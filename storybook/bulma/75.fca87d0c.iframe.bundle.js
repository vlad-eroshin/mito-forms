(self.webpackChunk_mito_forms_bulma=self.webpackChunk_mito_forms_bulma||[]).push([[75],{"../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  t3: () => (/* reexport */ dataSource_DataStatus),\n  pl: () => (/* reexport */ EditorContext),\n  kE: () => (/* reexport */ FormEditor),\n  dV: () => (/* reexport */ FormFieldset),\n  fW: () => (/* reexport */ ResultFormat),\n  Cx: () => (/* reexport */ buildCheckedValues),\n  Ok: () => (/* reexport */ buildEmptyRecordFromFields),\n  cM: () => (/* reexport */ convertInputOptions),\n  ux: () => (/* reexport */ fieldUtils_fetchJsonPath),\n  sx: () => (/* reexport */ generateReactKey),\n  kV: () => (/* reexport */ getFieldId),\n  JB: () => (/* reexport */ getFieldsetData),\n  Cc: () => (/* reexport */ useChangeHandler),\n  aS: () => (/* reexport */ useChecklistHandler),\n  mv: () => (/* reexport */ useOptionsChangeHandler),\n  Fr: () => (/* reexport */ useUtilComponent)\n});\n\n// UNUSED EXPORTS: AccessorType, ComponentTypeEnum, ConditionTypeEnum, DataAggregationMode, DataSourceType, DataType, FormInputField, SortOrder, TransformType, UnsupportedInputComponent, buildExpressionContext, buildFormStatesFromData, checkJsonPath, extractJsonPathString, fetchJsonPathValue, getInitialFieldSetData, isJsonPathExp, isNullOrUndefined, retrieveInputOptions, useCheckedHandler, useDecorator\n\n// EXTERNAL MODULE: ../../node_modules/.pnpm/react@19.1.0/node_modules/react/index.js\nvar react = __webpack_require__("../../node_modules/.pnpm/react@19.1.0/node_modules/react/index.js");\n// EXTERNAL MODULE: ../../node_modules/.pnpm/jmespath@0.16.0/node_modules/jmespath/jmespath.js\nvar jmespath = __webpack_require__("../../node_modules/.pnpm/jmespath@0.16.0/node_modules/jmespath/jmespath.js");\n// EXTERNAL MODULE: ../../node_modules/.pnpm/uuid-by-string@4.0.0/node_modules/uuid-by-string/src/index.js\nvar src = __webpack_require__("../../node_modules/.pnpm/uuid-by-string@4.0.0/node_modules/uuid-by-string/src/index.js");\nvar src_default = /*#__PURE__*/__webpack_require__.n(src);\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/utils/fieldUtils.js\n\n\nfunction isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n/**\n * Retrieve value from `data` object by json path.\n *\n * @param data\n * @param jsonPath\n */\nconst fieldUtils_fetchJsonPath = (data, jsonPath) => {\n    if (!jsonPath) {\n        return data;\n    }\n    const fetchedData = jmespath.search(data, jsonPath);\n    if (fetchedData) {\n        if (Array.isArray(fetchedData)) {\n            if (fetchedData.length === 1) {\n                return fetchedData[0];\n            }\n            else if (fetchedData.length === 0) {\n                return \'\';\n            }\n            return fetchedData;\n        }\n        return fetchedData;\n    }\n    else {\n        return \'\';\n    }\n};\n/**\n * Checks if the specified data exist in the context data\n *\n * @param contextData\n * @param jsonPath\n */\nconst checkJsonPath = (contextData, jsonPath) => {\n    const fetchedData = jmespath.search(contextData, jsonPath);\n    if (Array.isArray(fetchedData)) {\n        return fetchedData.length > 0;\n    }\n    return fetchedData;\n};\nconst getInitialFieldSetData = (inputData, fieldSet) => {\n    const fieldValues = {};\n    fieldSet.fields.forEach((fieldConf) => {\n        if (fieldConf.type === \'divider\') {\n            //Skip Divider field as it is not interractive\n            return;\n        }\n        let fetchedValue;\n        if (inputData) {\n            if (typeof fieldConf.value === \'function\') {\n                const rawValue = fieldConf.value(inputData);\n                fetchedValue = !isNullOrUndefined(rawValue) ? rawValue : fieldConf.default;\n            }\n            else if (isJsonPathExp(fieldConf.value)) {\n                const valueJsonPath = extractJsonPathString(fieldConf.value);\n                const rawValue = fieldUtils_fetchJsonPath(inputData, valueJsonPath) || inputData[fieldConf.name];\n                fetchedValue = !isNullOrUndefined(rawValue) ? rawValue : fieldConf.default;\n            }\n            else {\n                const rawValue = inputData[fieldConf.name];\n                fetchedValue = !isNullOrUndefined(rawValue)\n                    ? rawValue\n                    : fieldConf.value || fieldConf.default;\n            }\n            if (isJsonPathExp(fieldConf.options)) {\n                const jsonPath = extractJsonPathString(fieldConf.options);\n                const optionsRes = fieldUtils_fetchJsonPath(inputData, jsonPath) ||\n                    fieldUtils_fetchJsonPath(inputData, `${fieldConf.name}__options`);\n                fieldValues[`${fieldConf.name}__options`] = optionsRes\n                    ? Array.isArray(optionsRes)\n                        ? optionsRes\n                        : [optionsRes]\n                    : [];\n            }\n        }\n        else {\n            if (isJsonPathExp(fieldConf.value)) {\n                fetchedValue = fieldConf.default; // input data is not defined\n            }\n            else {\n                fetchedValue = fieldConf.value || fieldConf.default;\n            }\n        }\n        if (!isNullOrUndefined(fetchedValue)) {\n            fieldValues[fieldConf.name] = fetchedValue;\n        }\n    });\n    return fieldValues;\n};\n/**\n * Fetch initial field values for a given fieldset.\n *\n * @param inputData\n * @param fieldSetEntry\n */\nconst getFieldsetData = (inputData, fieldSetEntry) => {\n    let result;\n    if (!fieldSetEntry.type || fieldSetEntry.type === \'fieldSet\') {\n        const fieldSetInput = (fieldSetEntry.jsonPath ? fieldUtils_fetchJsonPath(inputData, fieldSetEntry.jsonPath) : inputData);\n        result = getInitialFieldSetData(fieldSetInput, fieldSetEntry);\n    }\n    else {\n        // Process records array\n        result = [];\n        const recordSetInput = (fieldSetEntry.jsonPath ? fieldUtils_fetchJsonPath(inputData, fieldSetEntry.jsonPath) : inputData);\n        if (!Array.isArray(recordSetInput)) {\n            return [];\n        }\n        recordSetInput.forEach((record) => {\n            result.push(getInitialFieldSetData(record, fieldSetEntry.rowFieldset));\n        });\n    }\n    return result;\n};\n/**\n * Check if expr is the string in the following format \'!{$.<sonPathstring>}\' example: {$.tagsSelector__options}\n * @param expr input string\n * @returns true if the input value is JSON path expression\n */\nconst isJsonPathExp = (expr) => {\n    if (typeof expr !== \'string\') {\n        return false;\n    }\n    const exprStr = expr;\n    return exprStr && exprStr.startsWith(\'!{\') && exprStr.endsWith(\'}\');\n};\n/**\n * From the input string in the format \'{$.<sonPathstring>}\' example: {$.tagsSelector__options}. extract only\n * json path option of it -> $.tagsSelector#option\n *\n * @param expr input string\n * @returns json path string or undefined\n */\nconst extractJsonPathString = (expr) => {\n    if (!isJsonPathExp(expr)) {\n        return undefined;\n    }\n    const strExpr = expr;\n    return strExpr.substring(2, strExpr.length - 1);\n};\n/**\n * Fetches value given by json path or json path expression !{<path>}\n *\n * @param contextData\n * @param exprOrJsonPath json path or json path expression !{<path>}\n */\nconst fetchJsonPathValue = (contextData, exprOrJsonPath) => {\n    const jsonPath = isJsonPathExp(exprOrJsonPath)\n        ? extractJsonPathString(exprOrJsonPath)\n        : exprOrJsonPath;\n    return fieldUtils_fetchJsonPath(contextData, jsonPath);\n};\n/**\n * For selector components input values (selected values) can go in\n * as comma separated string of values or it can be an array of strings or numbers\n * this function normalizes input by converting input values to array of strings.\n *\n * @param values input as string of comma separated values ("1,2,3") or array of [1, 2, 3] or [\'1\', \'2\', \'3\']\n *\n * @returns array of string values\n */\nconst buildCheckedValues = (values) => {\n    if (isNullOrUndefined(values)) {\n        return [];\n    }\n    if (Array.isArray(values)) {\n        return values.length > 0 ? values.join(\',\').split(\',\') : values;\n    }\n    else {\n        const trimmedVal = `${values}`.trim();\n        return trimmedVal ? `${trimmedVal}`.trim().split(\',\') : [];\n    }\n};\n/**\n * Converts options array (string | InputOption) into array of InputOptions for stable consumption by input fields\n *\n * @param options array of string options\n * @param checkedValues optional list of checked options\n * @returns array of Input Options\n */\nconst convertInputOptions = (options, checkedValues) => {\n    const convertedOptions = options\n        ? options.map(opt => {\n            const rawOpt = typeof opt === \'string\'\n                ? { label: opt, value: opt }\n                : opt;\n            return {\n                ...rawOpt,\n                checked: !!(checkedValues && checkedValues.indexOf(`${rawOpt.value}`) >= 0),\n                params: rawOpt.params || {},\n                disabled: !!rawOpt.disabled,\n            };\n        })\n        : [];\n    return convertedOptions;\n};\n/**\n * Checks if field has options passed down as JsonPath or as list of options and if it is JSON Path the corresponding json path is retrieved.\n * from the passed \'data\' object\n *\n */\nconst retrieveInputOptions = (field, data) => {\n    let rawOptions;\n    if (field.options && isJsonPathExp(field.options)) {\n        const optionsJsonPath = extractJsonPathString(field.options);\n        const optionsRes = fieldUtils_fetchJsonPath(data, optionsJsonPath) || fieldUtils_fetchJsonPath(data, `${field.name}__options`);\n        rawOptions = optionsRes ? (Array.isArray(optionsRes) ? optionsRes : [optionsRes]) : [];\n    }\n    else {\n        rawOptions = field.options;\n    }\n    if (typeof rawOptions === \'string\') {\n        return rawOptions.split(\',\');\n    }\n    else {\n        return rawOptions;\n    }\n};\nfunction getFieldId(fieldConfig, fieldIndex) {\n    return `${fieldConfig.type}-${fieldConfig.name}-${fieldIndex || 0}`;\n}\n/**\n * Generate react key\n *\n * @param seedValues\n */\nfunction generateReactKey(...seedValues) {\n    return src_default()(seedValues.join(\'-\'));\n}\n/**\n * Creates Expression Context\n *\n * @param state\n * @param context\n * @param additionalData\n */\nfunction buildExpressionContext(state, context, additionalData) {\n    return {\n        ...(additionalData || {}),\n        _CONTEXT: context,\n        _STATE: state,\n    };\n}\nfunction buildEmptyRecordFromFields(fields) {\n    const result = {};\n    fields.forEach(field => {\n        if (field.default) {\n            result[field.name] = field.default;\n            // if (field.type === \'select\') {\n            //   result[`${field.name}__options`] = field.options && isJsonPathExp(field.options);\n            // }\n        }\n    });\n    return result;\n}\n/**\n * Updates state from the passed input data for the editor.\n * Editor metadata how the data should be populated for each field and fieldset\n *\n * 1. Form Data retrieval :\n *    - if no jsonPath specified for the form data for the form will be editorData.\n *    - if jsonPath specified in the config first we perform lookup to that jsonPath\n *      and then pass what was retrieved is used as the Form Data.\n *\n * 2. Fieldset Data: Editor retrieves fieldset Data as following\n *    - by default fieldset data receives formData as an input refer to (1 above).\n *    - If jsonPath was provided then data is retrieved by that jsonPath from the containing form data.\n * 3. Field value Retrieval:\n *    - by default field value is retrieved from the editInput data by field name. Assuming no containing fieldset\n *      or form have jsonpath specified data for field is being lookced up in editorInput data object.\n *    - if value of the field is jsonPath expression (Example !{<path>}) then data is retrieved\n *      from that path in fieldset data.\n *\n *\n * @param editorMetadata\n * @param editorData\n */\nconst buildFormStatesFromData = (editorMetadata, editorData) => {\n    const result = {};\n    editorMetadata.forms.forEach(form => {\n        const formData = (form.jsonPath ? fieldUtils_fetchJsonPath(editorData, form.jsonPath) : editorData);\n        result[form.id] = {};\n        form.fieldSets.forEach(fieldSet => {\n            const fieldSetData = getFieldsetData(formData, fieldSet);\n            result[form.id][fieldSet.name] = { data: fieldSetData };\n        });\n    });\n    return result;\n};\n//# sourceMappingURL=fieldUtils.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/FormEditorReducer.js\n\n/**\n * Editor state reducer\n *\n * @param editorState\n * @param action\n */\nfunction editorStateReducer(editorState, action) {\n    const newEditorState = { ...editorState };\n    switch (action.type) {\n        case \'formChange\': {\n            const formChangePayload = action.payload;\n            const editorMetadata = formChangePayload.editorMetadata;\n            const reducersMap = formChangePayload.editorReducersMap;\n            if (!reducersMap) {\n                newEditorState.formStates[formChangePayload.formId] = {\n                    ...action.payload.data,\n                };\n                newEditorState.editorResult = updateEditorData(editorState.editorResult, formChangePayload);\n            }\n            else {\n                newEditorState.editorResult = updateEditorData(editorState.editorResult, formChangePayload, reducersMap);\n                newEditorState.formStates = buildFormStatesFromData(formChangePayload.editorMetadata, newEditorState.editorResult);\n            }\n            newEditorState.isValid = formChangePayload.isValid;\n            let k;\n            for (k in editorState.formStates) {\n                newEditorState.isValid =\n                    typeof editorState.formStates[k].isValid !== \'undefined\'\n                        ? !!editorState.formStates[k].isValid\n                        : formChangePayload.isValid;\n                if (!newEditorState.isValid) {\n                    break;\n                }\n            }\n            if (editorMetadata.resultValidator) {\n                const validatorResult = editorMetadata.resultValidator(newEditorState.editorResult);\n                newEditorState.isValid = formChangePayload.isValid && validatorResult.isValid;\n                newEditorState.validatorMessage = validatorResult.message;\n            }\n            return newEditorState;\n        }\n        case \'replace\': {\n            return { ...action.payload.data };\n        }\n    }\n    return newEditorState;\n}\n/**\n * Update editor data with Form Data (provided input field values).\n *\n * @param editorData raw edtior data\n * @param formChangePayload payload with the modified data\n * @param editorReducersMap map of editor reducers\n */\nconst updateEditorData = (editorData, formChangePayload, editorReducersMap) => {\n    const reducerMap = editorReducersMap;\n    const formId = formChangePayload.formId;\n    const fieldSetName = formChangePayload.fieldSetName;\n    const formReducers = reducerMap ? reducerMap[formId] : undefined;\n    const editorMetadata = formChangePayload.editorMetadata;\n    const formMetadata = editorMetadata.forms.find(form => form.id === formId);\n    if (!formMetadata) {\n        throw `Form not found: ${formId}`;\n    }\n    const fieldsetMetadata = formMetadata.fieldSets.find(fs => fs.name === fieldSetName);\n    const fieldSetReducer = formReducers?.[fieldSetName];\n    if (fieldsetMetadata && fieldSetReducer) {\n        const formData = formChangePayload.data[fieldSetName].data;\n        try {\n            const editorResult = fieldsetMetadata.type !== \'fieldSetList\'\n                ? fieldSetReducer(editorData, formData, formChangePayload.contextParams)\n                : fieldSetReducer(editorData, formData, formChangePayload.contextParams);\n            return editorResult;\n        }\n        catch (error) {\n            console.error(error);\n            throw `Error occured in Reducer for FORM: ${formId}, FIELDSET: ${fieldSetName}`;\n        }\n    }\n    else {\n        // if no reducer function registered record data as following\n        const newEditorData = { ...editorData };\n        newEditorData[formChangePayload.formId] = {\n            ...editorData[formChangePayload.formId],\n            ...formChangePayload.data,\n        };\n        return newEditorData;\n    }\n};\n//# sourceMappingURL=FormEditorReducer.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/types/common.js\nvar DataType;\n(function (DataType) {\n    DataType[DataType["String"] = 0] = "String";\n    DataType[DataType["Decimal"] = 1] = "Decimal";\n    DataType[DataType["Date"] = 2] = "Date";\n    DataType[DataType["Object"] = 3] = "Object";\n})(DataType || (DataType = {}));\nvar common_ConditionTypeEnum;\n(function (ConditionTypeEnum) {\n    ConditionTypeEnum[ConditionTypeEnum["Equal"] = 0] = "Equal";\n    ConditionTypeEnum[ConditionTypeEnum["NotEqual"] = 1] = "NotEqual";\n    ConditionTypeEnum[ConditionTypeEnum["Greater"] = 2] = "Greater";\n    ConditionTypeEnum[ConditionTypeEnum["Less"] = 3] = "Less";\n    ConditionTypeEnum[ConditionTypeEnum["Between"] = 4] = "Between";\n})(common_ConditionTypeEnum || (common_ConditionTypeEnum = {}));\nvar SortOrder;\n(function (SortOrder) {\n    SortOrder[SortOrder["Asc"] = 1] = "Asc";\n    SortOrder[SortOrder["Desc"] = 2] = "Desc";\n})(SortOrder || (SortOrder = {}));\n//# sourceMappingURL=common.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/types/dataBindings.js\nvar ComponentTypeEnum;\n(function (ComponentTypeEnum) {\n    ComponentTypeEnum[ComponentTypeEnum["Widget"] = 0] = "Widget";\n    ComponentTypeEnum[ComponentTypeEnum["DataSource"] = 1] = "DataSource";\n    ComponentTypeEnum[ComponentTypeEnum["EditorField"] = 2] = "EditorField";\n    ComponentTypeEnum[ComponentTypeEnum["Data"] = 3] = "Data";\n})(ComponentTypeEnum || (ComponentTypeEnum = {}));\nvar AccessorType;\n(function (AccessorType) {\n    AccessorType[AccessorType["DirectUsage"] = 0] = "DirectUsage";\n    AccessorType[AccessorType["Property"] = 1] = "Property";\n    AccessorType[AccessorType["JsonPath"] = 2] = "JsonPath";\n})(AccessorType || (AccessorType = {}));\nvar TransformType;\n(function (TransformType) {\n    TransformType[TransformType["Sort"] = 0] = "Sort";\n    TransformType[TransformType["RemapRecord"] = 1] = "RemapRecord";\n    TransformType[TransformType["RemapRecordsArray"] = 2] = "RemapRecordsArray";\n    TransformType[TransformType["MapToArray"] = 3] = "MapToArray";\n    TransformType[TransformType["DecorateObject"] = 4] = "DecorateObject";\n    TransformType[TransformType["ConvertNanoToMilliSeconds"] = 5] = "ConvertNanoToMilliSeconds";\n    TransformType[TransformType["GroupByField"] = 6] = "GroupByField";\n    TransformType[TransformType["ArrayJoin"] = 7] = "ArrayJoin";\n    TransformType[TransformType["InjectData"] = 8] = "InjectData";\n    TransformType[TransformType["FlattenHierarchy"] = 9] = "FlattenHierarchy";\n    TransformType[TransformType["MilliSecondsToTimestamp"] = 10] = "MilliSecondsToTimestamp";\n    TransformType[TransformType["RemapFieldValue"] = 11] = "RemapFieldValue";\n    TransformType[TransformType["FilterRecord"] = 12] = "FilterRecord";\n    TransformType[TransformType["SplitStrings"] = 13] = "SplitStrings";\n    TransformType[TransformType["UniqueValues"] = 14] = "UniqueValues";\n})(TransformType || (TransformType = {}));\n//# sourceMappingURL=dataBindings.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/types/dataSource.js\nvar DataSourceType;\n(function (DataSourceType) {\n    DataSourceType[DataSourceType["ApiCall"] = 0] = "ApiCall";\n    DataSourceType[DataSourceType["Static"] = 1] = "Static";\n    DataSourceType[DataSourceType["Aggregate"] = 2] = "Aggregate";\n})(DataSourceType || (DataSourceType = {}));\nvar DataAggregationMode;\n(function (DataAggregationMode) {\n    DataAggregationMode[DataAggregationMode["Append"] = 0] = "Append";\n})(DataAggregationMode || (DataAggregationMode = {}));\nvar ResultFormat;\n(function (ResultFormat) {\n    ResultFormat[ResultFormat["PandasDataFrame"] = 0] = "PandasDataFrame";\n    ResultFormat[ResultFormat["RecordsArray"] = 1] = "RecordsArray";\n    ResultFormat[ResultFormat["Object"] = 2] = "Object";\n    ResultFormat[ResultFormat["Any"] = 3] = "Any";\n})(ResultFormat || (ResultFormat = {}));\nvar dataSource_DataStatus;\n(function (DataStatus) {\n    DataStatus[DataStatus["Unknown"] = 0] = "Unknown";\n    DataStatus[DataStatus["NeedsRefresh"] = 1] = "NeedsRefresh";\n    DataStatus[DataStatus["Loading"] = 2] = "Loading";\n    DataStatus[DataStatus["Loaded"] = 3] = "Loaded";\n    DataStatus[DataStatus["Error"] = 4] = "Error";\n})(dataSource_DataStatus || (dataSource_DataStatus = {}));\n//# sourceMappingURL=dataSource.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/types/index.js\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/EditorContext.js\n\nconst EditorContext = (0,react.createContext)({\n    dataSources: {},\n    contextParams: {},\n    componentRegistry: {\n        inputFields: {},\n        utilityComponents: {},\n    },\n    editorState: {\n        formStates: {},\n        editorResult: {},\n    },\n});\n//# sourceMappingURL=EditorContext.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/UnsupportedInputComponent.js\n\nconst UnsupportedInputComponent = ({ config }) => {\n    return (react.createElement("div", { className: "unsupported-input" }, `[Unsupported Input Component type (${config.type}): name: (${config.name})]`));\n};\n//# sourceMappingURL=UnsupportedInputComponent.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/hooks/context/useInputFieldComponent.js\n\n\n\nconst useInputFieldComponent = (componentType) => {\n    const editorContextData = (0,react.useContext)(EditorContext);\n    const componentRegistry = (0,react.useMemo)(() => editorContextData.componentRegistry, [editorContextData.componentRegistry]);\n    return componentRegistry.inputFields[componentType] || UnsupportedInputComponent;\n};\n//# sourceMappingURL=useInputFieldComponent.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/hooks/useChangeHandler.js\n\nconst useChangeHandler = (config, onChange) => {\n    return (0,react.useCallback)((e) => {\n        if (onChange) {\n            onChange({ [config.name]: e.target.value });\n        }\n    }, [onChange, config]);\n};\n//# sourceMappingURL=useChangeHandler.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/hooks/useCheckedHandler.js\n\nconst useCheckedHandler = (config, onChange) => {\n    return useCallback((e) => {\n        if (onChange) {\n            debugger;\n            onChange({ [config.name]: e.target.checked });\n        }\n    }, [onChange, config]);\n};\n//# sourceMappingURL=useCheckedHandler.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/hooks/useChecklistHandler.js\n\nconst useChecklistHandler = (config, options, onChange) => {\n    const checkedOptionsMap = (0,react.useMemo)(() => {\n        const result = {};\n        options.forEach(opt => {\n            result[`${opt.value}`] = opt.checked;\n        });\n        return result;\n    }, [options]);\n    return (0,react.useCallback)((event) => {\n        const optId = event.target.value;\n        checkedOptionsMap[optId] = event.target.checked;\n        if (onChange) {\n            const result = options\n                .filter(opt => checkedOptionsMap[`${opt.value}`])\n                .map(opt => opt.value);\n            onChange({ [config.name]: result });\n        }\n    }, [checkedOptionsMap, config.name, onChange, options]);\n};\n//# sourceMappingURL=useChecklistHandler.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/hooks/useOptionsChangeHandler.js\n\nconst useOptionsChangeHandler = (config, options, onChange) => {\n    return (0,react.useCallback)((e) => {\n        const valueSelected = e.target.value;\n        const selectedOpt = options.find(opt => `${opt.value}` === `${valueSelected}`);\n        if (onChange && selectedOpt) {\n            onChange({ [config.name]: selectedOpt.value });\n        }\n    }, [options, onChange, config.name]);\n};\n//# sourceMappingURL=useOptionsChangeHandler.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/hooks/context/useUtilComponent.js\n\n\nconst useUtilComponent = (componentType) => {\n    const editorContextData = (0,react.useContext)(EditorContext);\n    return editorContextData.componentRegistry.utilityComponents[componentType];\n};\n//# sourceMappingURL=useUtilComponent.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/hooks/useDecorator.js\n\n\n/**\n * Use Decorator Hook used to retrieve field decorator\n */\nfunction useDecorator() {\n    const editorContextData = (0,react.useContext)(EditorContext);\n    const componentRegistry = (0,react.useMemo)(() => editorContextData.componentRegistry, [editorContextData.componentRegistry]);\n    const getFieldDecorator = (0,react.useCallback)((decoratorName) => componentRegistry.getFieldDecorator(decoratorName), [componentRegistry]);\n    const getFieldsetDecorator = (0,react.useCallback)((decoratorName) => componentRegistry.getFieldsetDecorator(decoratorName), [componentRegistry]);\n    const getListEditorDecorator = (0,react.useCallback)((decoratorName) => componentRegistry.getListEditorDecorator(decoratorName), [componentRegistry]);\n    return {\n        getFieldDecorator,\n        getFieldsetDecorator,\n        getListEditorDecorator,\n    };\n}\n//# sourceMappingURL=useDecorator.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/hooks/index.js\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/utils/index.js\n\n//# sourceMappingURL=index.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/FormInputField.js\n\n\n\n\n\nfunction FormInputField({ config, value, onChange, options, label, status, fieldIndex = 0, isValid = true, validationErrors, fieldLayout, }) {\n    const InputCMP = useInputFieldComponent(config.type);\n    const { getFieldDecorator } = useDecorator();\n    const fieldDecoratorName = getFieldDecoratorName(fieldLayout, config);\n    const FieldDecorator = getFieldDecorator(fieldDecoratorName);\n    const inputId = getFieldId(config, fieldIndex);\n    const LoadingIndicator = useUtilComponent(\'loading\');\n    return (react.createElement(FieldDecorator, { id: inputId, label: label, helpText: config.helpText, required: config.required, customProps: config.customProps, controlElement: status !== dataSource_DataStatus.Loaded ? (react.createElement(LoadingIndicator, { size: "small" })) : (react.createElement(InputCMP, { config: config, value: value, label: label, onChange: onChange, options: options, isValid: isValid, validationErrors: validationErrors, fieldLayout: fieldLayout, fieldIndex: fieldIndex, status: status })), status: status, isValid: isValid, validationErrors: validationErrors }));\n}\nconst getFieldDecoratorName = (fieldLayout, fieldConfig) => {\n    if (fieldConfig.fieldDecorator) {\n        return fieldConfig.fieldDecorator;\n    }\n    if (fieldLayout === \'compact\') {\n        return \'compactField\';\n    }\n    else if (fieldLayout === \'twoColumn\') {\n        return \'horizontalField\';\n    }\n    else if (fieldLayout === \'twoColumnJustified\') {\n        return \'horizontalJustifiedFieldd\';\n    }\n    else {\n        return \'compactField\';\n    }\n};\n//# sourceMappingURL=FormInputField.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/validators/email.js\n// Simple validation of whether a string is an email\n// this is not exhaustive -- the exhaustive regex is complex and\n// unnecessary for our purposes.\n// https://stackoverflow.com/a/4964766\nconst validateSimpleEmail = (email) => {\n    return /^\\S+@\\S+\\.\\S+$/u.test(email);\n};\n//# sourceMappingURL=email.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/validators/number.js\n/**\n * Validates if the input string is a number\n *\n * @param value input string\n * @param min optional min\n * @param max ptional max\n * @returns\n */\nconst validateNumberField = (value, min, max) => {\n    const res = !value || !isInteger(value) ? [\'This field must be a valid number.\', undefined] : true;\n    if (res !== true) {\n        return res;\n    }\n    const minValue = Number.isInteger(min) ? min : Number.MIN_VALUE;\n    const maxValue = Number.isInteger(max) ? max : Number.MAX_VALUE;\n    const intValue = parseInt(value, 10);\n    if (intValue < minValue) {\n        return [`This field must be greater than ${minValue}.`, undefined];\n    }\n    if (intValue > maxValue) {\n        return [`This field must be less than ${maxValue}.`, undefined];\n    }\n    return true;\n};\nconst validateRequiredField = (value, errorMessage) => {\n    if (typeof value === \'boolean\') {\n        return true;\n    }\n    else if (!value) {\n        return [errorMessage || \'This field is required\'];\n    }\n    return true;\n};\n/**\n * Checks if the string is integer\n * @param value inpiut string\n * @returns true/false\n */\nconst isInteger = (value) => {\n    return value ? /^-?\\d+$/u.test(value) : false;\n};\n//# sourceMappingURL=number.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/validators/index.js\n\n\nconst getValidatorFunction = (typeOrFn, field) => {\n    if (typeof typeOrFn === \'function\') {\n        return typeOrFn;\n    }\n    const validatorType = typeOrFn;\n    switch (validatorType) {\n        case \'required\': {\n            return value => {\n                return validateRequiredField(value);\n            };\n        }\n        case \'number\':\n            return ((value) => {\n                return validateNumberField(value, field?.minValue, field?.maxValue);\n            });\n        case \'string\':\n            return ((value) => {\n                return value != null;\n            });\n        case \'emailMultiline\':\n            // Validates that the value is a multiline string\n            // with every line being a valid email\n            return (value) => {\n                const emails = value?.split(\'\\n\');\n                if (!emails) {\n                    return true;\n                }\n                for (const email of emails) {\n                    if (!validateSimpleEmail(email)) {\n                        return `"${email}" is not a valid email`;\n                    }\n                }\n                return true;\n            };\n        default:\n            return ((_value) => {\n                return [\'\', undefined];\n            });\n    }\n};\n//# sourceMappingURL=index.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/data/accessor/resolveAccessor.js\n\n\n/**\n * Resolve accessor on the specified data object\n *\n * @param data\n * @param accessor\n */\nconst resolveAccessor = (data, accessor) => {\n    if (!data) {\n        return null;\n    }\n    const accessorType = accessor.type;\n    switch (accessorType) {\n        case AccessorType.Property: {\n            if (!accessor.property) {\n                return null;\n            }\n            return data[accessor.property];\n        }\n        case AccessorType.JsonPath: {\n            const resolvedData = accessor.jsonPath ? jmespath.search(data, accessor.jsonPath) : data;\n            return Array.isArray(resolvedData) && resolvedData.length === 1\n                ? resolvedData[0]\n                : resolvedData;\n        }\n        default:\n            return data;\n    }\n};\n//# sourceMappingURL=resolveAccessor.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/data/accessor/index.js\n\n//# sourceMappingURL=index.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/data/DataUtils.js\n\n\n\n//import { transformData } from \'./transformer\';\nconst transformData = (dataObject, _transformers, _origData) => {\n    //DUMMY implementation of missing transform Data function\n    return dataObject;\n};\nconst evaluateLogicCondition = (conditionInfo, dataValue) => {\n    switch (conditionInfo.type) {\n        case ConditionTypeEnum.Equal: {\n            return conditionInfo.value === dataValue;\n        }\n        case ConditionTypeEnum.Greater: {\n            const dataType = typeof conditionInfo.value;\n            if (dataType === \'number\' || dataType === \'string\') {\n                return conditionInfo.value > (dataValue || 0);\n            }\n            return false;\n        }\n        case ConditionTypeEnum.Less: {\n            const dataType = typeof conditionInfo.value;\n            if (dataType === \'number\' || dataType === \'string\') {\n                return conditionInfo.value < (dataValue || 0);\n            }\n            return false;\n        }\n        case ConditionTypeEnum.Between: {\n            const dataType = typeof conditionInfo.value;\n            if (dataType === \'number\' || dataType === \'string\') {\n                return (conditionInfo.value < (dataValue || 0) && (dataValue || 0) < (conditionInfo.value2 || 0));\n            }\n            return false;\n        }\n        case ConditionTypeEnum.NotEqual: {\n            return conditionInfo.value !== dataValue;\n        }\n    }\n};\n/**\n * Evaluates logic\n *\n * @param expression\n * @param contextData\n */\nconst evaluateLogicInContext = (expression, contextData) => {\n    if (typeof expression === \'boolean\') {\n        return expression;\n    }\n    if (isJsonPathExp(expression)) {\n        const jsonPath = extractJsonPathString(expression);\n        return checkJsonPath(contextData, jsonPath);\n    }\n    else {\n        return !!expression;\n    }\n};\nconst evaluateConditionInContext = (condition, contextData) => {\n    const valueField = condition.value; // Treating value as JSON PATH\n    const value = fetchJsonPath(contextData, valueField);\n    if ((value === \'\' || typeof value !== \'object\' || value === null) &&\n        !evaluateLogicCondition({ ...condition, value: (value || \'\') }, condition.value2)) {\n        return false;\n    }\n    else {\n        return true;\n    }\n};\nconst accessAndTransformData = (dataObject, accessor, transformers) => {\n    const accessedData = !accessor ? dataObject : resolveAccessor(dataObject, accessor);\n    return !transformers ? accessedData : transformData(accessedData, transformers, dataObject);\n};\nconst dataSourceHasRequiredParams = (dataSource, params) => {\n    if (dataSource.action.requiredParams) {\n        const dsParams = {\n            ...dataSource.action.params,\n            ...dataSource.action.urlParams,\n            ...params,\n        };\n        const notDefinedParams = dataSource.action.requiredParams.filter(param => !dsParams[param]);\n        return notDefinedParams.length === 0;\n    }\n    return true;\n};\n/**\n * Regex to test if property intends to access element in the array example \'prop[10]\'\n */\nconst ARRAY_ELEMENT_INDEX_RX = /^(\\w+)\\[(\\d+)\\].*?/u;\n/**\n * Inserts property value into object several levels down the hierarchy\n * Arrays are supported too.\n * example if there is data as {} this function can insert value as this\n * {top: { lower: {value: "test" }}} if the target Path specified as \'top.lower.value\' and the value as \'test\'.\n *\n *\n * @param data\n * @param targetPathStr\n * @param value\n */\nconst injectPropertyValue = (data, targetPathStr, value) => {\n    const propPath = targetPathStr.split(\'.\');\n    let currentObj = data;\n    propPath.forEach((prop, i) => {\n        if (typeof currentObj !== \'object\') {\n            console.error(\'Attempting to inject value into incompatible type.\');\n            return;\n        }\n        if (i === propPath.length - 1) {\n            setProperty(currentObj, prop, value);\n            return;\n        }\n        const holderObj = getProperty(currentObj, prop);\n        if (!holderObj) {\n            setProperty(currentObj, prop, {});\n            currentObj = getProperty(currentObj, prop);\n        }\n        else {\n            currentObj = holderObj;\n        }\n    });\n};\nconst setProperty = (data, prop, value) => {\n    const dataAsParams = data;\n    const matchArr = prop.match(ARRAY_ELEMENT_INDEX_RX);\n    if (matchArr) {\n        let arrayObj = accessArray(dataAsParams, prop);\n        if (!arrayObj) {\n            arrayObj = dataAsParams[matchArr[1]] = [];\n        }\n        const arrayInd = parseInt(matchArr[2], 10);\n        arrayObj[arrayInd] = value;\n    }\n    else if (typeof data === \'object\') {\n        dataAsParams[prop] = value;\n    }\n};\nconst getProperty = (data, prop) => {\n    const dataAsParams = data;\n    const matchArr = prop.match(ARRAY_ELEMENT_INDEX_RX);\n    if (matchArr) {\n        const arrayObj = accessArray(dataAsParams, prop);\n        if (arrayObj) {\n            const arrayInd = parseInt(matchArr[2], 10);\n            return arrayObj[arrayInd];\n        }\n        else {\n            return null;\n        }\n    }\n    else if (typeof data === \'object\') {\n        return dataAsParams[prop];\n    }\n    return undefined;\n};\nconst accessArray = (data, prop) => {\n    const dataAsParams = data;\n    const matchArr = prop.match(ARRAY_ELEMENT_INDEX_RX);\n    if (matchArr) {\n        const arrayName = matchArr[1];\n        if (!Array.isArray(dataAsParams[arrayName])) {\n            console.error(\'Attempting to inject value into incompatible type.\');\n            return;\n        }\n        return dataAsParams[arrayName];\n    }\n    return undefined;\n};\n//# sourceMappingURL=DataUtils.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/data/StaticDatasource.js\n\nconst refreshStaticDatasource = (config, _browserUrlParams) => {\n    const staticAction = config.action;\n    const data = staticAction.staticData;\n    return new Promise(resolve => {\n        resolve({\n            id: config.id,\n            status: DataStatus.Loaded,\n            resultFormat: config.resultFormat,\n            data,\n        });\n    });\n};\n//# sourceMappingURL=StaticDatasource.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/data/index.js\n\n\n//# sourceMappingURL=index.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/hooks/useFieldsetState.js\n\n\n\n\n\nfunction useFieldsetState(config) {\n    const editorContextData = (0,react.useContext)(EditorContext);\n    const editorState = (0,react.useMemo)(() => editorContextData.editorState, [editorContextData.editorState]);\n    const fieldsLayout = (0,react.useMemo)(() => config.fieldsLayout || editorContextData.fieldsLayout, [config, editorContextData.fieldsLayout]);\n    const dataSourceStates = (0,react.useMemo)(() => editorContextData.dataSources, [editorContextData.dataSources]);\n    /**\n     * Populates field data by evaluating data binding and retrieving data from them\n     */\n    const populateFieldData = (0,react.useCallback)((field, inputData) => {\n        const options = retrieveInputOptions(field, inputData);\n        const genericInputFieldConfig = {\n            ...field,\n        };\n        genericInputFieldConfig[\'options\'] = options;\n        if (typeof field.disabled === \'string\') {\n            genericInputFieldConfig[\'disabled\'] = evaluateLogicInContext(field.disabled, buildExpressionContext(editorState.formStates, editorContextData.contextParams, inputData));\n        }\n        let value = inputData ? inputData[field.name] : null;\n        let componentDataStatus = dataSource_DataStatus.Loaded;\n        if (field.dataBindings) {\n            field.dataBindings.forEach((dataBinding) => {\n                const dataSourceState = dataSourceStates[dataBinding.datasourceId];\n                if (dataSourceState && dataSourceState.status === dataSource_DataStatus.Loaded) {\n                    const propData = accessAndTransformData(dataSourceState.data, dataBinding.accessor, dataBinding.transformers);\n                    if (dataBinding.targetProperty === \'value\') {\n                        value = propData;\n                    }\n                    else if (dataBinding.targetProperty) {\n                        genericInputFieldConfig[dataBinding.targetProperty] = propData;\n                    }\n                }\n                else {\n                    componentDataStatus = dataSource_DataStatus.Loading;\n                }\n            });\n        }\n        return { fieldConfig: genericInputFieldConfig, componentDataStatus, value };\n    }, [dataSourceStates, editorContextData.contextParams, editorState.formStates]);\n    const getVisibleFields = (0,react.useCallback)(fieldSetData => {\n        return config.fields.filter(field => {\n            return field.render\n                ? evaluateLogicInContext(field.render, buildExpressionContext(editorState.formStates, editorContextData.contextParams, fieldSetData))\n                : true;\n        });\n    }, [config.fields, editorContextData.contextParams, editorState]);\n    return {\n        getVisibleFields,\n        fieldsLayout,\n        populateFieldData,\n    };\n}\n//# sourceMappingURL=useFieldsetState.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/FormFieldset.js\n\n\n\n\n\n\nfunction FormFieldset({ config, inputData, onChange, rowIndex = -1, onRowDelete, showFieldLabels = true, }) {\n    const arrangeFields = config.arrangeFields || \'column\';\n    const [fieldsValidationState, setFieldValidationState] = (0,react.useState)({});\n    const fieldSetValues = inputData;\n    const [collapsed, setCollapsed] = (0,react.useState)(!!config.collapsible && !!config.collapsed);\n    const { getVisibleFields, populateFieldData, fieldsLayout } = useFieldsetState(config);\n    const FormDivider = useUtilComponent(\'divider\');\n    const visibleFormFields = getVisibleFields(inputData);\n    const showTitle = config.showTitle !== undefined ? config.showTitle : true;\n    const { getFieldsetDecorator } = useDecorator();\n    const defaultDecoratorName = getFieldsetDecoratorName(arrangeFields);\n    const decoratorName = config.fieldSetDecorator || defaultDecoratorName;\n    const FieldSetDecorator = getFieldsetDecorator(decoratorName);\n    const isFieldSetValid = (0,react.useCallback)((fieldsData) => {\n        const tmpValidationStates = {};\n        for (let i = 0; i < visibleFormFields.length; i++) {\n            const field = visibleFormFields[i];\n            if (field.type === \'divider\') {\n                continue;\n            }\n            const value = fieldsData[field.name];\n            if (field.required) {\n                const validatorFn = getValidatorFunction(\'required\', field);\n                const validationRes = validatorFn(value);\n                if (validationRes !== true) {\n                    tmpValidationStates[field.name] = {\n                        isValid: false,\n                        validationErrors: validationRes,\n                    };\n                    setFieldValidationState(tmpValidationStates);\n                    return false;\n                }\n            }\n            if (field.validator) {\n                const validatorFn = getValidatorFunction(field.validator, field);\n                const validationRes = validatorFn(value);\n                if (validationRes !== true) {\n                    tmpValidationStates[field.name] = {\n                        isValid: false,\n                        validationErrors: validationRes,\n                    };\n                    setFieldValidationState(tmpValidationStates);\n                    return false;\n                }\n            }\n        }\n        setFieldValidationState(tmpValidationStates);\n        return true;\n    }, [visibleFormFields]);\n    const handleCollapsExpand = (0,react.useCallback)(() => {\n        setCollapsed(!collapsed);\n    }, [collapsed]);\n    const handleFieldChange = (0,react.useCallback)((params) => {\n        const newFieldSetData = {\n            ...fieldSetValues,\n            ...params,\n        };\n        if (onChange) {\n            const fieldSetIsValid = isFieldSetValid(newFieldSetData);\n            onChange(newFieldSetData, fieldSetIsValid);\n        }\n    }, [fieldSetValues, isFieldSetValid, onChange]);\n    const renderFields = (fields) => {\n        return fields.map((field, fieldIndex) => {\n            if (field.type === \'divider\') {\n                return (react.createElement(FormDivider, { key: generateReactKey(\'divider\', `${fieldIndex}`), config: field }));\n            }\n            const { fieldConfig, componentDataStatus, value } = populateFieldData(field, inputData);\n            const validationResult = fieldsValidationState[field.name];\n            const isValidField = validationResult ? validationResult.isValid : true;\n            return (react.createElement(FormInputField, { key: generateReactKey(config.name, field.type, field.name), value: value, label: showFieldLabels ? field.label : undefined, options: fieldConfig.options, config: fieldConfig, onChange: handleFieldChange, status: componentDataStatus, isValid: isValidField, validationErrors: validationResult?.validationErrors || [], fieldLayout: fieldsLayout }));\n        });\n    };\n    return (react.createElement(FieldSetDecorator, { onCollapse: handleCollapsExpand, legend: showTitle ? config.title : undefined, collapsible: config.collapsible, collapsed: collapsed, config: config, onRowDelete: onRowDelete, rowIndex: rowIndex }, renderFields(visibleFormFields)));\n}\nfunction getFieldsetDecoratorName(arrangeFields) {\n    switch (arrangeFields) {\n        case \'tableRow\':\n            return \'tableRowFieldset\';\n        case \'column\':\n            return \'columnFieldset\';\n        case \'row\':\n            return \'rowFieldset\';\n        default:\n            return \'columnFieldset\';\n    }\n}\n//# sourceMappingURL=FormFieldset.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/hooks/useFormState.js\n\n\n\n\nconst useFormState = (formConfig) => {\n    const editorContextData = (0,react.useContext)(EditorContext);\n    const editorState = (0,react.useMemo)(() => editorContextData.editorState, [editorContextData.editorState]);\n    const formState = (0,react.useMemo)(() => editorState.formStates[formConfig.id], [formConfig, editorState]);\n    const getFieldsetState = (0,react.useCallback)((fieldsetName) => {\n        return formState ? formState[fieldsetName] : {};\n    }, [formState]);\n    const getVisibleFieldSets = (0,react.useCallback)(() => {\n        return formConfig.fieldSets.filter(fieldSetEntry => {\n            if (fieldSetEntry.render) {\n                return evaluateLogicInContext(fieldSetEntry.render, buildExpressionContext(editorState.formStates, editorContextData.contextParams));\n            }\n            return true;\n        });\n    }, [editorContextData.contextParams, editorState, formConfig.fieldSets]);\n    return { formState, getFieldsetState, getVisibleFieldSets };\n};\n//# sourceMappingURL=useFormState.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/hooks/useEditorMetadata.js\n\n\nconst useEditorMetadata = () => {\n    const editorContextData = (0,react.useContext)(EditorContext);\n    return (0,react.useMemo)(() => editorContextData.editorMetadata, [editorContextData.editorMetadata]);\n};\n//# sourceMappingURL=useEditorMetadata.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/InputForm.js\n\n\n\n\n\n\nfunction InputForm({ config, onChange, showTitle = true, }) {\n    const { getFieldsetState, formState, getVisibleFieldSets } = useFormState(config);\n    const editorMetadata = useEditorMetadata();\n    const visibleFieldSets = getVisibleFieldSets();\n    const { getListEditorDecorator } = useDecorator();\n    const handleFieldsetChange = (0,react.useCallback)((freshData, name, isFieldsetValid) => {\n        const fieldsetValuesEntry = getFieldsetState(name);\n        const newData = { ...formState };\n        newData[name] = {\n            data: (fieldsetValuesEntry\n                ? Array.isArray(fieldsetValuesEntry.data)\n                    ? [...freshData]\n                    : { ...fieldsetValuesEntry.data, ...freshData }\n                : freshData),\n            isValid: isFieldsetValid,\n        };\n        onChange(newData, config.id, name, isFormValid(newData, isFieldsetValid));\n    }, [getFieldsetState, formState, onChange, config.id]);\n    const isShowTitle = editorMetadata.displayAs === \'tabSet\' ? false : showTitle && config.title;\n    return (react.createElement(react.Fragment, null,\n        react.createElement("form", null,\n            isShowTitle ? react.createElement("h2", null, config.title) : react.createElement(react.Fragment, null),\n            visibleFieldSets.map((fieldSetEntry, i) => {\n                const fieldSetData = formState ? formState[fieldSetEntry.name] : { data: {} };\n                if (fieldSetEntry.type === \'fieldSetList\') {\n                    const listEditorConfig = fieldSetEntry;\n                    const id = generateReactKey(config.id, listEditorConfig.name);\n                    const ListEditor = getListEditorDecorator(listEditorConfig.decorator || \'default\');\n                    return (react.createElement("fieldset", { key: id, className: \'mf-fieldset\' },\n                        listEditorConfig.label && react.createElement("legend", null, listEditorConfig.label),\n                        react.createElement(ListEditor, { name: fieldSetEntry.name, rowFieldset: listEditorConfig.rowFieldset, data: fieldSetData.data || [], canDeleteRows: listEditorConfig.canDeleteRows, onChange: (newData, isValid) => handleFieldsetChange(newData, fieldSetEntry.name, isValid), showHeader: listEditorConfig.showHeader, showBorders: listEditorConfig.showBorders, canAddRows: listEditorConfig.canAddRows })));\n                }\n                else\n                    return (react.createElement(FormFieldset, { key: generateReactKey(config.id, fieldSetEntry.name, fieldSetEntry.type), config: fieldSetEntry, inputData: fieldSetData.data || {}, onChange: (newFieldSetData, isValid) => handleFieldsetChange(newFieldSetData, fieldSetEntry.name, isValid) }));\n            })),\n        react.createElement("br", null)));\n}\nconst isFormValid = (newData, valid) => {\n    let k;\n    for (k in newData) {\n        valid = typeof newData[k].isValid !== \'undefined\' ? newData[k].isValid : valid;\n        if (!valid) {\n            return false;\n        }\n    }\n    return true;\n};\n//# sourceMappingURL=InputForm.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/FormsContainer.js\n\n\n\n\nfunction FormsContainer({ forms, onFormChange, displayAs = \'tabSet\', activeForm, }) {\n    const [activeTab, setActiveTab] = (0,react.useState)(activeForm);\n    const TabbedSection = useUtilComponent(\'tabbedSection\');\n    const handleSwitchTab = (0,react.useCallback)((tabId) => {\n        setActiveTab(tabId);\n    }, []);\n    if (displayAs === \'tabSet\') {\n        const tabs = forms.map((formConfig, i) => {\n            return {\n                id: formConfig.id,\n                label: formConfig.title,\n                content: (react.createElement(InputForm, { key: generateReactKey(\'configForm\', formConfig.id), config: formConfig, onChange: onFormChange })),\n            };\n        });\n        return react.createElement(TabbedSection, { selected: activeTab, onTab: handleSwitchTab, tabs: tabs });\n    }\n    else {\n        return (react.createElement(react.Fragment, null, forms.map((formConfig, i) => {\n            return (react.createElement(InputForm, { key: generateReactKey(\'configForm\', formConfig.id), showTitle: formConfig.showTitle, config: formConfig, onChange: onFormChange }));\n        })));\n    }\n}\nFormsContainer.displayName = \'FormsContainer\';\n//# sourceMappingURL=FormsContainer.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/FormEditor.js\n\n\n\n\n\nfunction FormEditor({ editorMetadata, initialData, onChange, dataSourceStates, throttleChange, changeInterval = 1000, componentRegistry, contextParams, editorRef, }) {\n    const { isValid, message: validatorMessage = undefined } = editorMetadata.resultValidator\n        ? editorMetadata.resultValidator(initialData)\n        : { isValid: true };\n    const [editorState, dispatchStateAction] = (0,react.useReducer)(editorStateReducer, {\n        //build initial state from the provided input\n        editorResult: initialData,\n        formStates: {},\n        isValid,\n        validatorMessage,\n    }, (initialState) => ({\n        ...initialState,\n        formStates: buildFormStatesFromData(editorMetadata, initialData),\n    }));\n    // Change time out is used for throtling changes - to minimize frequency of how often onChange handler is invoked\n    //const [changeTimeout, setChangeTimeout] = useState<NodeJS.Timeout | undefined>(undefined);\n    const changeTimeoutRef = (0,react.useRef)(undefined);\n    (0,react.useImperativeHandle)(editorRef, () => {\n        return {\n            setData: (newData) => {\n                const payload = {\n                    data: {\n                        formStates: buildFormStatesFromData(editorMetadata, newData),\n                        editorResult: newData,\n                    },\n                };\n                dispatchStateAction({\n                    payload: payload,\n                    type: \'replace\',\n                });\n            },\n        };\n    });\n    // Editor context Data stores data source state and editor state\n    const editorContextData = (0,react.useMemo)(() => ({\n        dataSources: dataSourceStates || {},\n        componentRegistry,\n        editorState,\n        editorMetadata,\n        contextParams,\n        fieldsLayout: editorMetadata.fieldsLayout || \'compact\',\n    }), [dataSourceStates, componentRegistry, editorState, editorMetadata, contextParams]);\n    const LoadingComponent = componentRegistry.utilityComponents.loading;\n    //Handler for certain form change\n    const handleFormChange = (0,react.useCallback)((freshFormData, formName, fieldSetName, isFormValid) => {\n        const hasReducers = editorMetadata.reducersMap && Object.keys(editorMetadata.reducersMap).length > 0;\n        const changePayload = {\n            formId: formName,\n            fieldSetName,\n            data: freshFormData,\n            isValid: isFormValid,\n            editorMetadata,\n            editorReducersMap: hasReducers ? editorMetadata.reducersMap : undefined,\n            contextParams: editorContextData.contextParams,\n        };\n        dispatchStateAction({\n            type: \'formChange\',\n            payload: changePayload,\n        });\n    }, [editorMetadata, editorContextData]);\n    const scheduleOnChange = (0,react.useCallback)((editorResult) => {\n        console.log(\'Editor will submit changes in: \', `${changeInterval}Ms`);\n        const newTimeout = setTimeout(() => {\n            console.log(\'Editor submitted Changes.\');\n            changeTimeoutRef.current = undefined;\n            onChange(editorResult, true);\n        }, changeInterval);\n        return newTimeout;\n    }, [changeInterval, onChange]);\n    (0,react.useEffect)(() => {\n        // Captures editor state change and calls onChange handler.\n        const isFormValid = !!editorState.isValid;\n        const editorResult = editorState.editorResult;\n        if (!isValid) {\n            onChange(editorResult, isValid, editorState.validatorMessage);\n            return;\n        }\n        if (editorResult === initialData /*|| equal(editorResult, initialData)*/) {\n            return;\n        }\n        if (throttleChange) {\n            if (changeTimeoutRef.current) {\n                clearTimeout(changeTimeoutRef.current);\n            }\n            changeTimeoutRef.current = scheduleOnChange(editorResult);\n        }\n        else {\n            onChange(editorResult, isFormValid, editorState.validatorMessage);\n        }\n        /**\n         * In order for the throttle change to work properly and avoid infinite loop this effect cannot depend on the timeout\n         * Need the line below `eslint-disable-next-line react-hooks/exhaustive-deps`\n         */\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [editorState, initialData, onChange, scheduleOnChange]);\n    return (react.createElement("div", { className: "config-editor" },\n        react.createElement("div", { className: "editor-status" }, changeTimeoutRef.current && (react.createElement("div", { className: "info" },\n            react.createElement(LoadingComponent, { loadingText: \'Applying changes...\' })))),\n        react.createElement(EditorContext.Provider, { value: editorContextData },\n            react.createElement(FormsContainer, { displayAs: editorMetadata.displayAs || \'onePage\', activeForm: editorMetadata.activeForm || editorMetadata.forms[0]?.id, forms: editorMetadata.forms, onFormChange: handleFormChange }))));\n}\n//# sourceMappingURL=FormEditor.js.map\n;// ../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/index.js\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtaXRvLWZvcm1zK2NvcmVAMC4yLjIzLWJldGFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQG1pdG8tZm9ybXMvY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0M7QUFDVTtBQUNuQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxNQUFNLHdCQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx3QkFBd0IsZUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdCQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdCQUFhO0FBQ2hELG9CQUFvQix3QkFBYSxlQUFlLGVBQWU7QUFDL0QsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx3REFBd0Qsd0JBQWE7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx3QkFBYTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QixxQkFBVztBQUN4QywwREFBMEQsZUFBZTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxJQUFJLG1CQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksbUJBQW1CLFVBQVUsNEJBQTRCO0FBQ3JFLFFBQVEsbUJBQW1CLFVBQVUsNEJBQTRCLCtCQUErQixtQkFBbUIsVUFBVSxtQkFBbUI7QUFDaEosWUFBWSxtQkFBbUIscUJBQXFCLG9DQUFvQztBQUN4RixRQUFRLG1CQUFtQixDQUFDLGFBQWEsYUFBYSwwQkFBMEI7QUFDaEYsWUFBWSxtQkFBbUIsQ0FBQyxjQUFjLElBQUkscUxBQXFMO0FBQ3ZPO0FBQ0Esc0M7O0FDMUc2QjtBQUNJO0FBQ0Y7QUFDUDtBQUNBO0FBQ0E7QUFDUTtBQUN3QztBQUN4RSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtaXRvLWZvcm1zL2J1bG1hLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWl0by1mb3Jtcytjb3JlQDAuMi4yMy1iZXRhX3R5cGVzY3JpcHRANS44LjMvbm9kZV9tb2R1bGVzL0BtaXRvLWZvcm1zL2NvcmUvZGlzdC91dGlscy9maWVsZFV0aWxzLmpzPzVhODAiLCJ3ZWJwYWNrOi8vQG1pdG8tZm9ybXMvYnVsbWEvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtaXRvLWZvcm1zK2NvcmVAMC4yLjIzLWJldGFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQG1pdG8tZm9ybXMvY29yZS9kaXN0L0Zvcm1FZGl0b3JSZWR1Y2VyLmpzPzEzNDQiLCJ3ZWJwYWNrOi8vQG1pdG8tZm9ybXMvYnVsbWEvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtaXRvLWZvcm1zK2NvcmVAMC4yLjIzLWJldGFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQG1pdG8tZm9ybXMvY29yZS9kaXN0L3R5cGVzL2NvbW1vbi5qcz84MGRhIiwid2VicGFjazovL0BtaXRvLWZvcm1zL2J1bG1hLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWl0by1mb3Jtcytjb3JlQDAuMi4yMy1iZXRhX3R5cGVzY3JpcHRANS44LjMvbm9kZV9tb2R1bGVzL0BtaXRvLWZvcm1zL2NvcmUvZGlzdC90eXBlcy9kYXRhQmluZGluZ3MuanM/ZTM5OSIsIndlYnBhY2s6Ly9AbWl0by1mb3Jtcy9idWxtYS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1pdG8tZm9ybXMrY29yZUAwLjIuMjMtYmV0YV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AbWl0by1mb3Jtcy9jb3JlL2Rpc3QvdHlwZXMvZGF0YVNvdXJjZS5qcz80MDI2Iiwid2VicGFjazovL0BtaXRvLWZvcm1zL2J1bG1hLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWl0by1mb3Jtcytjb3JlQDAuMi4yMy1iZXRhX3R5cGVzY3JpcHRANS44LjMvbm9kZV9tb2R1bGVzL0BtaXRvLWZvcm1zL2NvcmUvZGlzdC90eXBlcy9pbmRleC5qcz9mYzAwIiwid2VicGFjazovL0BtaXRvLWZvcm1zL2J1bG1hLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWl0by1mb3Jtcytjb3JlQDAuMi4yMy1iZXRhX3R5cGVzY3JpcHRANS44LjMvbm9kZV9tb2R1bGVzL0BtaXRvLWZvcm1zL2NvcmUvZGlzdC9FZGl0b3JDb250ZXh0LmpzP2M5NzgiLCJ3ZWJwYWNrOi8vQG1pdG8tZm9ybXMvYnVsbWEvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtaXRvLWZvcm1zK2NvcmVAMC4yLjIzLWJldGFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQG1pdG8tZm9ybXMvY29yZS9kaXN0L1Vuc3VwcG9ydGVkSW5wdXRDb21wb25lbnQuanM/ZDYwOSIsIndlYnBhY2s6Ly9AbWl0by1mb3Jtcy9idWxtYS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1pdG8tZm9ybXMrY29yZUAwLjIuMjMtYmV0YV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AbWl0by1mb3Jtcy9jb3JlL2Rpc3QvaG9va3MvY29udGV4dC91c2VJbnB1dEZpZWxkQ29tcG9uZW50LmpzP2NmZjYiLCJ3ZWJwYWNrOi8vQG1pdG8tZm9ybXMvYnVsbWEvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtaXRvLWZvcm1zK2NvcmVAMC4yLjIzLWJldGFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQG1pdG8tZm9ybXMvY29yZS9kaXN0L2hvb2tzL3VzZUNoYW5nZUhhbmRsZXIuanM/NWNjYSIsIndlYnBhY2s6Ly9AbWl0by1mb3Jtcy9idWxtYS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1pdG8tZm9ybXMrY29yZUAwLjIuMjMtYmV0YV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AbWl0by1mb3Jtcy9jb3JlL2Rpc3QvaG9va3MvdXNlQ2hlY2tlZEhhbmRsZXIuanM/NDk2ZSIsIndlYnBhY2s6Ly9AbWl0by1mb3Jtcy9idWxtYS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1pdG8tZm9ybXMrY29yZUAwLjIuMjMtYmV0YV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AbWl0by1mb3Jtcy9jb3JlL2Rpc3QvaG9va3MvdXNlQ2hlY2tsaXN0SGFuZGxlci5qcz80OTVkIiwid2VicGFjazovL0BtaXRvLWZvcm1zL2J1bG1hLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWl0by1mb3Jtcytjb3JlQDAuMi4yMy1iZXRhX3R5cGVzY3JpcHRANS44LjMvbm9kZV9tb2R1bGVzL0BtaXRvLWZvcm1zL2NvcmUvZGlzdC9ob29rcy91c2VPcHRpb25zQ2hhbmdlSGFuZGxlci5qcz8xZjgzIiwid2VicGFjazovL0BtaXRvLWZvcm1zL2J1bG1hLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWl0by1mb3Jtcytjb3JlQDAuMi4yMy1iZXRhX3R5cGVzY3JpcHRANS44LjMvbm9kZV9tb2R1bGVzL0BtaXRvLWZvcm1zL2NvcmUvZGlzdC9ob29rcy9jb250ZXh0L3VzZVV0aWxDb21wb25lbnQuanM/NjdlYSIsIndlYnBhY2s6Ly9AbWl0by1mb3Jtcy9idWxtYS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1pdG8tZm9ybXMrY29yZUAwLjIuMjMtYmV0YV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AbWl0by1mb3Jtcy9jb3JlL2Rpc3QvaG9va3MvdXNlRGVjb3JhdG9yLmpzP2Q0YTIiLCJ3ZWJwYWNrOi8vQG1pdG8tZm9ybXMvYnVsbWEvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtaXRvLWZvcm1zK2NvcmVAMC4yLjIzLWJldGFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQG1pdG8tZm9ybXMvY29yZS9kaXN0L2hvb2tzL2luZGV4LmpzPzMwODciLCJ3ZWJwYWNrOi8vQG1pdG8tZm9ybXMvYnVsbWEvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtaXRvLWZvcm1zK2NvcmVAMC4yLjIzLWJldGFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQG1pdG8tZm9ybXMvY29yZS9kaXN0L3V0aWxzL2luZGV4LmpzP2E2MGUiLCJ3ZWJwYWNrOi8vQG1pdG8tZm9ybXMvYnVsbWEvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtaXRvLWZvcm1zK2NvcmVAMC4yLjIzLWJldGFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQG1pdG8tZm9ybXMvY29yZS9kaXN0L0Zvcm1JbnB1dEZpZWxkLmpzPzNhMTQiLCJ3ZWJwYWNrOi8vQG1pdG8tZm9ybXMvYnVsbWEvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtaXRvLWZvcm1zK2NvcmVAMC4yLjIzLWJldGFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQG1pdG8tZm9ybXMvY29yZS9kaXN0L3ZhbGlkYXRvcnMvZW1haWwuanM/MWU3ZiIsIndlYnBhY2s6Ly9AbWl0by1mb3Jtcy9idWxtYS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1pdG8tZm9ybXMrY29yZUAwLjIuMjMtYmV0YV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AbWl0by1mb3Jtcy9jb3JlL2Rpc3QvdmFsaWRhdG9ycy9udW1iZXIuanM/NGFkZSIsIndlYnBhY2s6Ly9AbWl0by1mb3Jtcy9idWxtYS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1pdG8tZm9ybXMrY29yZUAwLjIuMjMtYmV0YV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AbWl0by1mb3Jtcy9jb3JlL2Rpc3QvdmFsaWRhdG9ycy9pbmRleC5qcz85ZmJiIiwid2VicGFjazovL0BtaXRvLWZvcm1zL2J1bG1hLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWl0by1mb3Jtcytjb3JlQDAuMi4yMy1iZXRhX3R5cGVzY3JpcHRANS44LjMvbm9kZV9tb2R1bGVzL0BtaXRvLWZvcm1zL2NvcmUvZGlzdC9kYXRhL2FjY2Vzc29yL3Jlc29sdmVBY2Nlc3Nvci5qcz82YzZjIiwid2VicGFjazovL0BtaXRvLWZvcm1zL2J1bG1hLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWl0by1mb3Jtcytjb3JlQDAuMi4yMy1iZXRhX3R5cGVzY3JpcHRANS44LjMvbm9kZV9tb2R1bGVzL0BtaXRvLWZvcm1zL2NvcmUvZGlzdC9kYXRhL2FjY2Vzc29yL2luZGV4LmpzPzk0YzMiLCJ3ZWJwYWNrOi8vQG1pdG8tZm9ybXMvYnVsbWEvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtaXRvLWZvcm1zK2NvcmVAMC4yLjIzLWJldGFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQG1pdG8tZm9ybXMvY29yZS9kaXN0L2RhdGEvRGF0YVV0aWxzLmpzPzkxYTUiLCJ3ZWJwYWNrOi8vQG1pdG8tZm9ybXMvYnVsbWEvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtaXRvLWZvcm1zK2NvcmVAMC4yLjIzLWJldGFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQG1pdG8tZm9ybXMvY29yZS9kaXN0L2RhdGEvU3RhdGljRGF0YXNvdXJjZS5qcz9jODQ1Iiwid2VicGFjazovL0BtaXRvLWZvcm1zL2J1bG1hLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWl0by1mb3Jtcytjb3JlQDAuMi4yMy1iZXRhX3R5cGVzY3JpcHRANS44LjMvbm9kZV9tb2R1bGVzL0BtaXRvLWZvcm1zL2NvcmUvZGlzdC9kYXRhL2luZGV4LmpzPzg5ZTEiLCJ3ZWJwYWNrOi8vQG1pdG8tZm9ybXMvYnVsbWEvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtaXRvLWZvcm1zK2NvcmVAMC4yLjIzLWJldGFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQG1pdG8tZm9ybXMvY29yZS9kaXN0L2hvb2tzL3VzZUZpZWxkc2V0U3RhdGUuanM/ODE5OCIsIndlYnBhY2s6Ly9AbWl0by1mb3Jtcy9idWxtYS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1pdG8tZm9ybXMrY29yZUAwLjIuMjMtYmV0YV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AbWl0by1mb3Jtcy9jb3JlL2Rpc3QvRm9ybUZpZWxkc2V0LmpzP2QyM2YiLCJ3ZWJwYWNrOi8vQG1pdG8tZm9ybXMvYnVsbWEvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtaXRvLWZvcm1zK2NvcmVAMC4yLjIzLWJldGFfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQG1pdG8tZm9ybXMvY29yZS9kaXN0L2hvb2tzL3VzZUZvcm1TdGF0ZS5qcz85NzQxIiwid2VicGFjazovL0BtaXRvLWZvcm1zL2J1bG1hLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWl0by1mb3Jtcytjb3JlQDAuMi4yMy1iZXRhX3R5cGVzY3JpcHRANS44LjMvbm9kZV9tb2R1bGVzL0BtaXRvLWZvcm1zL2NvcmUvZGlzdC9ob29rcy91c2VFZGl0b3JNZXRhZGF0YS5qcz84ZGQ2Iiwid2VicGFjazovL0BtaXRvLWZvcm1zL2J1bG1hLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWl0by1mb3Jtcytjb3JlQDAuMi4yMy1iZXRhX3R5cGVzY3JpcHRANS44LjMvbm9kZV9tb2R1bGVzL0BtaXRvLWZvcm1zL2NvcmUvZGlzdC9JbnB1dEZvcm0uanM/MzM4ZCIsIndlYnBhY2s6Ly9AbWl0by1mb3Jtcy9idWxtYS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1pdG8tZm9ybXMrY29yZUAwLjIuMjMtYmV0YV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AbWl0by1mb3Jtcy9jb3JlL2Rpc3QvRm9ybXNDb250YWluZXIuanM/NjUxZiIsIndlYnBhY2s6Ly9AbWl0by1mb3Jtcy9idWxtYS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG1pdG8tZm9ybXMrY29yZUAwLjIuMjMtYmV0YV90eXBlc2NyaXB0QDUuOC4zL25vZGVfbW9kdWxlcy9AbWl0by1mb3Jtcy9jb3JlL2Rpc3QvRm9ybUVkaXRvci5qcz84ZWNlIiwid2VicGFjazovL0BtaXRvLWZvcm1zL2J1bG1hLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbWl0by1mb3Jtcytjb3JlQDAuMi4yMy1iZXRhX3R5cGVzY3JpcHRANS44LjMvbm9kZV9tb2R1bGVzL0BtaXRvLWZvcm1zL2NvcmUvZGlzdC9pbmRleC5qcz8xODExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEpNRSBmcm9tICdqbWVzcGF0aCc7XG5pbXBvcnQgdXVpZEJ5U3RyaW5nIGZyb20gJ3V1aWQtYnktc3RyaW5nJztcbmV4cG9ydCBmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBSZXRyaWV2ZSB2YWx1ZSBmcm9tIGBkYXRhYCBvYmplY3QgYnkganNvbiBwYXRoLlxuICpcbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0ganNvblBhdGhcbiAqL1xuZXhwb3J0IGNvbnN0IGZldGNoSnNvblBhdGggPSAoZGF0YSwganNvblBhdGgpID0+IHtcbiAgICBpZiAoIWpzb25QYXRoKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBmZXRjaGVkRGF0YSA9IEpNRS5zZWFyY2goZGF0YSwganNvblBhdGgpO1xuICAgIGlmIChmZXRjaGVkRGF0YSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmZXRjaGVkRGF0YSkpIHtcbiAgICAgICAgICAgIGlmIChmZXRjaGVkRGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hlZERhdGFbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmZXRjaGVkRGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hlZERhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZldGNoZWREYXRhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIGRhdGEgZXhpc3QgaW4gdGhlIGNvbnRleHQgZGF0YVxuICpcbiAqIEBwYXJhbSBjb250ZXh0RGF0YVxuICogQHBhcmFtIGpzb25QYXRoXG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja0pzb25QYXRoID0gKGNvbnRleHREYXRhLCBqc29uUGF0aCkgPT4ge1xuICAgIGNvbnN0IGZldGNoZWREYXRhID0gSk1FLnNlYXJjaChjb250ZXh0RGF0YSwganNvblBhdGgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZldGNoZWREYXRhKSkge1xuICAgICAgICByZXR1cm4gZmV0Y2hlZERhdGEubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZldGNoZWREYXRhO1xufTtcbmV4cG9ydCBjb25zdCBnZXRJbml0aWFsRmllbGRTZXREYXRhID0gKGlucHV0RGF0YSwgZmllbGRTZXQpID0+IHtcbiAgICBjb25zdCBmaWVsZFZhbHVlcyA9IHt9O1xuICAgIGZpZWxkU2V0LmZpZWxkcy5mb3JFYWNoKChmaWVsZENvbmYpID0+IHtcbiAgICAgICAgaWYgKGZpZWxkQ29uZi50eXBlID09PSAnZGl2aWRlcicpIHtcbiAgICAgICAgICAgIC8vU2tpcCBEaXZpZGVyIGZpZWxkIGFzIGl0IGlzIG5vdCBpbnRlcnJhY3RpdmVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmV0Y2hlZFZhbHVlO1xuICAgICAgICBpZiAoaW5wdXREYXRhKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkQ29uZi52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhd1ZhbHVlID0gZmllbGRDb25mLnZhbHVlKGlucHV0RGF0YSk7XG4gICAgICAgICAgICAgICAgZmV0Y2hlZFZhbHVlID0gIWlzTnVsbE9yVW5kZWZpbmVkKHJhd1ZhbHVlKSA/IHJhd1ZhbHVlIDogZmllbGRDb25mLmRlZmF1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0pzb25QYXRoRXhwKGZpZWxkQ29uZi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUpzb25QYXRoID0gZXh0cmFjdEpzb25QYXRoU3RyaW5nKGZpZWxkQ29uZi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3VmFsdWUgPSBmZXRjaEpzb25QYXRoKGlucHV0RGF0YSwgdmFsdWVKc29uUGF0aCkgfHwgaW5wdXREYXRhW2ZpZWxkQ29uZi5uYW1lXTtcbiAgICAgICAgICAgICAgICBmZXRjaGVkVmFsdWUgPSAhaXNOdWxsT3JVbmRlZmluZWQocmF3VmFsdWUpID8gcmF3VmFsdWUgOiBmaWVsZENvbmYuZGVmYXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhd1ZhbHVlID0gaW5wdXREYXRhW2ZpZWxkQ29uZi5uYW1lXTtcbiAgICAgICAgICAgICAgICBmZXRjaGVkVmFsdWUgPSAhaXNOdWxsT3JVbmRlZmluZWQocmF3VmFsdWUpXG4gICAgICAgICAgICAgICAgICAgID8gcmF3VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBmaWVsZENvbmYudmFsdWUgfHwgZmllbGRDb25mLmRlZmF1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNKc29uUGF0aEV4cChmaWVsZENvbmYub3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uUGF0aCA9IGV4dHJhY3RKc29uUGF0aFN0cmluZyhmaWVsZENvbmYub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uc1JlcyA9IGZldGNoSnNvblBhdGgoaW5wdXREYXRhLCBqc29uUGF0aCkgfHxcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hKc29uUGF0aChpbnB1dERhdGEsIGAke2ZpZWxkQ29uZi5uYW1lfV9fb3B0aW9uc2ApO1xuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWVzW2Ake2ZpZWxkQ29uZi5uYW1lfV9fb3B0aW9uc2BdID0gb3B0aW9uc1Jlc1xuICAgICAgICAgICAgICAgICAgICA/IEFycmF5LmlzQXJyYXkob3B0aW9uc1JlcylcbiAgICAgICAgICAgICAgICAgICAgICAgID8gb3B0aW9uc1Jlc1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBbb3B0aW9uc1Jlc11cbiAgICAgICAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc0pzb25QYXRoRXhwKGZpZWxkQ29uZi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmZXRjaGVkVmFsdWUgPSBmaWVsZENvbmYuZGVmYXVsdDsgLy8gaW5wdXQgZGF0YSBpcyBub3QgZGVmaW5lZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmV0Y2hlZFZhbHVlID0gZmllbGRDb25mLnZhbHVlIHx8IGZpZWxkQ29uZi5kZWZhdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoZmV0Y2hlZFZhbHVlKSkge1xuICAgICAgICAgICAgZmllbGRWYWx1ZXNbZmllbGRDb25mLm5hbWVdID0gZmV0Y2hlZFZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpZWxkVmFsdWVzO1xufTtcbi8qKlxuICogRmV0Y2ggaW5pdGlhbCBmaWVsZCB2YWx1ZXMgZm9yIGEgZ2l2ZW4gZmllbGRzZXQuXG4gKlxuICogQHBhcmFtIGlucHV0RGF0YVxuICogQHBhcmFtIGZpZWxkU2V0RW50cnlcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEZpZWxkc2V0RGF0YSA9IChpbnB1dERhdGEsIGZpZWxkU2V0RW50cnkpID0+IHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICghZmllbGRTZXRFbnRyeS50eXBlIHx8IGZpZWxkU2V0RW50cnkudHlwZSA9PT0gJ2ZpZWxkU2V0Jykge1xuICAgICAgICBjb25zdCBmaWVsZFNldElucHV0ID0gKGZpZWxkU2V0RW50cnkuanNvblBhdGggPyBmZXRjaEpzb25QYXRoKGlucHV0RGF0YSwgZmllbGRTZXRFbnRyeS5qc29uUGF0aCkgOiBpbnB1dERhdGEpO1xuICAgICAgICByZXN1bHQgPSBnZXRJbml0aWFsRmllbGRTZXREYXRhKGZpZWxkU2V0SW5wdXQsIGZpZWxkU2V0RW50cnkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gUHJvY2VzcyByZWNvcmRzIGFycmF5XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCByZWNvcmRTZXRJbnB1dCA9IChmaWVsZFNldEVudHJ5Lmpzb25QYXRoID8gZmV0Y2hKc29uUGF0aChpbnB1dERhdGEsIGZpZWxkU2V0RW50cnkuanNvblBhdGgpIDogaW5wdXREYXRhKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlY29yZFNldElucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJlY29yZFNldElucHV0LmZvckVhY2goKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2V0SW5pdGlhbEZpZWxkU2V0RGF0YShyZWNvcmQsIGZpZWxkU2V0RW50cnkucm93RmllbGRzZXQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBleHByIGlzIHRoZSBzdHJpbmcgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQgJyF7JC48c29uUGF0aHN0cmluZz59JyBleGFtcGxlOiB7JC50YWdzU2VsZWN0b3JfX29wdGlvbnN9XG4gKiBAcGFyYW0gZXhwciBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IHZhbHVlIGlzIEpTT04gcGF0aCBleHByZXNzaW9uXG4gKi9cbmV4cG9ydCBjb25zdCBpc0pzb25QYXRoRXhwID0gKGV4cHIpID0+IHtcbiAgICBpZiAodHlwZW9mIGV4cHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZXhwclN0ciA9IGV4cHI7XG4gICAgcmV0dXJuIGV4cHJTdHIgJiYgZXhwclN0ci5zdGFydHNXaXRoKCcheycpICYmIGV4cHJTdHIuZW5kc1dpdGgoJ30nKTtcbn07XG4vKipcbiAqIEZyb20gdGhlIGlucHV0IHN0cmluZyBpbiB0aGUgZm9ybWF0ICd7JC48c29uUGF0aHN0cmluZz59JyBleGFtcGxlOiB7JC50YWdzU2VsZWN0b3JfX29wdGlvbnN9LiBleHRyYWN0IG9ubHlcbiAqIGpzb24gcGF0aCBvcHRpb24gb2YgaXQgLT4gJC50YWdzU2VsZWN0b3Ijb3B0aW9uXG4gKlxuICogQHBhcmFtIGV4cHIgaW5wdXQgc3RyaW5nXG4gKiBAcmV0dXJucyBqc29uIHBhdGggc3RyaW5nIG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgY29uc3QgZXh0cmFjdEpzb25QYXRoU3RyaW5nID0gKGV4cHIpID0+IHtcbiAgICBpZiAoIWlzSnNvblBhdGhFeHAoZXhwcikpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgc3RyRXhwciA9IGV4cHI7XG4gICAgcmV0dXJuIHN0ckV4cHIuc3Vic3RyaW5nKDIsIHN0ckV4cHIubGVuZ3RoIC0gMSk7XG59O1xuLyoqXG4gKiBGZXRjaGVzIHZhbHVlIGdpdmVuIGJ5IGpzb24gcGF0aCBvciBqc29uIHBhdGggZXhwcmVzc2lvbiAhezxwYXRoPn1cbiAqXG4gKiBAcGFyYW0gY29udGV4dERhdGFcbiAqIEBwYXJhbSBleHByT3JKc29uUGF0aCBqc29uIHBhdGggb3IganNvbiBwYXRoIGV4cHJlc3Npb24gIXs8cGF0aD59XG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaEpzb25QYXRoVmFsdWUgPSAoY29udGV4dERhdGEsIGV4cHJPckpzb25QYXRoKSA9PiB7XG4gICAgY29uc3QganNvblBhdGggPSBpc0pzb25QYXRoRXhwKGV4cHJPckpzb25QYXRoKVxuICAgICAgICA/IGV4dHJhY3RKc29uUGF0aFN0cmluZyhleHByT3JKc29uUGF0aClcbiAgICAgICAgOiBleHByT3JKc29uUGF0aDtcbiAgICByZXR1cm4gZmV0Y2hKc29uUGF0aChjb250ZXh0RGF0YSwganNvblBhdGgpO1xufTtcbi8qKlxuICogRm9yIHNlbGVjdG9yIGNvbXBvbmVudHMgaW5wdXQgdmFsdWVzIChzZWxlY3RlZCB2YWx1ZXMpIGNhbiBnbyBpblxuICogYXMgY29tbWEgc2VwYXJhdGVkIHN0cmluZyBvZiB2YWx1ZXMgb3IgaXQgY2FuIGJlIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgbnVtYmVyc1xuICogdGhpcyBmdW5jdGlvbiBub3JtYWxpemVzIGlucHV0IGJ5IGNvbnZlcnRpbmcgaW5wdXQgdmFsdWVzIHRvIGFycmF5IG9mIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHZhbHVlcyBpbnB1dCBhcyBzdHJpbmcgb2YgY29tbWEgc2VwYXJhdGVkIHZhbHVlcyAoXCIxLDIsM1wiKSBvciBhcnJheSBvZiBbMSwgMiwgM10gb3IgWycxJywgJzInLCAnMyddXG4gKlxuICogQHJldHVybnMgYXJyYXkgb2Ygc3RyaW5nIHZhbHVlc1xuICovXG5leHBvcnQgY29uc3QgYnVpbGRDaGVja2VkVmFsdWVzID0gKHZhbHVlcykgPT4ge1xuICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzLmxlbmd0aCA+IDAgPyB2YWx1ZXMuam9pbignLCcpLnNwbGl0KCcsJykgOiB2YWx1ZXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0cmltbWVkVmFsID0gYCR7dmFsdWVzfWAudHJpbSgpO1xuICAgICAgICByZXR1cm4gdHJpbW1lZFZhbCA/IGAke3RyaW1tZWRWYWx9YC50cmltKCkuc3BsaXQoJywnKSA6IFtdO1xuICAgIH1cbn07XG4vKipcbiAqIENvbnZlcnRzIG9wdGlvbnMgYXJyYXkgKHN0cmluZyB8IElucHV0T3B0aW9uKSBpbnRvIGFycmF5IG9mIElucHV0T3B0aW9ucyBmb3Igc3RhYmxlIGNvbnN1bXB0aW9uIGJ5IGlucHV0IGZpZWxkc1xuICpcbiAqIEBwYXJhbSBvcHRpb25zIGFycmF5IG9mIHN0cmluZyBvcHRpb25zXG4gKiBAcGFyYW0gY2hlY2tlZFZhbHVlcyBvcHRpb25hbCBsaXN0IG9mIGNoZWNrZWQgb3B0aW9uc1xuICogQHJldHVybnMgYXJyYXkgb2YgSW5wdXQgT3B0aW9uc1xuICovXG5leHBvcnQgY29uc3QgY29udmVydElucHV0T3B0aW9ucyA9IChvcHRpb25zLCBjaGVja2VkVmFsdWVzKSA9PiB7XG4gICAgY29uc3QgY29udmVydGVkT3B0aW9ucyA9IG9wdGlvbnNcbiAgICAgICAgPyBvcHRpb25zLm1hcChvcHQgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmF3T3B0ID0gdHlwZW9mIG9wdCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IHsgbGFiZWw6IG9wdCwgdmFsdWU6IG9wdCB9XG4gICAgICAgICAgICAgICAgOiBvcHQ7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnJhd09wdCxcbiAgICAgICAgICAgICAgICBjaGVja2VkOiAhIShjaGVja2VkVmFsdWVzICYmIGNoZWNrZWRWYWx1ZXMuaW5kZXhPZihgJHtyYXdPcHQudmFsdWV9YCkgPj0gMCksXG4gICAgICAgICAgICAgICAgcGFyYW1zOiByYXdPcHQucGFyYW1zIHx8IHt9LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiAhIXJhd09wdC5kaXNhYmxlZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICAgIDogW107XG4gICAgcmV0dXJuIGNvbnZlcnRlZE9wdGlvbnM7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgZmllbGQgaGFzIG9wdGlvbnMgcGFzc2VkIGRvd24gYXMgSnNvblBhdGggb3IgYXMgbGlzdCBvZiBvcHRpb25zIGFuZCBpZiBpdCBpcyBKU09OIFBhdGggdGhlIGNvcnJlc3BvbmRpbmcganNvbiBwYXRoIGlzIHJldHJpZXZlZC5cbiAqIGZyb20gdGhlIHBhc3NlZCAnZGF0YScgb2JqZWN0XG4gKlxuICovXG5leHBvcnQgY29uc3QgcmV0cmlldmVJbnB1dE9wdGlvbnMgPSAoZmllbGQsIGRhdGEpID0+IHtcbiAgICBsZXQgcmF3T3B0aW9ucztcbiAgICBpZiAoZmllbGQub3B0aW9ucyAmJiBpc0pzb25QYXRoRXhwKGZpZWxkLm9wdGlvbnMpKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNKc29uUGF0aCA9IGV4dHJhY3RKc29uUGF0aFN0cmluZyhmaWVsZC5vcHRpb25zKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uc1JlcyA9IGZldGNoSnNvblBhdGgoZGF0YSwgb3B0aW9uc0pzb25QYXRoKSB8fCBmZXRjaEpzb25QYXRoKGRhdGEsIGAke2ZpZWxkLm5hbWV9X19vcHRpb25zYCk7XG4gICAgICAgIHJhd09wdGlvbnMgPSBvcHRpb25zUmVzID8gKEFycmF5LmlzQXJyYXkob3B0aW9uc1JlcykgPyBvcHRpb25zUmVzIDogW29wdGlvbnNSZXNdKSA6IFtdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmF3T3B0aW9ucyA9IGZpZWxkLm9wdGlvbnM7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmF3T3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHJhd09wdGlvbnMuc3BsaXQoJywnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByYXdPcHRpb25zO1xuICAgIH1cbn07XG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRJZChmaWVsZENvbmZpZywgZmllbGRJbmRleCkge1xuICAgIHJldHVybiBgJHtmaWVsZENvbmZpZy50eXBlfS0ke2ZpZWxkQ29uZmlnLm5hbWV9LSR7ZmllbGRJbmRleCB8fCAwfWA7XG59XG4vKipcbiAqIEdlbmVyYXRlIHJlYWN0IGtleVxuICpcbiAqIEBwYXJhbSBzZWVkVmFsdWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJlYWN0S2V5KC4uLnNlZWRWYWx1ZXMpIHtcbiAgICByZXR1cm4gdXVpZEJ5U3RyaW5nKHNlZWRWYWx1ZXMuam9pbignLScpKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBFeHByZXNzaW9uIENvbnRleHRcbiAqXG4gKiBAcGFyYW0gc3RhdGVcbiAqIEBwYXJhbSBjb250ZXh0XG4gKiBAcGFyYW0gYWRkaXRpb25hbERhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRXhwcmVzc2lvbkNvbnRleHQoc3RhdGUsIGNvbnRleHQsIGFkZGl0aW9uYWxEYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uKGFkZGl0aW9uYWxEYXRhIHx8IHt9KSxcbiAgICAgICAgX0NPTlRFWFQ6IGNvbnRleHQsXG4gICAgICAgIF9TVEFURTogc3RhdGUsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEVtcHR5UmVjb3JkRnJvbUZpZWxkcyhmaWVsZHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgIGlmIChmaWVsZC5kZWZhdWx0KSB7XG4gICAgICAgICAgICByZXN1bHRbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0O1xuICAgICAgICAgICAgLy8gaWYgKGZpZWxkLnR5cGUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICAvLyAgIHJlc3VsdFtgJHtmaWVsZC5uYW1lfV9fb3B0aW9uc2BdID0gZmllbGQub3B0aW9ucyAmJiBpc0pzb25QYXRoRXhwKGZpZWxkLm9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogVXBkYXRlcyBzdGF0ZSBmcm9tIHRoZSBwYXNzZWQgaW5wdXQgZGF0YSBmb3IgdGhlIGVkaXRvci5cbiAqIEVkaXRvciBtZXRhZGF0YSBob3cgdGhlIGRhdGEgc2hvdWxkIGJlIHBvcHVsYXRlZCBmb3IgZWFjaCBmaWVsZCBhbmQgZmllbGRzZXRcbiAqXG4gKiAxLiBGb3JtIERhdGEgcmV0cmlldmFsIDpcbiAqICAgIC0gaWYgbm8ganNvblBhdGggc3BlY2lmaWVkIGZvciB0aGUgZm9ybSBkYXRhIGZvciB0aGUgZm9ybSB3aWxsIGJlIGVkaXRvckRhdGEuXG4gKiAgICAtIGlmIGpzb25QYXRoIHNwZWNpZmllZCBpbiB0aGUgY29uZmlnIGZpcnN0IHdlIHBlcmZvcm0gbG9va3VwIHRvIHRoYXQganNvblBhdGhcbiAqICAgICAgYW5kIHRoZW4gcGFzcyB3aGF0IHdhcyByZXRyaWV2ZWQgaXMgdXNlZCBhcyB0aGUgRm9ybSBEYXRhLlxuICpcbiAqIDIuIEZpZWxkc2V0IERhdGE6IEVkaXRvciByZXRyaWV2ZXMgZmllbGRzZXQgRGF0YSBhcyBmb2xsb3dpbmdcbiAqICAgIC0gYnkgZGVmYXVsdCBmaWVsZHNldCBkYXRhIHJlY2VpdmVzIGZvcm1EYXRhIGFzIGFuIGlucHV0IHJlZmVyIHRvICgxIGFib3ZlKS5cbiAqICAgIC0gSWYganNvblBhdGggd2FzIHByb3ZpZGVkIHRoZW4gZGF0YSBpcyByZXRyaWV2ZWQgYnkgdGhhdCBqc29uUGF0aCBmcm9tIHRoZSBjb250YWluaW5nIGZvcm0gZGF0YS5cbiAqIDMuIEZpZWxkIHZhbHVlIFJldHJpZXZhbDpcbiAqICAgIC0gYnkgZGVmYXVsdCBmaWVsZCB2YWx1ZSBpcyByZXRyaWV2ZWQgZnJvbSB0aGUgZWRpdElucHV0IGRhdGEgYnkgZmllbGQgbmFtZS4gQXNzdW1pbmcgbm8gY29udGFpbmluZyBmaWVsZHNldFxuICogICAgICBvciBmb3JtIGhhdmUganNvbnBhdGggc3BlY2lmaWVkIGRhdGEgZm9yIGZpZWxkIGlzIGJlaW5nIGxvb2tjZWQgdXAgaW4gZWRpdG9ySW5wdXQgZGF0YSBvYmplY3QuXG4gKiAgICAtIGlmIHZhbHVlIG9mIHRoZSBmaWVsZCBpcyBqc29uUGF0aCBleHByZXNzaW9uIChFeGFtcGxlICF7PHBhdGg+fSkgdGhlbiBkYXRhIGlzIHJldHJpZXZlZFxuICogICAgICBmcm9tIHRoYXQgcGF0aCBpbiBmaWVsZHNldCBkYXRhLlxuICpcbiAqXG4gKiBAcGFyYW0gZWRpdG9yTWV0YWRhdGFcbiAqIEBwYXJhbSBlZGl0b3JEYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBidWlsZEZvcm1TdGF0ZXNGcm9tRGF0YSA9IChlZGl0b3JNZXRhZGF0YSwgZWRpdG9yRGF0YSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGVkaXRvck1ldGFkYXRhLmZvcm1zLmZvckVhY2goZm9ybSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gKGZvcm0uanNvblBhdGggPyBmZXRjaEpzb25QYXRoKGVkaXRvckRhdGEsIGZvcm0uanNvblBhdGgpIDogZWRpdG9yRGF0YSk7XG4gICAgICAgIHJlc3VsdFtmb3JtLmlkXSA9IHt9O1xuICAgICAgICBmb3JtLmZpZWxkU2V0cy5mb3JFYWNoKGZpZWxkU2V0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2V0RGF0YSA9IGdldEZpZWxkc2V0RGF0YShmb3JtRGF0YSwgZmllbGRTZXQpO1xuICAgICAgICAgICAgcmVzdWx0W2Zvcm0uaWRdW2ZpZWxkU2V0Lm5hbWVdID0geyBkYXRhOiBmaWVsZFNldERhdGEgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWVsZFV0aWxzLmpzLm1hcCIsImltcG9ydCB7IGJ1aWxkRm9ybVN0YXRlc0Zyb21EYXRhIH0gZnJvbSAnLi91dGlscy9maWVsZFV0aWxzJztcbi8qKlxuICogRWRpdG9yIHN0YXRlIHJlZHVjZXJcbiAqXG4gKiBAcGFyYW0gZWRpdG9yU3RhdGVcbiAqIEBwYXJhbSBhY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkaXRvclN0YXRlUmVkdWNlcihlZGl0b3JTdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgbmV3RWRpdG9yU3RhdGUgPSB7IC4uLmVkaXRvclN0YXRlIH07XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdmb3JtQ2hhbmdlJzoge1xuICAgICAgICAgICAgY29uc3QgZm9ybUNoYW5nZVBheWxvYWQgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvck1ldGFkYXRhID0gZm9ybUNoYW5nZVBheWxvYWQuZWRpdG9yTWV0YWRhdGE7XG4gICAgICAgICAgICBjb25zdCByZWR1Y2Vyc01hcCA9IGZvcm1DaGFuZ2VQYXlsb2FkLmVkaXRvclJlZHVjZXJzTWFwO1xuICAgICAgICAgICAgaWYgKCFyZWR1Y2Vyc01hcCkge1xuICAgICAgICAgICAgICAgIG5ld0VkaXRvclN0YXRlLmZvcm1TdGF0ZXNbZm9ybUNoYW5nZVBheWxvYWQuZm9ybUlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYWN0aW9uLnBheWxvYWQuZGF0YSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG5ld0VkaXRvclN0YXRlLmVkaXRvclJlc3VsdCA9IHVwZGF0ZUVkaXRvckRhdGEoZWRpdG9yU3RhdGUuZWRpdG9yUmVzdWx0LCBmb3JtQ2hhbmdlUGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdFZGl0b3JTdGF0ZS5lZGl0b3JSZXN1bHQgPSB1cGRhdGVFZGl0b3JEYXRhKGVkaXRvclN0YXRlLmVkaXRvclJlc3VsdCwgZm9ybUNoYW5nZVBheWxvYWQsIHJlZHVjZXJzTWFwKTtcbiAgICAgICAgICAgICAgICBuZXdFZGl0b3JTdGF0ZS5mb3JtU3RhdGVzID0gYnVpbGRGb3JtU3RhdGVzRnJvbURhdGEoZm9ybUNoYW5nZVBheWxvYWQuZWRpdG9yTWV0YWRhdGEsIG5ld0VkaXRvclN0YXRlLmVkaXRvclJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdFZGl0b3JTdGF0ZS5pc1ZhbGlkID0gZm9ybUNoYW5nZVBheWxvYWQuaXNWYWxpZDtcbiAgICAgICAgICAgIGxldCBrO1xuICAgICAgICAgICAgZm9yIChrIGluIGVkaXRvclN0YXRlLmZvcm1TdGF0ZXMpIHtcbiAgICAgICAgICAgICAgICBuZXdFZGl0b3JTdGF0ZS5pc1ZhbGlkID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGVkaXRvclN0YXRlLmZvcm1TdGF0ZXNba10uaXNWYWxpZCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gISFlZGl0b3JTdGF0ZS5mb3JtU3RhdGVzW2tdLmlzVmFsaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZm9ybUNoYW5nZVBheWxvYWQuaXNWYWxpZDtcbiAgICAgICAgICAgICAgICBpZiAoIW5ld0VkaXRvclN0YXRlLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVkaXRvck1ldGFkYXRhLnJlc3VsdFZhbGlkYXRvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRvclJlc3VsdCA9IGVkaXRvck1ldGFkYXRhLnJlc3VsdFZhbGlkYXRvcihuZXdFZGl0b3JTdGF0ZS5lZGl0b3JSZXN1bHQpO1xuICAgICAgICAgICAgICAgIG5ld0VkaXRvclN0YXRlLmlzVmFsaWQgPSBmb3JtQ2hhbmdlUGF5bG9hZC5pc1ZhbGlkICYmIHZhbGlkYXRvclJlc3VsdC5pc1ZhbGlkO1xuICAgICAgICAgICAgICAgIG5ld0VkaXRvclN0YXRlLnZhbGlkYXRvck1lc3NhZ2UgPSB2YWxpZGF0b3JSZXN1bHQubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdFZGl0b3JTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdyZXBsYWNlJzoge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4uYWN0aW9uLnBheWxvYWQuZGF0YSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdFZGl0b3JTdGF0ZTtcbn1cbi8qKlxuICogVXBkYXRlIGVkaXRvciBkYXRhIHdpdGggRm9ybSBEYXRhIChwcm92aWRlZCBpbnB1dCBmaWVsZCB2YWx1ZXMpLlxuICpcbiAqIEBwYXJhbSBlZGl0b3JEYXRhIHJhdyBlZHRpb3IgZGF0YVxuICogQHBhcmFtIGZvcm1DaGFuZ2VQYXlsb2FkIHBheWxvYWQgd2l0aCB0aGUgbW9kaWZpZWQgZGF0YVxuICogQHBhcmFtIGVkaXRvclJlZHVjZXJzTWFwIG1hcCBvZiBlZGl0b3IgcmVkdWNlcnNcbiAqL1xuY29uc3QgdXBkYXRlRWRpdG9yRGF0YSA9IChlZGl0b3JEYXRhLCBmb3JtQ2hhbmdlUGF5bG9hZCwgZWRpdG9yUmVkdWNlcnNNYXApID0+IHtcbiAgICBjb25zdCByZWR1Y2VyTWFwID0gZWRpdG9yUmVkdWNlcnNNYXA7XG4gICAgY29uc3QgZm9ybUlkID0gZm9ybUNoYW5nZVBheWxvYWQuZm9ybUlkO1xuICAgIGNvbnN0IGZpZWxkU2V0TmFtZSA9IGZvcm1DaGFuZ2VQYXlsb2FkLmZpZWxkU2V0TmFtZTtcbiAgICBjb25zdCBmb3JtUmVkdWNlcnMgPSByZWR1Y2VyTWFwID8gcmVkdWNlck1hcFtmb3JtSWRdIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGVkaXRvck1ldGFkYXRhID0gZm9ybUNoYW5nZVBheWxvYWQuZWRpdG9yTWV0YWRhdGE7XG4gICAgY29uc3QgZm9ybU1ldGFkYXRhID0gZWRpdG9yTWV0YWRhdGEuZm9ybXMuZmluZChmb3JtID0+IGZvcm0uaWQgPT09IGZvcm1JZCk7XG4gICAgaWYgKCFmb3JtTWV0YWRhdGEpIHtcbiAgICAgICAgdGhyb3cgYEZvcm0gbm90IGZvdW5kOiAke2Zvcm1JZH1gO1xuICAgIH1cbiAgICBjb25zdCBmaWVsZHNldE1ldGFkYXRhID0gZm9ybU1ldGFkYXRhLmZpZWxkU2V0cy5maW5kKGZzID0+IGZzLm5hbWUgPT09IGZpZWxkU2V0TmFtZSk7XG4gICAgY29uc3QgZmllbGRTZXRSZWR1Y2VyID0gZm9ybVJlZHVjZXJzPy5bZmllbGRTZXROYW1lXTtcbiAgICBpZiAoZmllbGRzZXRNZXRhZGF0YSAmJiBmaWVsZFNldFJlZHVjZXIpIHtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBmb3JtQ2hhbmdlUGF5bG9hZC5kYXRhW2ZpZWxkU2V0TmFtZV0uZGF0YTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvclJlc3VsdCA9IGZpZWxkc2V0TWV0YWRhdGEudHlwZSAhPT0gJ2ZpZWxkU2V0TGlzdCdcbiAgICAgICAgICAgICAgICA/IGZpZWxkU2V0UmVkdWNlcihlZGl0b3JEYXRhLCBmb3JtRGF0YSwgZm9ybUNoYW5nZVBheWxvYWQuY29udGV4dFBhcmFtcylcbiAgICAgICAgICAgICAgICA6IGZpZWxkU2V0UmVkdWNlcihlZGl0b3JEYXRhLCBmb3JtRGF0YSwgZm9ybUNoYW5nZVBheWxvYWQuY29udGV4dFBhcmFtcyk7XG4gICAgICAgICAgICByZXR1cm4gZWRpdG9yUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBgRXJyb3Igb2NjdXJlZCBpbiBSZWR1Y2VyIGZvciBGT1JNOiAke2Zvcm1JZH0sIEZJRUxEU0VUOiAke2ZpZWxkU2V0TmFtZX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBpZiBubyByZWR1Y2VyIGZ1bmN0aW9uIHJlZ2lzdGVyZWQgcmVjb3JkIGRhdGEgYXMgZm9sbG93aW5nXG4gICAgICAgIGNvbnN0IG5ld0VkaXRvckRhdGEgPSB7IC4uLmVkaXRvckRhdGEgfTtcbiAgICAgICAgbmV3RWRpdG9yRGF0YVtmb3JtQ2hhbmdlUGF5bG9hZC5mb3JtSWRdID0ge1xuICAgICAgICAgICAgLi4uZWRpdG9yRGF0YVtmb3JtQ2hhbmdlUGF5bG9hZC5mb3JtSWRdLFxuICAgICAgICAgICAgLi4uZm9ybUNoYW5nZVBheWxvYWQuZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ld0VkaXRvckRhdGE7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZvcm1FZGl0b3JSZWR1Y2VyLmpzLm1hcCIsImV4cG9ydCB2YXIgRGF0YVR5cGU7XG4oZnVuY3Rpb24gKERhdGFUeXBlKSB7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJTdHJpbmdcIl0gPSAwXSA9IFwiU3RyaW5nXCI7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJEZWNpbWFsXCJdID0gMV0gPSBcIkRlY2ltYWxcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkRhdGVcIl0gPSAyXSA9IFwiRGF0ZVwiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiT2JqZWN0XCJdID0gM10gPSBcIk9iamVjdFwiO1xufSkoRGF0YVR5cGUgfHwgKERhdGFUeXBlID0ge30pKTtcbmV4cG9ydCB2YXIgQ29uZGl0aW9uVHlwZUVudW07XG4oZnVuY3Rpb24gKENvbmRpdGlvblR5cGVFbnVtKSB7XG4gICAgQ29uZGl0aW9uVHlwZUVudW1bQ29uZGl0aW9uVHlwZUVudW1bXCJFcXVhbFwiXSA9IDBdID0gXCJFcXVhbFwiO1xuICAgIENvbmRpdGlvblR5cGVFbnVtW0NvbmRpdGlvblR5cGVFbnVtW1wiTm90RXF1YWxcIl0gPSAxXSA9IFwiTm90RXF1YWxcIjtcbiAgICBDb25kaXRpb25UeXBlRW51bVtDb25kaXRpb25UeXBlRW51bVtcIkdyZWF0ZXJcIl0gPSAyXSA9IFwiR3JlYXRlclwiO1xuICAgIENvbmRpdGlvblR5cGVFbnVtW0NvbmRpdGlvblR5cGVFbnVtW1wiTGVzc1wiXSA9IDNdID0gXCJMZXNzXCI7XG4gICAgQ29uZGl0aW9uVHlwZUVudW1bQ29uZGl0aW9uVHlwZUVudW1bXCJCZXR3ZWVuXCJdID0gNF0gPSBcIkJldHdlZW5cIjtcbn0pKENvbmRpdGlvblR5cGVFbnVtIHx8IChDb25kaXRpb25UeXBlRW51bSA9IHt9KSk7XG5leHBvcnQgdmFyIFNvcnRPcmRlcjtcbihmdW5jdGlvbiAoU29ydE9yZGVyKSB7XG4gICAgU29ydE9yZGVyW1NvcnRPcmRlcltcIkFzY1wiXSA9IDFdID0gXCJBc2NcIjtcbiAgICBTb3J0T3JkZXJbU29ydE9yZGVyW1wiRGVzY1wiXSA9IDJdID0gXCJEZXNjXCI7XG59KShTb3J0T3JkZXIgfHwgKFNvcnRPcmRlciA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIiwiZXhwb3J0IHZhciBDb21wb25lbnRUeXBlRW51bTtcbihmdW5jdGlvbiAoQ29tcG9uZW50VHlwZUVudW0pIHtcbiAgICBDb21wb25lbnRUeXBlRW51bVtDb21wb25lbnRUeXBlRW51bVtcIldpZGdldFwiXSA9IDBdID0gXCJXaWRnZXRcIjtcbiAgICBDb21wb25lbnRUeXBlRW51bVtDb21wb25lbnRUeXBlRW51bVtcIkRhdGFTb3VyY2VcIl0gPSAxXSA9IFwiRGF0YVNvdXJjZVwiO1xuICAgIENvbXBvbmVudFR5cGVFbnVtW0NvbXBvbmVudFR5cGVFbnVtW1wiRWRpdG9yRmllbGRcIl0gPSAyXSA9IFwiRWRpdG9yRmllbGRcIjtcbiAgICBDb21wb25lbnRUeXBlRW51bVtDb21wb25lbnRUeXBlRW51bVtcIkRhdGFcIl0gPSAzXSA9IFwiRGF0YVwiO1xufSkoQ29tcG9uZW50VHlwZUVudW0gfHwgKENvbXBvbmVudFR5cGVFbnVtID0ge30pKTtcbmV4cG9ydCB2YXIgQWNjZXNzb3JUeXBlO1xuKGZ1bmN0aW9uIChBY2Nlc3NvclR5cGUpIHtcbiAgICBBY2Nlc3NvclR5cGVbQWNjZXNzb3JUeXBlW1wiRGlyZWN0VXNhZ2VcIl0gPSAwXSA9IFwiRGlyZWN0VXNhZ2VcIjtcbiAgICBBY2Nlc3NvclR5cGVbQWNjZXNzb3JUeXBlW1wiUHJvcGVydHlcIl0gPSAxXSA9IFwiUHJvcGVydHlcIjtcbiAgICBBY2Nlc3NvclR5cGVbQWNjZXNzb3JUeXBlW1wiSnNvblBhdGhcIl0gPSAyXSA9IFwiSnNvblBhdGhcIjtcbn0pKEFjY2Vzc29yVHlwZSB8fCAoQWNjZXNzb3JUeXBlID0ge30pKTtcbmV4cG9ydCB2YXIgVHJhbnNmb3JtVHlwZTtcbihmdW5jdGlvbiAoVHJhbnNmb3JtVHlwZSkge1xuICAgIFRyYW5zZm9ybVR5cGVbVHJhbnNmb3JtVHlwZVtcIlNvcnRcIl0gPSAwXSA9IFwiU29ydFwiO1xuICAgIFRyYW5zZm9ybVR5cGVbVHJhbnNmb3JtVHlwZVtcIlJlbWFwUmVjb3JkXCJdID0gMV0gPSBcIlJlbWFwUmVjb3JkXCI7XG4gICAgVHJhbnNmb3JtVHlwZVtUcmFuc2Zvcm1UeXBlW1wiUmVtYXBSZWNvcmRzQXJyYXlcIl0gPSAyXSA9IFwiUmVtYXBSZWNvcmRzQXJyYXlcIjtcbiAgICBUcmFuc2Zvcm1UeXBlW1RyYW5zZm9ybVR5cGVbXCJNYXBUb0FycmF5XCJdID0gM10gPSBcIk1hcFRvQXJyYXlcIjtcbiAgICBUcmFuc2Zvcm1UeXBlW1RyYW5zZm9ybVR5cGVbXCJEZWNvcmF0ZU9iamVjdFwiXSA9IDRdID0gXCJEZWNvcmF0ZU9iamVjdFwiO1xuICAgIFRyYW5zZm9ybVR5cGVbVHJhbnNmb3JtVHlwZVtcIkNvbnZlcnROYW5vVG9NaWxsaVNlY29uZHNcIl0gPSA1XSA9IFwiQ29udmVydE5hbm9Ub01pbGxpU2Vjb25kc1wiO1xuICAgIFRyYW5zZm9ybVR5cGVbVHJhbnNmb3JtVHlwZVtcIkdyb3VwQnlGaWVsZFwiXSA9IDZdID0gXCJHcm91cEJ5RmllbGRcIjtcbiAgICBUcmFuc2Zvcm1UeXBlW1RyYW5zZm9ybVR5cGVbXCJBcnJheUpvaW5cIl0gPSA3XSA9IFwiQXJyYXlKb2luXCI7XG4gICAgVHJhbnNmb3JtVHlwZVtUcmFuc2Zvcm1UeXBlW1wiSW5qZWN0RGF0YVwiXSA9IDhdID0gXCJJbmplY3REYXRhXCI7XG4gICAgVHJhbnNmb3JtVHlwZVtUcmFuc2Zvcm1UeXBlW1wiRmxhdHRlbkhpZXJhcmNoeVwiXSA9IDldID0gXCJGbGF0dGVuSGllcmFyY2h5XCI7XG4gICAgVHJhbnNmb3JtVHlwZVtUcmFuc2Zvcm1UeXBlW1wiTWlsbGlTZWNvbmRzVG9UaW1lc3RhbXBcIl0gPSAxMF0gPSBcIk1pbGxpU2Vjb25kc1RvVGltZXN0YW1wXCI7XG4gICAgVHJhbnNmb3JtVHlwZVtUcmFuc2Zvcm1UeXBlW1wiUmVtYXBGaWVsZFZhbHVlXCJdID0gMTFdID0gXCJSZW1hcEZpZWxkVmFsdWVcIjtcbiAgICBUcmFuc2Zvcm1UeXBlW1RyYW5zZm9ybVR5cGVbXCJGaWx0ZXJSZWNvcmRcIl0gPSAxMl0gPSBcIkZpbHRlclJlY29yZFwiO1xuICAgIFRyYW5zZm9ybVR5cGVbVHJhbnNmb3JtVHlwZVtcIlNwbGl0U3RyaW5nc1wiXSA9IDEzXSA9IFwiU3BsaXRTdHJpbmdzXCI7XG4gICAgVHJhbnNmb3JtVHlwZVtUcmFuc2Zvcm1UeXBlW1wiVW5pcXVlVmFsdWVzXCJdID0gMTRdID0gXCJVbmlxdWVWYWx1ZXNcIjtcbn0pKFRyYW5zZm9ybVR5cGUgfHwgKFRyYW5zZm9ybVR5cGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YUJpbmRpbmdzLmpzLm1hcCIsImV4cG9ydCB2YXIgRGF0YVNvdXJjZVR5cGU7XG4oZnVuY3Rpb24gKERhdGFTb3VyY2VUeXBlKSB7XG4gICAgRGF0YVNvdXJjZVR5cGVbRGF0YVNvdXJjZVR5cGVbXCJBcGlDYWxsXCJdID0gMF0gPSBcIkFwaUNhbGxcIjtcbiAgICBEYXRhU291cmNlVHlwZVtEYXRhU291cmNlVHlwZVtcIlN0YXRpY1wiXSA9IDFdID0gXCJTdGF0aWNcIjtcbiAgICBEYXRhU291cmNlVHlwZVtEYXRhU291cmNlVHlwZVtcIkFnZ3JlZ2F0ZVwiXSA9IDJdID0gXCJBZ2dyZWdhdGVcIjtcbn0pKERhdGFTb3VyY2VUeXBlIHx8IChEYXRhU291cmNlVHlwZSA9IHt9KSk7XG5leHBvcnQgdmFyIERhdGFBZ2dyZWdhdGlvbk1vZGU7XG4oZnVuY3Rpb24gKERhdGFBZ2dyZWdhdGlvbk1vZGUpIHtcbiAgICBEYXRhQWdncmVnYXRpb25Nb2RlW0RhdGFBZ2dyZWdhdGlvbk1vZGVbXCJBcHBlbmRcIl0gPSAwXSA9IFwiQXBwZW5kXCI7XG59KShEYXRhQWdncmVnYXRpb25Nb2RlIHx8IChEYXRhQWdncmVnYXRpb25Nb2RlID0ge30pKTtcbmV4cG9ydCB2YXIgUmVzdWx0Rm9ybWF0O1xuKGZ1bmN0aW9uIChSZXN1bHRGb3JtYXQpIHtcbiAgICBSZXN1bHRGb3JtYXRbUmVzdWx0Rm9ybWF0W1wiUGFuZGFzRGF0YUZyYW1lXCJdID0gMF0gPSBcIlBhbmRhc0RhdGFGcmFtZVwiO1xuICAgIFJlc3VsdEZvcm1hdFtSZXN1bHRGb3JtYXRbXCJSZWNvcmRzQXJyYXlcIl0gPSAxXSA9IFwiUmVjb3Jkc0FycmF5XCI7XG4gICAgUmVzdWx0Rm9ybWF0W1Jlc3VsdEZvcm1hdFtcIk9iamVjdFwiXSA9IDJdID0gXCJPYmplY3RcIjtcbiAgICBSZXN1bHRGb3JtYXRbUmVzdWx0Rm9ybWF0W1wiQW55XCJdID0gM10gPSBcIkFueVwiO1xufSkoUmVzdWx0Rm9ybWF0IHx8IChSZXN1bHRGb3JtYXQgPSB7fSkpO1xuZXhwb3J0IHZhciBEYXRhU3RhdHVzO1xuKGZ1bmN0aW9uIChEYXRhU3RhdHVzKSB7XG4gICAgRGF0YVN0YXR1c1tEYXRhU3RhdHVzW1wiVW5rbm93blwiXSA9IDBdID0gXCJVbmtub3duXCI7XG4gICAgRGF0YVN0YXR1c1tEYXRhU3RhdHVzW1wiTmVlZHNSZWZyZXNoXCJdID0gMV0gPSBcIk5lZWRzUmVmcmVzaFwiO1xuICAgIERhdGFTdGF0dXNbRGF0YVN0YXR1c1tcIkxvYWRpbmdcIl0gPSAyXSA9IFwiTG9hZGluZ1wiO1xuICAgIERhdGFTdGF0dXNbRGF0YVN0YXR1c1tcIkxvYWRlZFwiXSA9IDNdID0gXCJMb2FkZWRcIjtcbiAgICBEYXRhU3RhdHVzW0RhdGFTdGF0dXNbXCJFcnJvclwiXSA9IDRdID0gXCJFcnJvclwiO1xufSkoRGF0YVN0YXR1cyB8fCAoRGF0YVN0YXR1cyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhU291cmNlLmpzLm1hcCIsImV4cG9ydCAqIGZyb20gJy4vY29tbW9uJztcbmV4cG9ydCAqIGZyb20gJy4vZGF0YUJpbmRpbmdzJztcbmV4cG9ydCAqIGZyb20gJy4vZGF0YVNvdXJjZSc7XG5leHBvcnQgKiBmcm9tICcuL2VkaXRvck1ldGFkYXRhJztcbmV4cG9ydCAqIGZyb20gJy4vc3RhdGUnO1xuZXhwb3J0ICogZnJvbSAnLi9leHByZXNzaW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL3JlZ2lzdHJ5Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5leHBvcnQgY29uc3QgRWRpdG9yQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICAgIGRhdGFTb3VyY2VzOiB7fSxcbiAgICBjb250ZXh0UGFyYW1zOiB7fSxcbiAgICBjb21wb25lbnRSZWdpc3RyeToge1xuICAgICAgICBpbnB1dEZpZWxkczoge30sXG4gICAgICAgIHV0aWxpdHlDb21wb25lbnRzOiB7fSxcbiAgICB9LFxuICAgIGVkaXRvclN0YXRlOiB7XG4gICAgICAgIGZvcm1TdGF0ZXM6IHt9LFxuICAgICAgICBlZGl0b3JSZXN1bHQ6IHt9LFxuICAgIH0sXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVkaXRvckNvbnRleHQuanMubWFwIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBjb25zdCBVbnN1cHBvcnRlZElucHV0Q29tcG9uZW50ID0gKHsgY29uZmlnIH0pID0+IHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwidW5zdXBwb3J0ZWQtaW5wdXRcIiB9LCBgW1Vuc3VwcG9ydGVkIElucHV0IENvbXBvbmVudCB0eXBlICgke2NvbmZpZy50eXBlfSk6IG5hbWU6ICgke2NvbmZpZy5uYW1lfSldYCkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuc3VwcG9ydGVkSW5wdXRDb21wb25lbnQuanMubWFwIiwiaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVkaXRvckNvbnRleHQgfSBmcm9tICcuLi8uLi9FZGl0b3JDb250ZXh0JztcbmltcG9ydCB7IFVuc3VwcG9ydGVkSW5wdXRDb21wb25lbnQgfSBmcm9tICcuLi8uLi9VbnN1cHBvcnRlZElucHV0Q29tcG9uZW50JztcbmV4cG9ydCBjb25zdCB1c2VJbnB1dEZpZWxkQ29tcG9uZW50ID0gKGNvbXBvbmVudFR5cGUpID0+IHtcbiAgICBjb25zdCBlZGl0b3JDb250ZXh0RGF0YSA9IHVzZUNvbnRleHQoRWRpdG9yQ29udGV4dCk7XG4gICAgY29uc3QgY29tcG9uZW50UmVnaXN0cnkgPSB1c2VNZW1vKCgpID0+IGVkaXRvckNvbnRleHREYXRhLmNvbXBvbmVudFJlZ2lzdHJ5LCBbZWRpdG9yQ29udGV4dERhdGEuY29tcG9uZW50UmVnaXN0cnldKTtcbiAgICByZXR1cm4gY29tcG9uZW50UmVnaXN0cnkuaW5wdXRGaWVsZHNbY29tcG9uZW50VHlwZV0gfHwgVW5zdXBwb3J0ZWRJbnB1dENvbXBvbmVudDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VJbnB1dEZpZWxkQ29tcG9uZW50LmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuZXhwb3J0IGNvbnN0IHVzZUNoYW5nZUhhbmRsZXIgPSAoY29uZmlnLCBvbkNoYW5nZSkgPT4ge1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgICAgICAgIG9uQ2hhbmdlKHsgW2NvbmZpZy5uYW1lXTogZS50YXJnZXQudmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25DaGFuZ2UsIGNvbmZpZ10pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZUNoYW5nZUhhbmRsZXIuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5leHBvcnQgY29uc3QgdXNlQ2hlY2tlZEhhbmRsZXIgPSAoY29uZmlnLCBvbkNoYW5nZSkgPT4ge1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgb25DaGFuZ2UoeyBbY29uZmlnLm5hbWVdOiBlLnRhcmdldC5jaGVja2VkIH0pO1xuICAgICAgICB9XG4gICAgfSwgW29uQ2hhbmdlLCBjb25maWddKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VDaGVja2VkSGFuZGxlci5qcy5tYXAiLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBjb25zdCB1c2VDaGVja2xpc3RIYW5kbGVyID0gKGNvbmZpZywgb3B0aW9ucywgb25DaGFuZ2UpID0+IHtcbiAgICBjb25zdCBjaGVja2VkT3B0aW9uc01hcCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgb3B0aW9ucy5mb3JFYWNoKG9wdCA9PiB7XG4gICAgICAgICAgICByZXN1bHRbYCR7b3B0LnZhbHVlfWBdID0gb3B0LmNoZWNrZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtvcHRpb25zXSk7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBvcHRJZCA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgY2hlY2tlZE9wdGlvbnNNYXBbb3B0SWRdID0gZXZlbnQudGFyZ2V0LmNoZWNrZWQ7XG4gICAgICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIob3B0ID0+IGNoZWNrZWRPcHRpb25zTWFwW2Ake29wdC52YWx1ZX1gXSlcbiAgICAgICAgICAgICAgICAubWFwKG9wdCA9PiBvcHQudmFsdWUpO1xuICAgICAgICAgICAgb25DaGFuZ2UoeyBbY29uZmlnLm5hbWVdOiByZXN1bHQgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbY2hlY2tlZE9wdGlvbnNNYXAsIGNvbmZpZy5uYW1lLCBvbkNoYW5nZSwgb3B0aW9uc10pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZUNoZWNrbGlzdEhhbmRsZXIuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5leHBvcnQgY29uc3QgdXNlT3B0aW9uc0NoYW5nZUhhbmRsZXIgPSAoY29uZmlnLCBvcHRpb25zLCBvbkNoYW5nZSkgPT4ge1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZVNlbGVjdGVkID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkT3B0ID0gb3B0aW9ucy5maW5kKG9wdCA9PiBgJHtvcHQudmFsdWV9YCA9PT0gYCR7dmFsdWVTZWxlY3RlZH1gKTtcbiAgICAgICAgaWYgKG9uQ2hhbmdlICYmIHNlbGVjdGVkT3B0KSB7XG4gICAgICAgICAgICBvbkNoYW5nZSh7IFtjb25maWcubmFtZV06IHNlbGVjdGVkT3B0LnZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgfSwgW29wdGlvbnMsIG9uQ2hhbmdlLCBjb25maWcubmFtZV0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZU9wdGlvbnNDaGFuZ2VIYW5kbGVyLmpzLm1hcCIsImltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBFZGl0b3JDb250ZXh0IH0gZnJvbSAnLi4vLi4vRWRpdG9yQ29udGV4dCc7XG5leHBvcnQgY29uc3QgdXNlVXRpbENvbXBvbmVudCA9IChjb21wb25lbnRUeXBlKSA9PiB7XG4gICAgY29uc3QgZWRpdG9yQ29udGV4dERhdGEgPSB1c2VDb250ZXh0KEVkaXRvckNvbnRleHQpO1xuICAgIHJldHVybiBlZGl0b3JDb250ZXh0RGF0YS5jb21wb25lbnRSZWdpc3RyeS51dGlsaXR5Q29tcG9uZW50c1tjb21wb25lbnRUeXBlXTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VVdGlsQ29tcG9uZW50LmpzLm1hcCIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRWRpdG9yQ29udGV4dCB9IGZyb20gJy4uL0VkaXRvckNvbnRleHQnO1xuLyoqXG4gKiBVc2UgRGVjb3JhdG9yIEhvb2sgdXNlZCB0byByZXRyaWV2ZSBmaWVsZCBkZWNvcmF0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZURlY29yYXRvcigpIHtcbiAgICBjb25zdCBlZGl0b3JDb250ZXh0RGF0YSA9IHVzZUNvbnRleHQoRWRpdG9yQ29udGV4dCk7XG4gICAgY29uc3QgY29tcG9uZW50UmVnaXN0cnkgPSB1c2VNZW1vKCgpID0+IGVkaXRvckNvbnRleHREYXRhLmNvbXBvbmVudFJlZ2lzdHJ5LCBbZWRpdG9yQ29udGV4dERhdGEuY29tcG9uZW50UmVnaXN0cnldKTtcbiAgICBjb25zdCBnZXRGaWVsZERlY29yYXRvciA9IHVzZUNhbGxiYWNrKChkZWNvcmF0b3JOYW1lKSA9PiBjb21wb25lbnRSZWdpc3RyeS5nZXRGaWVsZERlY29yYXRvcihkZWNvcmF0b3JOYW1lKSwgW2NvbXBvbmVudFJlZ2lzdHJ5XSk7XG4gICAgY29uc3QgZ2V0RmllbGRzZXREZWNvcmF0b3IgPSB1c2VDYWxsYmFjaygoZGVjb3JhdG9yTmFtZSkgPT4gY29tcG9uZW50UmVnaXN0cnkuZ2V0RmllbGRzZXREZWNvcmF0b3IoZGVjb3JhdG9yTmFtZSksIFtjb21wb25lbnRSZWdpc3RyeV0pO1xuICAgIGNvbnN0IGdldExpc3RFZGl0b3JEZWNvcmF0b3IgPSB1c2VDYWxsYmFjaygoZGVjb3JhdG9yTmFtZSkgPT4gY29tcG9uZW50UmVnaXN0cnkuZ2V0TGlzdEVkaXRvckRlY29yYXRvcihkZWNvcmF0b3JOYW1lKSwgW2NvbXBvbmVudFJlZ2lzdHJ5XSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0RmllbGREZWNvcmF0b3IsXG4gICAgICAgIGdldEZpZWxkc2V0RGVjb3JhdG9yLFxuICAgICAgICBnZXRMaXN0RWRpdG9yRGVjb3JhdG9yLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VEZWNvcmF0b3IuanMubWFwIiwiZXhwb3J0ICogZnJvbSAnLi91c2VDaGFuZ2VIYW5kbGVyJztcbmV4cG9ydCAqIGZyb20gJy4vdXNlQ2hlY2tlZEhhbmRsZXInO1xuZXhwb3J0ICogZnJvbSAnLi91c2VDaGVja2xpc3RIYW5kbGVyJztcbmV4cG9ydCAqIGZyb20gJy4vdXNlT3B0aW9uc0NoYW5nZUhhbmRsZXInO1xuZXhwb3J0ICogZnJvbSAnLi9jb250ZXh0L3VzZVV0aWxDb21wb25lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi91c2VEZWNvcmF0b3InO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0ICogZnJvbSAnLi9maWVsZFV0aWxzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBEYXRhU3RhdHVzLCB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgdXNlSW5wdXRGaWVsZENvbXBvbmVudCB9IGZyb20gJy4vaG9va3MvY29udGV4dC91c2VJbnB1dEZpZWxkQ29tcG9uZW50JztcbmltcG9ydCB7IHVzZURlY29yYXRvciwgdXNlVXRpbENvbXBvbmVudCB9IGZyb20gJy4vaG9va3MnO1xuaW1wb3J0IHsgZ2V0RmllbGRJZCB9IGZyb20gJy4vdXRpbHMnO1xuZXhwb3J0IGZ1bmN0aW9uIEZvcm1JbnB1dEZpZWxkKHsgY29uZmlnLCB2YWx1ZSwgb25DaGFuZ2UsIG9wdGlvbnMsIGxhYmVsLCBzdGF0dXMsIGZpZWxkSW5kZXggPSAwLCBpc1ZhbGlkID0gdHJ1ZSwgdmFsaWRhdGlvbkVycm9ycywgZmllbGRMYXlvdXQsIH0pIHtcbiAgICBjb25zdCBJbnB1dENNUCA9IHVzZUlucHV0RmllbGRDb21wb25lbnQoY29uZmlnLnR5cGUpO1xuICAgIGNvbnN0IHsgZ2V0RmllbGREZWNvcmF0b3IgfSA9IHVzZURlY29yYXRvcigpO1xuICAgIGNvbnN0IGZpZWxkRGVjb3JhdG9yTmFtZSA9IGdldEZpZWxkRGVjb3JhdG9yTmFtZShmaWVsZExheW91dCwgY29uZmlnKTtcbiAgICBjb25zdCBGaWVsZERlY29yYXRvciA9IGdldEZpZWxkRGVjb3JhdG9yKGZpZWxkRGVjb3JhdG9yTmFtZSk7XG4gICAgY29uc3QgaW5wdXRJZCA9IGdldEZpZWxkSWQoY29uZmlnLCBmaWVsZEluZGV4KTtcbiAgICBjb25zdCBMb2FkaW5nSW5kaWNhdG9yID0gdXNlVXRpbENvbXBvbmVudCgnbG9hZGluZycpO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChGaWVsZERlY29yYXRvciwgeyBpZDogaW5wdXRJZCwgbGFiZWw6IGxhYmVsLCBoZWxwVGV4dDogY29uZmlnLmhlbHBUZXh0LCByZXF1aXJlZDogY29uZmlnLnJlcXVpcmVkLCBjdXN0b21Qcm9wczogY29uZmlnLmN1c3RvbVByb3BzLCBjb250cm9sRWxlbWVudDogc3RhdHVzICE9PSBEYXRhU3RhdHVzLkxvYWRlZCA/IChSZWFjdC5jcmVhdGVFbGVtZW50KExvYWRpbmdJbmRpY2F0b3IsIHsgc2l6ZTogXCJzbWFsbFwiIH0pKSA6IChSZWFjdC5jcmVhdGVFbGVtZW50KElucHV0Q01QLCB7IGNvbmZpZzogY29uZmlnLCB2YWx1ZTogdmFsdWUsIGxhYmVsOiBsYWJlbCwgb25DaGFuZ2U6IG9uQ2hhbmdlLCBvcHRpb25zOiBvcHRpb25zLCBpc1ZhbGlkOiBpc1ZhbGlkLCB2YWxpZGF0aW9uRXJyb3JzOiB2YWxpZGF0aW9uRXJyb3JzLCBmaWVsZExheW91dDogZmllbGRMYXlvdXQsIGZpZWxkSW5kZXg6IGZpZWxkSW5kZXgsIHN0YXR1czogc3RhdHVzIH0pKSwgc3RhdHVzOiBzdGF0dXMsIGlzVmFsaWQ6IGlzVmFsaWQsIHZhbGlkYXRpb25FcnJvcnM6IHZhbGlkYXRpb25FcnJvcnMgfSkpO1xufVxuY29uc3QgZ2V0RmllbGREZWNvcmF0b3JOYW1lID0gKGZpZWxkTGF5b3V0LCBmaWVsZENvbmZpZykgPT4ge1xuICAgIGlmIChmaWVsZENvbmZpZy5maWVsZERlY29yYXRvcikge1xuICAgICAgICByZXR1cm4gZmllbGRDb25maWcuZmllbGREZWNvcmF0b3I7XG4gICAgfVxuICAgIGlmIChmaWVsZExheW91dCA9PT0gJ2NvbXBhY3QnKSB7XG4gICAgICAgIHJldHVybiAnY29tcGFjdEZpZWxkJztcbiAgICB9XG4gICAgZWxzZSBpZiAoZmllbGRMYXlvdXQgPT09ICd0d29Db2x1bW4nKSB7XG4gICAgICAgIHJldHVybiAnaG9yaXpvbnRhbEZpZWxkJztcbiAgICB9XG4gICAgZWxzZSBpZiAoZmllbGRMYXlvdXQgPT09ICd0d29Db2x1bW5KdXN0aWZpZWQnKSB7XG4gICAgICAgIHJldHVybiAnaG9yaXpvbnRhbEp1c3RpZmllZEZpZWxkZCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJ2NvbXBhY3RGaWVsZCc7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZvcm1JbnB1dEZpZWxkLmpzLm1hcCIsIi8vIFNpbXBsZSB2YWxpZGF0aW9uIG9mIHdoZXRoZXIgYSBzdHJpbmcgaXMgYW4gZW1haWxcbi8vIHRoaXMgaXMgbm90IGV4aGF1c3RpdmUgLS0gdGhlIGV4aGF1c3RpdmUgcmVnZXggaXMgY29tcGxleCBhbmRcbi8vIHVubmVjZXNzYXJ5IGZvciBvdXIgcHVycG9zZXMuXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDk2NDc2NlxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlU2ltcGxlRW1haWwgPSAoZW1haWwpID0+IHtcbiAgICByZXR1cm4gL15cXFMrQFxcUytcXC5cXFMrJC91LnRlc3QoZW1haWwpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtYWlsLmpzLm1hcCIsIi8qKlxuICogVmFsaWRhdGVzIGlmIHRoZSBpbnB1dCBzdHJpbmcgaXMgYSBudW1iZXJcbiAqXG4gKiBAcGFyYW0gdmFsdWUgaW5wdXQgc3RyaW5nXG4gKiBAcGFyYW0gbWluIG9wdGlvbmFsIG1pblxuICogQHBhcmFtIG1heCBwdGlvbmFsIG1heFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlTnVtYmVyRmllbGQgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiB7XG4gICAgY29uc3QgcmVzID0gIXZhbHVlIHx8ICFpc0ludGVnZXIodmFsdWUpID8gWydUaGlzIGZpZWxkIG11c3QgYmUgYSB2YWxpZCBudW1iZXIuJywgdW5kZWZpbmVkXSA6IHRydWU7XG4gICAgaWYgKHJlcyAhPT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBjb25zdCBtaW5WYWx1ZSA9IE51bWJlci5pc0ludGVnZXIobWluKSA/IG1pbiA6IE51bWJlci5NSU5fVkFMVUU7XG4gICAgY29uc3QgbWF4VmFsdWUgPSBOdW1iZXIuaXNJbnRlZ2VyKG1heCkgPyBtYXggOiBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICBpZiAoaW50VmFsdWUgPCBtaW5WYWx1ZSkge1xuICAgICAgICByZXR1cm4gW2BUaGlzIGZpZWxkIG11c3QgYmUgZ3JlYXRlciB0aGFuICR7bWluVmFsdWV9LmAsIHVuZGVmaW5lZF07XG4gICAgfVxuICAgIGlmIChpbnRWYWx1ZSA+IG1heFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbYFRoaXMgZmllbGQgbXVzdCBiZSBsZXNzIHRoYW4gJHttYXhWYWx1ZX0uYCwgdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlUmVxdWlyZWRGaWVsZCA9ICh2YWx1ZSwgZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtlcnJvck1lc3NhZ2UgfHwgJ1RoaXMgZmllbGQgaXMgcmVxdWlyZWQnXTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHN0cmluZyBpcyBpbnRlZ2VyXG4gKiBAcGFyYW0gdmFsdWUgaW5waXV0IHN0cmluZ1xuICogQHJldHVybnMgdHJ1ZS9mYWxzZVxuICovXG5leHBvcnQgY29uc3QgaXNJbnRlZ2VyID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlID8gL14tP1xcZCskL3UudGVzdCh2YWx1ZSkgOiBmYWxzZTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuanMubWFwIiwiaW1wb3J0IHsgdmFsaWRhdGVTaW1wbGVFbWFpbCB9IGZyb20gJy4vZW1haWwnO1xuaW1wb3J0IHsgdmFsaWRhdGVOdW1iZXJGaWVsZCwgdmFsaWRhdGVSZXF1aXJlZEZpZWxkIH0gZnJvbSAnLi9udW1iZXInO1xuZXhwb3J0IGNvbnN0IGdldFZhbGlkYXRvckZ1bmN0aW9uID0gKHR5cGVPckZuLCBmaWVsZCkgPT4ge1xuICAgIGlmICh0eXBlb2YgdHlwZU9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVPckZuO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0b3JUeXBlID0gdHlwZU9yRm47XG4gICAgc3dpdGNoICh2YWxpZGF0b3JUeXBlKSB7XG4gICAgICAgIGNhc2UgJ3JlcXVpcmVkJzoge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVSZXF1aXJlZEZpZWxkKHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIHJldHVybiAoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlTnVtYmVyRmllbGQodmFsdWUsIGZpZWxkPy5taW5WYWx1ZSwgZmllbGQ/Lm1heFZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuICgodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlICdlbWFpbE11bHRpbGluZSc6XG4gICAgICAgICAgICAvLyBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXMgYSBtdWx0aWxpbmUgc3RyaW5nXG4gICAgICAgICAgICAvLyB3aXRoIGV2ZXJ5IGxpbmUgYmVpbmcgYSB2YWxpZCBlbWFpbFxuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtYWlscyA9IHZhbHVlPy5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFlbWFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW1haWwgb2YgZW1haWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGVTaW1wbGVFbWFpbChlbWFpbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgXCIke2VtYWlsfVwiIGlzIG5vdCBhIHZhbGlkIGVtYWlsYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gKChfdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWycnLCB1bmRlZmluZWRdO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IEFjY2Vzc29yVHlwZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCAqIGFzIEpNRSBmcm9tICdqbWVzcGF0aCc7XG4vKipcbiAqIFJlc29sdmUgYWNjZXNzb3Igb24gdGhlIHNwZWNpZmllZCBkYXRhIG9iamVjdFxuICpcbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0gYWNjZXNzb3JcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmVBY2Nlc3NvciA9IChkYXRhLCBhY2Nlc3NvcikgPT4ge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgYWNjZXNzb3JUeXBlID0gYWNjZXNzb3IudHlwZTtcbiAgICBzd2l0Y2ggKGFjY2Vzc29yVHlwZSkge1xuICAgICAgICBjYXNlIEFjY2Vzc29yVHlwZS5Qcm9wZXJ0eToge1xuICAgICAgICAgICAgaWYgKCFhY2Nlc3Nvci5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGFbYWNjZXNzb3IucHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgQWNjZXNzb3JUeXBlLkpzb25QYXRoOiB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZERhdGEgPSBhY2Nlc3Nvci5qc29uUGF0aCA/IEpNRS5zZWFyY2goZGF0YSwgYWNjZXNzb3IuanNvblBhdGgpIDogZGF0YTtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlc29sdmVkRGF0YSkgJiYgcmVzb2x2ZWREYXRhLmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgICAgID8gcmVzb2x2ZWREYXRhWzBdXG4gICAgICAgICAgICAgICAgOiByZXNvbHZlZERhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlQWNjZXNzb3IuanMubWFwIiwiZXhwb3J0ICogZnJvbSAnLi9yZXNvbHZlQWNjZXNzb3InO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgQ29uZGl0aW9uVHlwZUVudW0gfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBjaGVja0pzb25QYXRoLCBleHRyYWN0SnNvblBhdGhTdHJpbmcsIGZldGNoSnNvblBhdGgsIGlzSnNvblBhdGhFeHAgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyByZXNvbHZlQWNjZXNzb3IgfSBmcm9tICcuL2FjY2Vzc29yJztcbi8vaW1wb3J0IHsgdHJhbnNmb3JtRGF0YSB9IGZyb20gJy4vdHJhbnNmb3JtZXInO1xuZXhwb3J0IGNvbnN0IHRyYW5zZm9ybURhdGEgPSAoZGF0YU9iamVjdCwgX3RyYW5zZm9ybWVycywgX29yaWdEYXRhKSA9PiB7XG4gICAgLy9EVU1NWSBpbXBsZW1lbnRhdGlvbiBvZiBtaXNzaW5nIHRyYW5zZm9ybSBEYXRhIGZ1bmN0aW9uXG4gICAgcmV0dXJuIGRhdGFPYmplY3Q7XG59O1xuZXhwb3J0IGNvbnN0IGV2YWx1YXRlTG9naWNDb25kaXRpb24gPSAoY29uZGl0aW9uSW5mbywgZGF0YVZhbHVlKSA9PiB7XG4gICAgc3dpdGNoIChjb25kaXRpb25JbmZvLnR5cGUpIHtcbiAgICAgICAgY2FzZSBDb25kaXRpb25UeXBlRW51bS5FcXVhbDoge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbkluZm8udmFsdWUgPT09IGRhdGFWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIENvbmRpdGlvblR5cGVFbnVtLkdyZWF0ZXI6IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFUeXBlID0gdHlwZW9mIGNvbmRpdGlvbkluZm8udmFsdWU7XG4gICAgICAgICAgICBpZiAoZGF0YVR5cGUgPT09ICdudW1iZXInIHx8IGRhdGFUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25kaXRpb25JbmZvLnZhbHVlID4gKGRhdGFWYWx1ZSB8fCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIENvbmRpdGlvblR5cGVFbnVtLkxlc3M6IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFUeXBlID0gdHlwZW9mIGNvbmRpdGlvbkluZm8udmFsdWU7XG4gICAgICAgICAgICBpZiAoZGF0YVR5cGUgPT09ICdudW1iZXInIHx8IGRhdGFUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25kaXRpb25JbmZvLnZhbHVlIDwgKGRhdGFWYWx1ZSB8fCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIENvbmRpdGlvblR5cGVFbnVtLkJldHdlZW46IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFUeXBlID0gdHlwZW9mIGNvbmRpdGlvbkluZm8udmFsdWU7XG4gICAgICAgICAgICBpZiAoZGF0YVR5cGUgPT09ICdudW1iZXInIHx8IGRhdGFUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoY29uZGl0aW9uSW5mby52YWx1ZSA8IChkYXRhVmFsdWUgfHwgMCkgJiYgKGRhdGFWYWx1ZSB8fCAwKSA8IChjb25kaXRpb25JbmZvLnZhbHVlMiB8fCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBDb25kaXRpb25UeXBlRW51bS5Ob3RFcXVhbDoge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbkluZm8udmFsdWUgIT09IGRhdGFWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIEV2YWx1YXRlcyBsb2dpY1xuICpcbiAqIEBwYXJhbSBleHByZXNzaW9uXG4gKiBAcGFyYW0gY29udGV4dERhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGV2YWx1YXRlTG9naWNJbkNvbnRleHQgPSAoZXhwcmVzc2lvbiwgY29udGV4dERhdGEpID0+IHtcbiAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgaWYgKGlzSnNvblBhdGhFeHAoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgY29uc3QganNvblBhdGggPSBleHRyYWN0SnNvblBhdGhTdHJpbmcoZXhwcmVzc2lvbik7XG4gICAgICAgIHJldHVybiBjaGVja0pzb25QYXRoKGNvbnRleHREYXRhLCBqc29uUGF0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gISFleHByZXNzaW9uO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgZXZhbHVhdGVDb25kaXRpb25JbkNvbnRleHQgPSAoY29uZGl0aW9uLCBjb250ZXh0RGF0YSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlRmllbGQgPSBjb25kaXRpb24udmFsdWU7IC8vIFRyZWF0aW5nIHZhbHVlIGFzIEpTT04gUEFUSFxuICAgIGNvbnN0IHZhbHVlID0gZmV0Y2hKc29uUGF0aChjb250ZXh0RGF0YSwgdmFsdWVGaWVsZCk7XG4gICAgaWYgKCh2YWx1ZSA9PT0gJycgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkgJiZcbiAgICAgICAgIWV2YWx1YXRlTG9naWNDb25kaXRpb24oeyAuLi5jb25kaXRpb24sIHZhbHVlOiAodmFsdWUgfHwgJycpIH0sIGNvbmRpdGlvbi52YWx1ZTIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgYWNjZXNzQW5kVHJhbnNmb3JtRGF0YSA9IChkYXRhT2JqZWN0LCBhY2Nlc3NvciwgdHJhbnNmb3JtZXJzKSA9PiB7XG4gICAgY29uc3QgYWNjZXNzZWREYXRhID0gIWFjY2Vzc29yID8gZGF0YU9iamVjdCA6IHJlc29sdmVBY2Nlc3NvcihkYXRhT2JqZWN0LCBhY2Nlc3Nvcik7XG4gICAgcmV0dXJuICF0cmFuc2Zvcm1lcnMgPyBhY2Nlc3NlZERhdGEgOiB0cmFuc2Zvcm1EYXRhKGFjY2Vzc2VkRGF0YSwgdHJhbnNmb3JtZXJzLCBkYXRhT2JqZWN0KTtcbn07XG5leHBvcnQgY29uc3QgZGF0YVNvdXJjZUhhc1JlcXVpcmVkUGFyYW1zID0gKGRhdGFTb3VyY2UsIHBhcmFtcykgPT4ge1xuICAgIGlmIChkYXRhU291cmNlLmFjdGlvbi5yZXF1aXJlZFBhcmFtcykge1xuICAgICAgICBjb25zdCBkc1BhcmFtcyA9IHtcbiAgICAgICAgICAgIC4uLmRhdGFTb3VyY2UuYWN0aW9uLnBhcmFtcyxcbiAgICAgICAgICAgIC4uLmRhdGFTb3VyY2UuYWN0aW9uLnVybFBhcmFtcyxcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgbm90RGVmaW5lZFBhcmFtcyA9IGRhdGFTb3VyY2UuYWN0aW9uLnJlcXVpcmVkUGFyYW1zLmZpbHRlcihwYXJhbSA9PiAhZHNQYXJhbXNbcGFyYW1dKTtcbiAgICAgICAgcmV0dXJuIG5vdERlZmluZWRQYXJhbXMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIFJlZ2V4IHRvIHRlc3QgaWYgcHJvcGVydHkgaW50ZW5kcyB0byBhY2Nlc3MgZWxlbWVudCBpbiB0aGUgYXJyYXkgZXhhbXBsZSAncHJvcFsxMF0nXG4gKi9cbmNvbnN0IEFSUkFZX0VMRU1FTlRfSU5ERVhfUlggPSAvXihcXHcrKVxcWyhcXGQrKVxcXS4qPy91O1xuLyoqXG4gKiBJbnNlcnRzIHByb3BlcnR5IHZhbHVlIGludG8gb2JqZWN0IHNldmVyYWwgbGV2ZWxzIGRvd24gdGhlIGhpZXJhcmNoeVxuICogQXJyYXlzIGFyZSBzdXBwb3J0ZWQgdG9vLlxuICogZXhhbXBsZSBpZiB0aGVyZSBpcyBkYXRhIGFzIHt9IHRoaXMgZnVuY3Rpb24gY2FuIGluc2VydCB2YWx1ZSBhcyB0aGlzXG4gKiB7dG9wOiB7IGxvd2VyOiB7dmFsdWU6IFwidGVzdFwiIH19fSBpZiB0aGUgdGFyZ2V0IFBhdGggc3BlY2lmaWVkIGFzICd0b3AubG93ZXIudmFsdWUnIGFuZCB0aGUgdmFsdWUgYXMgJ3Rlc3QnLlxuICpcbiAqXG4gKiBAcGFyYW0gZGF0YVxuICogQHBhcmFtIHRhcmdldFBhdGhTdHJcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgaW5qZWN0UHJvcGVydHlWYWx1ZSA9IChkYXRhLCB0YXJnZXRQYXRoU3RyLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHByb3BQYXRoID0gdGFyZ2V0UGF0aFN0ci5zcGxpdCgnLicpO1xuICAgIGxldCBjdXJyZW50T2JqID0gZGF0YTtcbiAgICBwcm9wUGF0aC5mb3JFYWNoKChwcm9wLCBpKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgY3VycmVudE9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRpbmcgdG8gaW5qZWN0IHZhbHVlIGludG8gaW5jb21wYXRpYmxlIHR5cGUuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IHByb3BQYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHNldFByb3BlcnR5KGN1cnJlbnRPYmosIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob2xkZXJPYmogPSBnZXRQcm9wZXJ0eShjdXJyZW50T2JqLCBwcm9wKTtcbiAgICAgICAgaWYgKCFob2xkZXJPYmopIHtcbiAgICAgICAgICAgIHNldFByb3BlcnR5KGN1cnJlbnRPYmosIHByb3AsIHt9KTtcbiAgICAgICAgICAgIGN1cnJlbnRPYmogPSBnZXRQcm9wZXJ0eShjdXJyZW50T2JqLCBwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRPYmogPSBob2xkZXJPYmo7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5jb25zdCBzZXRQcm9wZXJ0eSA9IChkYXRhLCBwcm9wLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGRhdGFBc1BhcmFtcyA9IGRhdGE7XG4gICAgY29uc3QgbWF0Y2hBcnIgPSBwcm9wLm1hdGNoKEFSUkFZX0VMRU1FTlRfSU5ERVhfUlgpO1xuICAgIGlmIChtYXRjaEFycikge1xuICAgICAgICBsZXQgYXJyYXlPYmogPSBhY2Nlc3NBcnJheShkYXRhQXNQYXJhbXMsIHByb3ApO1xuICAgICAgICBpZiAoIWFycmF5T2JqKSB7XG4gICAgICAgICAgICBhcnJheU9iaiA9IGRhdGFBc1BhcmFtc1ttYXRjaEFyclsxXV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcnJheUluZCA9IHBhcnNlSW50KG1hdGNoQXJyWzJdLCAxMCk7XG4gICAgICAgIGFycmF5T2JqW2FycmF5SW5kXSA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZGF0YUFzUGFyYW1zW3Byb3BdID0gdmFsdWU7XG4gICAgfVxufTtcbmNvbnN0IGdldFByb3BlcnR5ID0gKGRhdGEsIHByb3ApID0+IHtcbiAgICBjb25zdCBkYXRhQXNQYXJhbXMgPSBkYXRhO1xuICAgIGNvbnN0IG1hdGNoQXJyID0gcHJvcC5tYXRjaChBUlJBWV9FTEVNRU5UX0lOREVYX1JYKTtcbiAgICBpZiAobWF0Y2hBcnIpIHtcbiAgICAgICAgY29uc3QgYXJyYXlPYmogPSBhY2Nlc3NBcnJheShkYXRhQXNQYXJhbXMsIHByb3ApO1xuICAgICAgICBpZiAoYXJyYXlPYmopIHtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5SW5kID0gcGFyc2VJbnQobWF0Y2hBcnJbMl0sIDEwKTtcbiAgICAgICAgICAgIHJldHVybiBhcnJheU9ialthcnJheUluZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFBc1BhcmFtc1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5jb25zdCBhY2Nlc3NBcnJheSA9IChkYXRhLCBwcm9wKSA9PiB7XG4gICAgY29uc3QgZGF0YUFzUGFyYW1zID0gZGF0YTtcbiAgICBjb25zdCBtYXRjaEFyciA9IHByb3AubWF0Y2goQVJSQVlfRUxFTUVOVF9JTkRFWF9SWCk7XG4gICAgaWYgKG1hdGNoQXJyKSB7XG4gICAgICAgIGNvbnN0IGFycmF5TmFtZSA9IG1hdGNoQXJyWzFdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YUFzUGFyYW1zW2FycmF5TmFtZV0pKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBdHRlbXB0aW5nIHRvIGluamVjdCB2YWx1ZSBpbnRvIGluY29tcGF0aWJsZSB0eXBlLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhQXNQYXJhbXNbYXJyYXlOYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhVXRpbHMuanMubWFwIiwiaW1wb3J0IHsgRGF0YVN0YXR1cyB9IGZyb20gJy4uL3R5cGVzJztcbmV4cG9ydCBjb25zdCByZWZyZXNoU3RhdGljRGF0YXNvdXJjZSA9IChjb25maWcsIF9icm93c2VyVXJsUGFyYW1zKSA9PiB7XG4gICAgY29uc3Qgc3RhdGljQWN0aW9uID0gY29uZmlnLmFjdGlvbjtcbiAgICBjb25zdCBkYXRhID0gc3RhdGljQWN0aW9uLnN0YXRpY0RhdGE7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIGlkOiBjb25maWcuaWQsXG4gICAgICAgICAgICBzdGF0dXM6IERhdGFTdGF0dXMuTG9hZGVkLFxuICAgICAgICAgICAgcmVzdWx0Rm9ybWF0OiBjb25maWcucmVzdWx0Rm9ybWF0LFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhdGljRGF0YXNvdXJjZS5qcy5tYXAiLCJleHBvcnQgKiBmcm9tICcuL0RhdGFVdGlscyc7XG5leHBvcnQgKiBmcm9tICcuL1N0YXRpY0RhdGFzb3VyY2UnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgRGF0YVN0YXR1cywgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGFjY2Vzc0FuZFRyYW5zZm9ybURhdGEsIGV2YWx1YXRlTG9naWNJbkNvbnRleHQgfSBmcm9tICcuLi9kYXRhJztcbmltcG9ydCB7IEVkaXRvckNvbnRleHQgfSBmcm9tICcuLi9FZGl0b3JDb250ZXh0JztcbmltcG9ydCB7IGJ1aWxkRXhwcmVzc2lvbkNvbnRleHQsIHJldHJpZXZlSW5wdXRPcHRpb25zIH0gZnJvbSAnLi4vdXRpbHMnO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZpZWxkc2V0U3RhdGUoY29uZmlnKSB7XG4gICAgY29uc3QgZWRpdG9yQ29udGV4dERhdGEgPSB1c2VDb250ZXh0KEVkaXRvckNvbnRleHQpO1xuICAgIGNvbnN0IGVkaXRvclN0YXRlID0gdXNlTWVtbygoKSA9PiBlZGl0b3JDb250ZXh0RGF0YS5lZGl0b3JTdGF0ZSwgW2VkaXRvckNvbnRleHREYXRhLmVkaXRvclN0YXRlXSk7XG4gICAgY29uc3QgZmllbGRzTGF5b3V0ID0gdXNlTWVtbygoKSA9PiBjb25maWcuZmllbGRzTGF5b3V0IHx8IGVkaXRvckNvbnRleHREYXRhLmZpZWxkc0xheW91dCwgW2NvbmZpZywgZWRpdG9yQ29udGV4dERhdGEuZmllbGRzTGF5b3V0XSk7XG4gICAgY29uc3QgZGF0YVNvdXJjZVN0YXRlcyA9IHVzZU1lbW8oKCkgPT4gZWRpdG9yQ29udGV4dERhdGEuZGF0YVNvdXJjZXMsIFtlZGl0b3JDb250ZXh0RGF0YS5kYXRhU291cmNlc10pO1xuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlcyBmaWVsZCBkYXRhIGJ5IGV2YWx1YXRpbmcgZGF0YSBiaW5kaW5nIGFuZCByZXRyaWV2aW5nIGRhdGEgZnJvbSB0aGVtXG4gICAgICovXG4gICAgY29uc3QgcG9wdWxhdGVGaWVsZERhdGEgPSB1c2VDYWxsYmFjaygoZmllbGQsIGlucHV0RGF0YSkgPT4ge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gcmV0cmlldmVJbnB1dE9wdGlvbnMoZmllbGQsIGlucHV0RGF0YSk7XG4gICAgICAgIGNvbnN0IGdlbmVyaWNJbnB1dEZpZWxkQ29uZmlnID0ge1xuICAgICAgICAgICAgLi4uZmllbGQsXG4gICAgICAgIH07XG4gICAgICAgIGdlbmVyaWNJbnB1dEZpZWxkQ29uZmlnWydvcHRpb25zJ10gPSBvcHRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkLmRpc2FibGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZ2VuZXJpY0lucHV0RmllbGRDb25maWdbJ2Rpc2FibGVkJ10gPSBldmFsdWF0ZUxvZ2ljSW5Db250ZXh0KGZpZWxkLmRpc2FibGVkLCBidWlsZEV4cHJlc3Npb25Db250ZXh0KGVkaXRvclN0YXRlLmZvcm1TdGF0ZXMsIGVkaXRvckNvbnRleHREYXRhLmNvbnRleHRQYXJhbXMsIGlucHV0RGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWx1ZSA9IGlucHV0RGF0YSA/IGlucHV0RGF0YVtmaWVsZC5uYW1lXSA6IG51bGw7XG4gICAgICAgIGxldCBjb21wb25lbnREYXRhU3RhdHVzID0gRGF0YVN0YXR1cy5Mb2FkZWQ7XG4gICAgICAgIGlmIChmaWVsZC5kYXRhQmluZGluZ3MpIHtcbiAgICAgICAgICAgIGZpZWxkLmRhdGFCaW5kaW5ncy5mb3JFYWNoKChkYXRhQmluZGluZykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFTb3VyY2VTdGF0ZSA9IGRhdGFTb3VyY2VTdGF0ZXNbZGF0YUJpbmRpbmcuZGF0YXNvdXJjZUlkXTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVNvdXJjZVN0YXRlICYmIGRhdGFTb3VyY2VTdGF0ZS5zdGF0dXMgPT09IERhdGFTdGF0dXMuTG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BEYXRhID0gYWNjZXNzQW5kVHJhbnNmb3JtRGF0YShkYXRhU291cmNlU3RhdGUuZGF0YSwgZGF0YUJpbmRpbmcuYWNjZXNzb3IsIGRhdGFCaW5kaW5nLnRyYW5zZm9ybWVycyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhQmluZGluZy50YXJnZXRQcm9wZXJ0eSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9wRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhQmluZGluZy50YXJnZXRQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJpY0lucHV0RmllbGRDb25maWdbZGF0YUJpbmRpbmcudGFyZ2V0UHJvcGVydHldID0gcHJvcERhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudERhdGFTdGF0dXMgPSBEYXRhU3RhdHVzLkxvYWRpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZmllbGRDb25maWc6IGdlbmVyaWNJbnB1dEZpZWxkQ29uZmlnLCBjb21wb25lbnREYXRhU3RhdHVzLCB2YWx1ZSB9O1xuICAgIH0sIFtkYXRhU291cmNlU3RhdGVzLCBlZGl0b3JDb250ZXh0RGF0YS5jb250ZXh0UGFyYW1zLCBlZGl0b3JTdGF0ZS5mb3JtU3RhdGVzXSk7XG4gICAgY29uc3QgZ2V0VmlzaWJsZUZpZWxkcyA9IHVzZUNhbGxiYWNrKGZpZWxkU2V0RGF0YSA9PiB7XG4gICAgICAgIHJldHVybiBjb25maWcuZmllbGRzLmZpbHRlcihmaWVsZCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGQucmVuZGVyXG4gICAgICAgICAgICAgICAgPyBldmFsdWF0ZUxvZ2ljSW5Db250ZXh0KGZpZWxkLnJlbmRlciwgYnVpbGRFeHByZXNzaW9uQ29udGV4dChlZGl0b3JTdGF0ZS5mb3JtU3RhdGVzLCBlZGl0b3JDb250ZXh0RGF0YS5jb250ZXh0UGFyYW1zLCBmaWVsZFNldERhdGEpKVxuICAgICAgICAgICAgICAgIDogdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfSwgW2NvbmZpZy5maWVsZHMsIGVkaXRvckNvbnRleHREYXRhLmNvbnRleHRQYXJhbXMsIGVkaXRvclN0YXRlXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0VmlzaWJsZUZpZWxkcyxcbiAgICAgICAgZmllbGRzTGF5b3V0LFxuICAgICAgICBwb3B1bGF0ZUZpZWxkRGF0YSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlRmllbGRzZXRTdGF0ZS5qcy5tYXAiLCJpbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRm9ybUlucHV0RmllbGQgfSBmcm9tICcuL0Zvcm1JbnB1dEZpZWxkJztcbmltcG9ydCB7IGdlbmVyYXRlUmVhY3RLZXkgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGdldFZhbGlkYXRvckZ1bmN0aW9uIH0gZnJvbSAnLi92YWxpZGF0b3JzJztcbmltcG9ydCB7IHVzZURlY29yYXRvciwgdXNlVXRpbENvbXBvbmVudCB9IGZyb20gJy4vaG9va3MnO1xuaW1wb3J0IHsgdXNlRmllbGRzZXRTdGF0ZSB9IGZyb20gJy4vaG9va3MvdXNlRmllbGRzZXRTdGF0ZSc7XG5leHBvcnQgZnVuY3Rpb24gRm9ybUZpZWxkc2V0KHsgY29uZmlnLCBpbnB1dERhdGEsIG9uQ2hhbmdlLCByb3dJbmRleCA9IC0xLCBvblJvd0RlbGV0ZSwgc2hvd0ZpZWxkTGFiZWxzID0gdHJ1ZSwgfSkge1xuICAgIGNvbnN0IGFycmFuZ2VGaWVsZHMgPSBjb25maWcuYXJyYW5nZUZpZWxkcyB8fCAnY29sdW1uJztcbiAgICBjb25zdCBbZmllbGRzVmFsaWRhdGlvblN0YXRlLCBzZXRGaWVsZFZhbGlkYXRpb25TdGF0ZV0gPSB1c2VTdGF0ZSh7fSk7XG4gICAgY29uc3QgZmllbGRTZXRWYWx1ZXMgPSBpbnB1dERhdGE7XG4gICAgY29uc3QgW2NvbGxhcHNlZCwgc2V0Q29sbGFwc2VkXSA9IHVzZVN0YXRlKCEhY29uZmlnLmNvbGxhcHNpYmxlICYmICEhY29uZmlnLmNvbGxhcHNlZCk7XG4gICAgY29uc3QgeyBnZXRWaXNpYmxlRmllbGRzLCBwb3B1bGF0ZUZpZWxkRGF0YSwgZmllbGRzTGF5b3V0IH0gPSB1c2VGaWVsZHNldFN0YXRlKGNvbmZpZyk7XG4gICAgY29uc3QgRm9ybURpdmlkZXIgPSB1c2VVdGlsQ29tcG9uZW50KCdkaXZpZGVyJyk7XG4gICAgY29uc3QgdmlzaWJsZUZvcm1GaWVsZHMgPSBnZXRWaXNpYmxlRmllbGRzKGlucHV0RGF0YSk7XG4gICAgY29uc3Qgc2hvd1RpdGxlID0gY29uZmlnLnNob3dUaXRsZSAhPT0gdW5kZWZpbmVkID8gY29uZmlnLnNob3dUaXRsZSA6IHRydWU7XG4gICAgY29uc3QgeyBnZXRGaWVsZHNldERlY29yYXRvciB9ID0gdXNlRGVjb3JhdG9yKCk7XG4gICAgY29uc3QgZGVmYXVsdERlY29yYXRvck5hbWUgPSBnZXRGaWVsZHNldERlY29yYXRvck5hbWUoYXJyYW5nZUZpZWxkcyk7XG4gICAgY29uc3QgZGVjb3JhdG9yTmFtZSA9IGNvbmZpZy5maWVsZFNldERlY29yYXRvciB8fCBkZWZhdWx0RGVjb3JhdG9yTmFtZTtcbiAgICBjb25zdCBGaWVsZFNldERlY29yYXRvciA9IGdldEZpZWxkc2V0RGVjb3JhdG9yKGRlY29yYXRvck5hbWUpO1xuICAgIGNvbnN0IGlzRmllbGRTZXRWYWxpZCA9IHVzZUNhbGxiYWNrKChmaWVsZHNEYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHRtcFZhbGlkYXRpb25TdGF0ZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpYmxlRm9ybUZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSB2aXNpYmxlRm9ybUZpZWxkc1tpXTtcbiAgICAgICAgICAgIGlmIChmaWVsZC50eXBlID09PSAnZGl2aWRlcicpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGRzRGF0YVtmaWVsZC5uYW1lXTtcbiAgICAgICAgICAgIGlmIChmaWVsZC5yZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRvckZuID0gZ2V0VmFsaWRhdG9yRnVuY3Rpb24oJ3JlcXVpcmVkJywgZmllbGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXMgPSB2YWxpZGF0b3JGbih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25SZXMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wVmFsaWRhdGlvblN0YXRlc1tmaWVsZC5uYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9yczogdmFsaWRhdGlvblJlcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2V0RmllbGRWYWxpZGF0aW9uU3RhdGUodG1wVmFsaWRhdGlvblN0YXRlcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmllbGQudmFsaWRhdG9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdG9yRm4gPSBnZXRWYWxpZGF0b3JGdW5jdGlvbihmaWVsZC52YWxpZGF0b3IsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzID0gdmFsaWRhdG9yRm4odmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uUmVzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcFZhbGlkYXRpb25TdGF0ZXNbZmllbGQubmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnM6IHZhbGlkYXRpb25SZXMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNldEZpZWxkVmFsaWRhdGlvblN0YXRlKHRtcFZhbGlkYXRpb25TdGF0ZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldEZpZWxkVmFsaWRhdGlvblN0YXRlKHRtcFZhbGlkYXRpb25TdGF0ZXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBbdmlzaWJsZUZvcm1GaWVsZHNdKTtcbiAgICBjb25zdCBoYW5kbGVDb2xsYXBzRXhwYW5kID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBzZXRDb2xsYXBzZWQoIWNvbGxhcHNlZCk7XG4gICAgfSwgW2NvbGxhcHNlZF0pO1xuICAgIGNvbnN0IGhhbmRsZUZpZWxkQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCBuZXdGaWVsZFNldERhdGEgPSB7XG4gICAgICAgICAgICAuLi5maWVsZFNldFZhbHVlcyxcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFNldElzVmFsaWQgPSBpc0ZpZWxkU2V0VmFsaWQobmV3RmllbGRTZXREYXRhKTtcbiAgICAgICAgICAgIG9uQ2hhbmdlKG5ld0ZpZWxkU2V0RGF0YSwgZmllbGRTZXRJc1ZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sIFtmaWVsZFNldFZhbHVlcywgaXNGaWVsZFNldFZhbGlkLCBvbkNoYW5nZV0pO1xuICAgIGNvbnN0IHJlbmRlckZpZWxkcyA9IChmaWVsZHMpID0+IHtcbiAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoKGZpZWxkLCBmaWVsZEluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoZmllbGQudHlwZSA9PT0gJ2RpdmlkZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1EaXZpZGVyLCB7IGtleTogZ2VuZXJhdGVSZWFjdEtleSgnZGl2aWRlcicsIGAke2ZpZWxkSW5kZXh9YCksIGNvbmZpZzogZmllbGQgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBmaWVsZENvbmZpZywgY29tcG9uZW50RGF0YVN0YXR1cywgdmFsdWUgfSA9IHBvcHVsYXRlRmllbGREYXRhKGZpZWxkLCBpbnB1dERhdGEpO1xuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGZpZWxkc1ZhbGlkYXRpb25TdGF0ZVtmaWVsZC5uYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRGaWVsZCA9IHZhbGlkYXRpb25SZXN1bHQgPyB2YWxpZGF0aW9uUmVzdWx0LmlzVmFsaWQgOiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1JbnB1dEZpZWxkLCB7IGtleTogZ2VuZXJhdGVSZWFjdEtleShjb25maWcubmFtZSwgZmllbGQudHlwZSwgZmllbGQubmFtZSksIHZhbHVlOiB2YWx1ZSwgbGFiZWw6IHNob3dGaWVsZExhYmVscyA/IGZpZWxkLmxhYmVsIDogdW5kZWZpbmVkLCBvcHRpb25zOiBmaWVsZENvbmZpZy5vcHRpb25zLCBjb25maWc6IGZpZWxkQ29uZmlnLCBvbkNoYW5nZTogaGFuZGxlRmllbGRDaGFuZ2UsIHN0YXR1czogY29tcG9uZW50RGF0YVN0YXR1cywgaXNWYWxpZDogaXNWYWxpZEZpZWxkLCB2YWxpZGF0aW9uRXJyb3JzOiB2YWxpZGF0aW9uUmVzdWx0Py52YWxpZGF0aW9uRXJyb3JzIHx8IFtdLCBmaWVsZExheW91dDogZmllbGRzTGF5b3V0IH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRmllbGRTZXREZWNvcmF0b3IsIHsgb25Db2xsYXBzZTogaGFuZGxlQ29sbGFwc0V4cGFuZCwgbGVnZW5kOiBzaG93VGl0bGUgPyBjb25maWcudGl0bGUgOiB1bmRlZmluZWQsIGNvbGxhcHNpYmxlOiBjb25maWcuY29sbGFwc2libGUsIGNvbGxhcHNlZDogY29sbGFwc2VkLCBjb25maWc6IGNvbmZpZywgb25Sb3dEZWxldGU6IG9uUm93RGVsZXRlLCByb3dJbmRleDogcm93SW5kZXggfSwgcmVuZGVyRmllbGRzKHZpc2libGVGb3JtRmllbGRzKSkpO1xufVxuZnVuY3Rpb24gZ2V0RmllbGRzZXREZWNvcmF0b3JOYW1lKGFycmFuZ2VGaWVsZHMpIHtcbiAgICBzd2l0Y2ggKGFycmFuZ2VGaWVsZHMpIHtcbiAgICAgICAgY2FzZSAndGFibGVSb3cnOlxuICAgICAgICAgICAgcmV0dXJuICd0YWJsZVJvd0ZpZWxkc2V0JztcbiAgICAgICAgY2FzZSAnY29sdW1uJzpcbiAgICAgICAgICAgIHJldHVybiAnY29sdW1uRmllbGRzZXQnO1xuICAgICAgICBjYXNlICdyb3cnOlxuICAgICAgICAgICAgcmV0dXJuICdyb3dGaWVsZHNldCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ2NvbHVtbkZpZWxkc2V0JztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gb3JtRmllbGRzZXQuanMubWFwIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBldmFsdWF0ZUxvZ2ljSW5Db250ZXh0IH0gZnJvbSAnLi4vZGF0YSc7XG5pbXBvcnQgeyBFZGl0b3JDb250ZXh0IH0gZnJvbSAnLi4vRWRpdG9yQ29udGV4dCc7XG5pbXBvcnQgeyBidWlsZEV4cHJlc3Npb25Db250ZXh0IH0gZnJvbSAnLi4vdXRpbHMnO1xuZXhwb3J0IGNvbnN0IHVzZUZvcm1TdGF0ZSA9IChmb3JtQ29uZmlnKSA9PiB7XG4gICAgY29uc3QgZWRpdG9yQ29udGV4dERhdGEgPSB1c2VDb250ZXh0KEVkaXRvckNvbnRleHQpO1xuICAgIGNvbnN0IGVkaXRvclN0YXRlID0gdXNlTWVtbygoKSA9PiBlZGl0b3JDb250ZXh0RGF0YS5lZGl0b3JTdGF0ZSwgW2VkaXRvckNvbnRleHREYXRhLmVkaXRvclN0YXRlXSk7XG4gICAgY29uc3QgZm9ybVN0YXRlID0gdXNlTWVtbygoKSA9PiBlZGl0b3JTdGF0ZS5mb3JtU3RhdGVzW2Zvcm1Db25maWcuaWRdLCBbZm9ybUNvbmZpZywgZWRpdG9yU3RhdGVdKTtcbiAgICBjb25zdCBnZXRGaWVsZHNldFN0YXRlID0gdXNlQ2FsbGJhY2soKGZpZWxkc2V0TmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gZm9ybVN0YXRlID8gZm9ybVN0YXRlW2ZpZWxkc2V0TmFtZV0gOiB7fTtcbiAgICB9LCBbZm9ybVN0YXRlXSk7XG4gICAgY29uc3QgZ2V0VmlzaWJsZUZpZWxkU2V0cyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGZvcm1Db25maWcuZmllbGRTZXRzLmZpbHRlcihmaWVsZFNldEVudHJ5ID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZFNldEVudHJ5LnJlbmRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmFsdWF0ZUxvZ2ljSW5Db250ZXh0KGZpZWxkU2V0RW50cnkucmVuZGVyLCBidWlsZEV4cHJlc3Npb25Db250ZXh0KGVkaXRvclN0YXRlLmZvcm1TdGF0ZXMsIGVkaXRvckNvbnRleHREYXRhLmNvbnRleHRQYXJhbXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9LCBbZWRpdG9yQ29udGV4dERhdGEuY29udGV4dFBhcmFtcywgZWRpdG9yU3RhdGUsIGZvcm1Db25maWcuZmllbGRTZXRzXSk7XG4gICAgcmV0dXJuIHsgZm9ybVN0YXRlLCBnZXRGaWVsZHNldFN0YXRlLCBnZXRWaXNpYmxlRmllbGRTZXRzIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlRm9ybVN0YXRlLmpzLm1hcCIsImltcG9ydCB7IHVzZUNvbnRleHQsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBFZGl0b3JDb250ZXh0IH0gZnJvbSAnLi4vRWRpdG9yQ29udGV4dCc7XG5leHBvcnQgY29uc3QgdXNlRWRpdG9yTWV0YWRhdGEgPSAoKSA9PiB7XG4gICAgY29uc3QgZWRpdG9yQ29udGV4dERhdGEgPSB1c2VDb250ZXh0KEVkaXRvckNvbnRleHQpO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IGVkaXRvckNvbnRleHREYXRhLmVkaXRvck1ldGFkYXRhLCBbZWRpdG9yQ29udGV4dERhdGEuZWRpdG9yTWV0YWRhdGFdKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VFZGl0b3JNZXRhZGF0YS5qcy5tYXAiLCJpbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBGb3JtRmllbGRzZXQgfSBmcm9tICcuL0Zvcm1GaWVsZHNldCc7XG5pbXBvcnQgeyBnZW5lcmF0ZVJlYWN0S2V5IH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyB1c2VGb3JtU3RhdGUgfSBmcm9tICcuL2hvb2tzL3VzZUZvcm1TdGF0ZSc7XG5pbXBvcnQgeyB1c2VFZGl0b3JNZXRhZGF0YSB9IGZyb20gJy4vaG9va3MvdXNlRWRpdG9yTWV0YWRhdGEnO1xuaW1wb3J0IHsgdXNlRGVjb3JhdG9yIH0gZnJvbSAnLi9ob29rcyc7XG5leHBvcnQgZnVuY3Rpb24gSW5wdXRGb3JtKHsgY29uZmlnLCBvbkNoYW5nZSwgc2hvd1RpdGxlID0gdHJ1ZSwgfSkge1xuICAgIGNvbnN0IHsgZ2V0RmllbGRzZXRTdGF0ZSwgZm9ybVN0YXRlLCBnZXRWaXNpYmxlRmllbGRTZXRzIH0gPSB1c2VGb3JtU3RhdGUoY29uZmlnKTtcbiAgICBjb25zdCBlZGl0b3JNZXRhZGF0YSA9IHVzZUVkaXRvck1ldGFkYXRhKCk7XG4gICAgY29uc3QgdmlzaWJsZUZpZWxkU2V0cyA9IGdldFZpc2libGVGaWVsZFNldHMoKTtcbiAgICBjb25zdCB7IGdldExpc3RFZGl0b3JEZWNvcmF0b3IgfSA9IHVzZURlY29yYXRvcigpO1xuICAgIGNvbnN0IGhhbmRsZUZpZWxkc2V0Q2hhbmdlID0gdXNlQ2FsbGJhY2soKGZyZXNoRGF0YSwgbmFtZSwgaXNGaWVsZHNldFZhbGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkc2V0VmFsdWVzRW50cnkgPSBnZXRGaWVsZHNldFN0YXRlKG5hbWUpO1xuICAgICAgICBjb25zdCBuZXdEYXRhID0geyAuLi5mb3JtU3RhdGUgfTtcbiAgICAgICAgbmV3RGF0YVtuYW1lXSA9IHtcbiAgICAgICAgICAgIGRhdGE6IChmaWVsZHNldFZhbHVlc0VudHJ5XG4gICAgICAgICAgICAgICAgPyBBcnJheS5pc0FycmF5KGZpZWxkc2V0VmFsdWVzRW50cnkuZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgPyBbLi4uZnJlc2hEYXRhXVxuICAgICAgICAgICAgICAgICAgICA6IHsgLi4uZmllbGRzZXRWYWx1ZXNFbnRyeS5kYXRhLCAuLi5mcmVzaERhdGEgfVxuICAgICAgICAgICAgICAgIDogZnJlc2hEYXRhKSxcbiAgICAgICAgICAgIGlzVmFsaWQ6IGlzRmllbGRzZXRWYWxpZCxcbiAgICAgICAgfTtcbiAgICAgICAgb25DaGFuZ2UobmV3RGF0YSwgY29uZmlnLmlkLCBuYW1lLCBpc0Zvcm1WYWxpZChuZXdEYXRhLCBpc0ZpZWxkc2V0VmFsaWQpKTtcbiAgICB9LCBbZ2V0RmllbGRzZXRTdGF0ZSwgZm9ybVN0YXRlLCBvbkNoYW5nZSwgY29uZmlnLmlkXSk7XG4gICAgY29uc3QgaXNTaG93VGl0bGUgPSBlZGl0b3JNZXRhZGF0YS5kaXNwbGF5QXMgPT09ICd0YWJTZXQnID8gZmFsc2UgOiBzaG93VGl0bGUgJiYgY29uZmlnLnRpdGxlO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImZvcm1cIiwgbnVsbCxcbiAgICAgICAgICAgIGlzU2hvd1RpdGxlID8gUmVhY3QuY3JlYXRlRWxlbWVudChcImgyXCIsIG51bGwsIGNvbmZpZy50aXRsZSkgOiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsKSxcbiAgICAgICAgICAgIHZpc2libGVGaWVsZFNldHMubWFwKChmaWVsZFNldEVudHJ5LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRTZXREYXRhID0gZm9ybVN0YXRlID8gZm9ybVN0YXRlW2ZpZWxkU2V0RW50cnkubmFtZV0gOiB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkU2V0RW50cnkudHlwZSA9PT0gJ2ZpZWxkU2V0TGlzdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlzdEVkaXRvckNvbmZpZyA9IGZpZWxkU2V0RW50cnk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVSZWFjdEtleShjb25maWcuaWQsIGxpc3RFZGl0b3JDb25maWcubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IExpc3RFZGl0b3IgPSBnZXRMaXN0RWRpdG9yRGVjb3JhdG9yKGxpc3RFZGl0b3JDb25maWcuZGVjb3JhdG9yIHx8ICdkZWZhdWx0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIsIHsga2V5OiBpZCwgY2xhc3NOYW1lOiAnbWYtZmllbGRzZXQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0RWRpdG9yQ29uZmlnLmxhYmVsICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsZWdlbmRcIiwgbnVsbCwgbGlzdEVkaXRvckNvbmZpZy5sYWJlbCksXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KExpc3RFZGl0b3IsIHsgbmFtZTogZmllbGRTZXRFbnRyeS5uYW1lLCByb3dGaWVsZHNldDogbGlzdEVkaXRvckNvbmZpZy5yb3dGaWVsZHNldCwgZGF0YTogZmllbGRTZXREYXRhLmRhdGEgfHwgW10sIGNhbkRlbGV0ZVJvd3M6IGxpc3RFZGl0b3JDb25maWcuY2FuRGVsZXRlUm93cywgb25DaGFuZ2U6IChuZXdEYXRhLCBpc1ZhbGlkKSA9PiBoYW5kbGVGaWVsZHNldENoYW5nZShuZXdEYXRhLCBmaWVsZFNldEVudHJ5Lm5hbWUsIGlzVmFsaWQpLCBzaG93SGVhZGVyOiBsaXN0RWRpdG9yQ29uZmlnLnNob3dIZWFkZXIsIHNob3dCb3JkZXJzOiBsaXN0RWRpdG9yQ29uZmlnLnNob3dCb3JkZXJzLCBjYW5BZGRSb3dzOiBsaXN0RWRpdG9yQ29uZmlnLmNhbkFkZFJvd3MgfSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybUZpZWxkc2V0LCB7IGtleTogZ2VuZXJhdGVSZWFjdEtleShjb25maWcuaWQsIGZpZWxkU2V0RW50cnkubmFtZSwgZmllbGRTZXRFbnRyeS50eXBlKSwgY29uZmlnOiBmaWVsZFNldEVudHJ5LCBpbnB1dERhdGE6IGZpZWxkU2V0RGF0YS5kYXRhIHx8IHt9LCBvbkNoYW5nZTogKG5ld0ZpZWxkU2V0RGF0YSwgaXNWYWxpZCkgPT4gaGFuZGxlRmllbGRzZXRDaGFuZ2UobmV3RmllbGRTZXREYXRhLCBmaWVsZFNldEVudHJ5Lm5hbWUsIGlzVmFsaWQpIH0pKTtcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJyXCIsIG51bGwpKSk7XG59XG5jb25zdCBpc0Zvcm1WYWxpZCA9IChuZXdEYXRhLCB2YWxpZCkgPT4ge1xuICAgIGxldCBrO1xuICAgIGZvciAoayBpbiBuZXdEYXRhKSB7XG4gICAgICAgIHZhbGlkID0gdHlwZW9mIG5ld0RhdGFba10uaXNWYWxpZCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXdEYXRhW2tdLmlzVmFsaWQgOiB2YWxpZDtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlucHV0Rm9ybS5qcy5tYXAiLCJpbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgSW5wdXRGb3JtIH0gZnJvbSAnLi9JbnB1dEZvcm0nO1xuaW1wb3J0IHsgZ2VuZXJhdGVSZWFjdEtleSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgdXNlVXRpbENvbXBvbmVudCB9IGZyb20gJy4vaG9va3MnO1xuZXhwb3J0IGZ1bmN0aW9uIEZvcm1zQ29udGFpbmVyKHsgZm9ybXMsIG9uRm9ybUNoYW5nZSwgZGlzcGxheUFzID0gJ3RhYlNldCcsIGFjdGl2ZUZvcm0sIH0pIHtcbiAgICBjb25zdCBbYWN0aXZlVGFiLCBzZXRBY3RpdmVUYWJdID0gdXNlU3RhdGUoYWN0aXZlRm9ybSk7XG4gICAgY29uc3QgVGFiYmVkU2VjdGlvbiA9IHVzZVV0aWxDb21wb25lbnQoJ3RhYmJlZFNlY3Rpb24nKTtcbiAgICBjb25zdCBoYW5kbGVTd2l0Y2hUYWIgPSB1c2VDYWxsYmFjaygodGFiSWQpID0+IHtcbiAgICAgICAgc2V0QWN0aXZlVGFiKHRhYklkKTtcbiAgICB9LCBbXSk7XG4gICAgaWYgKGRpc3BsYXlBcyA9PT0gJ3RhYlNldCcpIHtcbiAgICAgICAgY29uc3QgdGFicyA9IGZvcm1zLm1hcCgoZm9ybUNvbmZpZywgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogZm9ybUNvbmZpZy5pZCxcbiAgICAgICAgICAgICAgICBsYWJlbDogZm9ybUNvbmZpZy50aXRsZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAoUmVhY3QuY3JlYXRlRWxlbWVudChJbnB1dEZvcm0sIHsga2V5OiBnZW5lcmF0ZVJlYWN0S2V5KCdjb25maWdGb3JtJywgZm9ybUNvbmZpZy5pZCksIGNvbmZpZzogZm9ybUNvbmZpZywgb25DaGFuZ2U6IG9uRm9ybUNoYW5nZSB9KSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGFiYmVkU2VjdGlvbiwgeyBzZWxlY3RlZDogYWN0aXZlVGFiLCBvblRhYjogaGFuZGxlU3dpdGNoVGFiLCB0YWJzOiB0YWJzIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBmb3Jtcy5tYXAoKGZvcm1Db25maWcsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChJbnB1dEZvcm0sIHsga2V5OiBnZW5lcmF0ZVJlYWN0S2V5KCdjb25maWdGb3JtJywgZm9ybUNvbmZpZy5pZCksIHNob3dUaXRsZTogZm9ybUNvbmZpZy5zaG93VGl0bGUsIGNvbmZpZzogZm9ybUNvbmZpZywgb25DaGFuZ2U6IG9uRm9ybUNoYW5nZSB9KSk7XG4gICAgICAgIH0pKSk7XG4gICAgfVxufVxuRm9ybXNDb250YWluZXIuZGlzcGxheU5hbWUgPSAnRm9ybXNDb250YWluZXInO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Rm9ybXNDb250YWluZXIuanMubWFwIiwiaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZU1lbW8sIHVzZVJlZHVjZXIsIHVzZVJlZiwgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBlZGl0b3JTdGF0ZVJlZHVjZXIgfSBmcm9tICcuL0Zvcm1FZGl0b3JSZWR1Y2VyJztcbmltcG9ydCB7IEZvcm1zQ29udGFpbmVyIH0gZnJvbSAnLi9Gb3Jtc0NvbnRhaW5lcic7XG5pbXBvcnQgeyBFZGl0b3JDb250ZXh0IH0gZnJvbSAnLi9FZGl0b3JDb250ZXh0JztcbmltcG9ydCB7IGJ1aWxkRm9ybVN0YXRlc0Zyb21EYXRhIH0gZnJvbSAnLi91dGlscyc7XG5leHBvcnQgZnVuY3Rpb24gRm9ybUVkaXRvcih7IGVkaXRvck1ldGFkYXRhLCBpbml0aWFsRGF0YSwgb25DaGFuZ2UsIGRhdGFTb3VyY2VTdGF0ZXMsIHRocm90dGxlQ2hhbmdlLCBjaGFuZ2VJbnRlcnZhbCA9IDEwMDAsIGNvbXBvbmVudFJlZ2lzdHJ5LCBjb250ZXh0UGFyYW1zLCBlZGl0b3JSZWYsIH0pIHtcbiAgICBjb25zdCB7IGlzVmFsaWQsIG1lc3NhZ2U6IHZhbGlkYXRvck1lc3NhZ2UgPSB1bmRlZmluZWQgfSA9IGVkaXRvck1ldGFkYXRhLnJlc3VsdFZhbGlkYXRvclxuICAgICAgICA/IGVkaXRvck1ldGFkYXRhLnJlc3VsdFZhbGlkYXRvcihpbml0aWFsRGF0YSlcbiAgICAgICAgOiB7IGlzVmFsaWQ6IHRydWUgfTtcbiAgICBjb25zdCBbZWRpdG9yU3RhdGUsIGRpc3BhdGNoU3RhdGVBY3Rpb25dID0gdXNlUmVkdWNlcihlZGl0b3JTdGF0ZVJlZHVjZXIsIHtcbiAgICAgICAgLy9idWlsZCBpbml0aWFsIHN0YXRlIGZyb20gdGhlIHByb3ZpZGVkIGlucHV0XG4gICAgICAgIGVkaXRvclJlc3VsdDogaW5pdGlhbERhdGEsXG4gICAgICAgIGZvcm1TdGF0ZXM6IHt9LFxuICAgICAgICBpc1ZhbGlkLFxuICAgICAgICB2YWxpZGF0b3JNZXNzYWdlLFxuICAgIH0sIChpbml0aWFsU3RhdGUpID0+ICh7XG4gICAgICAgIC4uLmluaXRpYWxTdGF0ZSxcbiAgICAgICAgZm9ybVN0YXRlczogYnVpbGRGb3JtU3RhdGVzRnJvbURhdGEoZWRpdG9yTWV0YWRhdGEsIGluaXRpYWxEYXRhKSxcbiAgICB9KSk7XG4gICAgLy8gQ2hhbmdlIHRpbWUgb3V0IGlzIHVzZWQgZm9yIHRocm90bGluZyBjaGFuZ2VzIC0gdG8gbWluaW1pemUgZnJlcXVlbmN5IG9mIGhvdyBvZnRlbiBvbkNoYW5nZSBoYW5kbGVyIGlzIGludm9rZWRcbiAgICAvL2NvbnN0IFtjaGFuZ2VUaW1lb3V0LCBzZXRDaGFuZ2VUaW1lb3V0XSA9IHVzZVN0YXRlPE5vZGVKUy5UaW1lb3V0IHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuICAgIGNvbnN0IGNoYW5nZVRpbWVvdXRSZWYgPSB1c2VSZWYodW5kZWZpbmVkKTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKGVkaXRvclJlZiwgKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0RGF0YTogKG5ld0RhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtU3RhdGVzOiBidWlsZEZvcm1TdGF0ZXNGcm9tRGF0YShlZGl0b3JNZXRhZGF0YSwgbmV3RGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3JSZXN1bHQ6IG5ld0RhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaFN0YXRlQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3JlcGxhY2UnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvLyBFZGl0b3IgY29udGV4dCBEYXRhIHN0b3JlcyBkYXRhIHNvdXJjZSBzdGF0ZSBhbmQgZWRpdG9yIHN0YXRlXG4gICAgY29uc3QgZWRpdG9yQ29udGV4dERhdGEgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIGRhdGFTb3VyY2VzOiBkYXRhU291cmNlU3RhdGVzIHx8IHt9LFxuICAgICAgICBjb21wb25lbnRSZWdpc3RyeSxcbiAgICAgICAgZWRpdG9yU3RhdGUsXG4gICAgICAgIGVkaXRvck1ldGFkYXRhLFxuICAgICAgICBjb250ZXh0UGFyYW1zLFxuICAgICAgICBmaWVsZHNMYXlvdXQ6IGVkaXRvck1ldGFkYXRhLmZpZWxkc0xheW91dCB8fCAnY29tcGFjdCcsXG4gICAgfSksIFtkYXRhU291cmNlU3RhdGVzLCBjb21wb25lbnRSZWdpc3RyeSwgZWRpdG9yU3RhdGUsIGVkaXRvck1ldGFkYXRhLCBjb250ZXh0UGFyYW1zXSk7XG4gICAgY29uc3QgTG9hZGluZ0NvbXBvbmVudCA9IGNvbXBvbmVudFJlZ2lzdHJ5LnV0aWxpdHlDb21wb25lbnRzLmxvYWRpbmc7XG4gICAgLy9IYW5kbGVyIGZvciBjZXJ0YWluIGZvcm0gY2hhbmdlXG4gICAgY29uc3QgaGFuZGxlRm9ybUNoYW5nZSA9IHVzZUNhbGxiYWNrKChmcmVzaEZvcm1EYXRhLCBmb3JtTmFtZSwgZmllbGRTZXROYW1lLCBpc0Zvcm1WYWxpZCkgPT4ge1xuICAgICAgICBjb25zdCBoYXNSZWR1Y2VycyA9IGVkaXRvck1ldGFkYXRhLnJlZHVjZXJzTWFwICYmIE9iamVjdC5rZXlzKGVkaXRvck1ldGFkYXRhLnJlZHVjZXJzTWFwKS5sZW5ndGggPiAwO1xuICAgICAgICBjb25zdCBjaGFuZ2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgZm9ybUlkOiBmb3JtTmFtZSxcbiAgICAgICAgICAgIGZpZWxkU2V0TmFtZSxcbiAgICAgICAgICAgIGRhdGE6IGZyZXNoRm9ybURhdGEsXG4gICAgICAgICAgICBpc1ZhbGlkOiBpc0Zvcm1WYWxpZCxcbiAgICAgICAgICAgIGVkaXRvck1ldGFkYXRhLFxuICAgICAgICAgICAgZWRpdG9yUmVkdWNlcnNNYXA6IGhhc1JlZHVjZXJzID8gZWRpdG9yTWV0YWRhdGEucmVkdWNlcnNNYXAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb250ZXh0UGFyYW1zOiBlZGl0b3JDb250ZXh0RGF0YS5jb250ZXh0UGFyYW1zLFxuICAgICAgICB9O1xuICAgICAgICBkaXNwYXRjaFN0YXRlQWN0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICdmb3JtQ2hhbmdlJyxcbiAgICAgICAgICAgIHBheWxvYWQ6IGNoYW5nZVBheWxvYWQsXG4gICAgICAgIH0pO1xuICAgIH0sIFtlZGl0b3JNZXRhZGF0YSwgZWRpdG9yQ29udGV4dERhdGFdKTtcbiAgICBjb25zdCBzY2hlZHVsZU9uQ2hhbmdlID0gdXNlQ2FsbGJhY2soKGVkaXRvclJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnRWRpdG9yIHdpbGwgc3VibWl0IGNoYW5nZXMgaW46ICcsIGAke2NoYW5nZUludGVydmFsfU1zYCk7XG4gICAgICAgIGNvbnN0IG5ld1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFZGl0b3Igc3VibWl0dGVkIENoYW5nZXMuJyk7XG4gICAgICAgICAgICBjaGFuZ2VUaW1lb3V0UmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBvbkNoYW5nZShlZGl0b3JSZXN1bHQsIHRydWUpO1xuICAgICAgICB9LCBjaGFuZ2VJbnRlcnZhbCk7XG4gICAgICAgIHJldHVybiBuZXdUaW1lb3V0O1xuICAgIH0sIFtjaGFuZ2VJbnRlcnZhbCwgb25DaGFuZ2VdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBDYXB0dXJlcyBlZGl0b3Igc3RhdGUgY2hhbmdlIGFuZCBjYWxscyBvbkNoYW5nZSBoYW5kbGVyLlxuICAgICAgICBjb25zdCBpc0Zvcm1WYWxpZCA9ICEhZWRpdG9yU3RhdGUuaXNWYWxpZDtcbiAgICAgICAgY29uc3QgZWRpdG9yUmVzdWx0ID0gZWRpdG9yU3RhdGUuZWRpdG9yUmVzdWx0O1xuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgIG9uQ2hhbmdlKGVkaXRvclJlc3VsdCwgaXNWYWxpZCwgZWRpdG9yU3RhdGUudmFsaWRhdG9yTWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVkaXRvclJlc3VsdCA9PT0gaW5pdGlhbERhdGEgLyp8fCBlcXVhbChlZGl0b3JSZXN1bHQsIGluaXRpYWxEYXRhKSovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocm90dGxlQ2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlVGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNoYW5nZVRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFuZ2VUaW1lb3V0UmVmLmN1cnJlbnQgPSBzY2hlZHVsZU9uQ2hhbmdlKGVkaXRvclJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbkNoYW5nZShlZGl0b3JSZXN1bHQsIGlzRm9ybVZhbGlkLCBlZGl0b3JTdGF0ZS52YWxpZGF0b3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSW4gb3JkZXIgZm9yIHRoZSB0aHJvdHRsZSBjaGFuZ2UgdG8gd29yayBwcm9wZXJseSBhbmQgYXZvaWQgaW5maW5pdGUgbG9vcCB0aGlzIGVmZmVjdCBjYW5ub3QgZGVwZW5kIG9uIHRoZSB0aW1lb3V0XG4gICAgICAgICAqIE5lZWQgdGhlIGxpbmUgYmVsb3cgYGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNgXG4gICAgICAgICAqL1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW2VkaXRvclN0YXRlLCBpbml0aWFsRGF0YSwgb25DaGFuZ2UsIHNjaGVkdWxlT25DaGFuZ2VdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiY29uZmlnLWVkaXRvclwiIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZWRpdG9yLXN0YXR1c1wiIH0sIGNoYW5nZVRpbWVvdXRSZWYuY3VycmVudCAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJpbmZvXCIgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTG9hZGluZ0NvbXBvbmVudCwgeyBsb2FkaW5nVGV4dDogJ0FwcGx5aW5nIGNoYW5nZXMuLi4nIH0pKSkpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEVkaXRvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGVkaXRvckNvbnRleHREYXRhIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1zQ29udGFpbmVyLCB7IGRpc3BsYXlBczogZWRpdG9yTWV0YWRhdGEuZGlzcGxheUFzIHx8ICdvbmVQYWdlJywgYWN0aXZlRm9ybTogZWRpdG9yTWV0YWRhdGEuYWN0aXZlRm9ybSB8fCBlZGl0b3JNZXRhZGF0YS5mb3Jtc1swXT8uaWQsIGZvcm1zOiBlZGl0b3JNZXRhZGF0YS5mb3Jtcywgb25Gb3JtQ2hhbmdlOiBoYW5kbGVGb3JtQ2hhbmdlIH0pKSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Rm9ybUVkaXRvci5qcy5tYXAiLCJleHBvcnQgKiBmcm9tICcuL0Zvcm1FZGl0b3InO1xuZXhwb3J0ICogZnJvbSAnLi9Gb3JtSW5wdXRGaWVsZCc7XG5leHBvcnQgKiBmcm9tICcuL0Zvcm1GaWVsZHNldCc7XG5leHBvcnQgKiBmcm9tICcuL2hvb2tzJztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscyc7XG5leHBvcnQgKiBmcm9tICcuL0VkaXRvckNvbnRleHQnO1xuZXhwb3J0IHsgVW5zdXBwb3J0ZWRJbnB1dENvbXBvbmVudCB9IGZyb20gJy4vVW5zdXBwb3J0ZWRJbnB1dENvbXBvbmVudCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/.pnpm/@mito-forms+core@0.2.23-beta_typescript@5.8.3/node_modules/@mito-forms/core/dist/index.js\n')},"../../node_modules/.pnpm/jmespath@0.16.0/node_modules/jmespath/jmespath.js":(__unused_webpack_module,exports)=>{eval('(function(exports) {\n  "use strict";\n\n  function isArray(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === "[object Array]";\n    } else {\n      return false;\n    }\n  }\n\n  function isObject(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === "[object Object]";\n    } else {\n      return false;\n    }\n  }\n\n  function strictDeepEqual(first, second) {\n    // Check the scalar case first.\n    if (first === second) {\n      return true;\n    }\n\n    // Check if they are the same type.\n    var firstType = Object.prototype.toString.call(first);\n    if (firstType !== Object.prototype.toString.call(second)) {\n      return false;\n    }\n    // We know that first and second have the same type so we can just check the\n    // first type from now on.\n    if (isArray(first) === true) {\n      // Short circuit if they\'re not the same length;\n      if (first.length !== second.length) {\n        return false;\n      }\n      for (var i = 0; i < first.length; i++) {\n        if (strictDeepEqual(first[i], second[i]) === false) {\n          return false;\n        }\n      }\n      return true;\n    }\n    if (isObject(first) === true) {\n      // An object is equal if it has the same key/value pairs.\n      var keysSeen = {};\n      for (var key in first) {\n        if (hasOwnProperty.call(first, key)) {\n          if (strictDeepEqual(first[key], second[key]) === false) {\n            return false;\n          }\n          keysSeen[key] = true;\n        }\n      }\n      // Now check that there aren\'t any keys in second that weren\'t\n      // in first.\n      for (var key2 in second) {\n        if (hasOwnProperty.call(second, key2)) {\n          if (keysSeen[key2] !== true) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  function isFalse(obj) {\n    // From the spec:\n    // A false value corresponds to the following values:\n    // Empty list\n    // Empty object\n    // Empty string\n    // False boolean\n    // null value\n\n    // First check the scalar values.\n    if (obj === "" || obj === false || obj === null) {\n        return true;\n    } else if (isArray(obj) && obj.length === 0) {\n        // Check for an empty array.\n        return true;\n    } else if (isObject(obj)) {\n        // Check for an empty object.\n        for (var key in obj) {\n            // If there are any keys, then\n            // the object is not empty so the object\n            // is not false.\n            if (obj.hasOwnProperty(key)) {\n              return false;\n            }\n        }\n        return true;\n    } else {\n        return false;\n    }\n  }\n\n  function objValues(obj) {\n    var keys = Object.keys(obj);\n    var values = [];\n    for (var i = 0; i < keys.length; i++) {\n      values.push(obj[keys[i]]);\n    }\n    return values;\n  }\n\n  function merge(a, b) {\n      var merged = {};\n      for (var key in a) {\n          merged[key] = a[key];\n      }\n      for (var key2 in b) {\n          merged[key2] = b[key2];\n      }\n      return merged;\n  }\n\n  var trimLeft;\n  if (typeof String.prototype.trimLeft === "function") {\n    trimLeft = function(str) {\n      return str.trimLeft();\n    };\n  } else {\n    trimLeft = function(str) {\n      return str.match(/^\\s*(.*)/)[1];\n    };\n  }\n\n  // Type constants used to define functions.\n  var TYPE_NUMBER = 0;\n  var TYPE_ANY = 1;\n  var TYPE_STRING = 2;\n  var TYPE_ARRAY = 3;\n  var TYPE_OBJECT = 4;\n  var TYPE_BOOLEAN = 5;\n  var TYPE_EXPREF = 6;\n  var TYPE_NULL = 7;\n  var TYPE_ARRAY_NUMBER = 8;\n  var TYPE_ARRAY_STRING = 9;\n  var TYPE_NAME_TABLE = {\n    0: \'number\',\n    1: \'any\',\n    2: \'string\',\n    3: \'array\',\n    4: \'object\',\n    5: \'boolean\',\n    6: \'expression\',\n    7: \'null\',\n    8: \'Array<number>\',\n    9: \'Array<string>\'\n  };\n\n  var TOK_EOF = "EOF";\n  var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";\n  var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";\n  var TOK_RBRACKET = "Rbracket";\n  var TOK_RPAREN = "Rparen";\n  var TOK_COMMA = "Comma";\n  var TOK_COLON = "Colon";\n  var TOK_RBRACE = "Rbrace";\n  var TOK_NUMBER = "Number";\n  var TOK_CURRENT = "Current";\n  var TOK_EXPREF = "Expref";\n  var TOK_PIPE = "Pipe";\n  var TOK_OR = "Or";\n  var TOK_AND = "And";\n  var TOK_EQ = "EQ";\n  var TOK_GT = "GT";\n  var TOK_LT = "LT";\n  var TOK_GTE = "GTE";\n  var TOK_LTE = "LTE";\n  var TOK_NE = "NE";\n  var TOK_FLATTEN = "Flatten";\n  var TOK_STAR = "Star";\n  var TOK_FILTER = "Filter";\n  var TOK_DOT = "Dot";\n  var TOK_NOT = "Not";\n  var TOK_LBRACE = "Lbrace";\n  var TOK_LBRACKET = "Lbracket";\n  var TOK_LPAREN= "Lparen";\n  var TOK_LITERAL= "Literal";\n\n  // The "&", "[", "<", ">" tokens\n  // are not in basicToken because\n  // there are two token variants\n  // ("&&", "[?", "<=", ">=").  This is specially handled\n  // below.\n\n  var basicTokens = {\n    ".": TOK_DOT,\n    "*": TOK_STAR,\n    ",": TOK_COMMA,\n    ":": TOK_COLON,\n    "{": TOK_LBRACE,\n    "}": TOK_RBRACE,\n    "]": TOK_RBRACKET,\n    "(": TOK_LPAREN,\n    ")": TOK_RPAREN,\n    "@": TOK_CURRENT\n  };\n\n  var operatorStartToken = {\n      "<": true,\n      ">": true,\n      "=": true,\n      "!": true\n  };\n\n  var skipChars = {\n      " ": true,\n      "\\t": true,\n      "\\n": true\n  };\n\n\n  function isAlpha(ch) {\n      return (ch >= "a" && ch <= "z") ||\n             (ch >= "A" && ch <= "Z") ||\n             ch === "_";\n  }\n\n  function isNum(ch) {\n      return (ch >= "0" && ch <= "9") ||\n             ch === "-";\n  }\n  function isAlphaNum(ch) {\n      return (ch >= "a" && ch <= "z") ||\n             (ch >= "A" && ch <= "Z") ||\n             (ch >= "0" && ch <= "9") ||\n             ch === "_";\n  }\n\n  function Lexer() {\n  }\n  Lexer.prototype = {\n      tokenize: function(stream) {\n          var tokens = [];\n          this._current = 0;\n          var start;\n          var identifier;\n          var token;\n          while (this._current < stream.length) {\n              if (isAlpha(stream[this._current])) {\n                  start = this._current;\n                  identifier = this._consumeUnquotedIdentifier(stream);\n                  tokens.push({type: TOK_UNQUOTEDIDENTIFIER,\n                               value: identifier,\n                               start: start});\n              } else if (basicTokens[stream[this._current]] !== undefined) {\n                  tokens.push({type: basicTokens[stream[this._current]],\n                              value: stream[this._current],\n                              start: this._current});\n                  this._current++;\n              } else if (isNum(stream[this._current])) {\n                  token = this._consumeNumber(stream);\n                  tokens.push(token);\n              } else if (stream[this._current] === "[") {\n                  // No need to increment this._current.  This happens\n                  // in _consumeLBracket\n                  token = this._consumeLBracket(stream);\n                  tokens.push(token);\n              } else if (stream[this._current] === "\\"") {\n                  start = this._current;\n                  identifier = this._consumeQuotedIdentifier(stream);\n                  tokens.push({type: TOK_QUOTEDIDENTIFIER,\n                               value: identifier,\n                               start: start});\n              } else if (stream[this._current] === "\'") {\n                  start = this._current;\n                  identifier = this._consumeRawStringLiteral(stream);\n                  tokens.push({type: TOK_LITERAL,\n                               value: identifier,\n                               start: start});\n              } else if (stream[this._current] === "`") {\n                  start = this._current;\n                  var literal = this._consumeLiteral(stream);\n                  tokens.push({type: TOK_LITERAL,\n                               value: literal,\n                               start: start});\n              } else if (operatorStartToken[stream[this._current]] !== undefined) {\n                  tokens.push(this._consumeOperator(stream));\n              } else if (skipChars[stream[this._current]] !== undefined) {\n                  // Ignore whitespace.\n                  this._current++;\n              } else if (stream[this._current] === "&") {\n                  start = this._current;\n                  this._current++;\n                  if (stream[this._current] === "&") {\n                      this._current++;\n                      tokens.push({type: TOK_AND, value: "&&", start: start});\n                  } else {\n                      tokens.push({type: TOK_EXPREF, value: "&", start: start});\n                  }\n              } else if (stream[this._current] === "|") {\n                  start = this._current;\n                  this._current++;\n                  if (stream[this._current] === "|") {\n                      this._current++;\n                      tokens.push({type: TOK_OR, value: "||", start: start});\n                  } else {\n                      tokens.push({type: TOK_PIPE, value: "|", start: start});\n                  }\n              } else {\n                  var error = new Error("Unknown character:" + stream[this._current]);\n                  error.name = "LexerError";\n                  throw error;\n              }\n          }\n          return tokens;\n      },\n\n      _consumeUnquotedIdentifier: function(stream) {\n          var start = this._current;\n          this._current++;\n          while (this._current < stream.length && isAlphaNum(stream[this._current])) {\n              this._current++;\n          }\n          return stream.slice(start, this._current);\n      },\n\n      _consumeQuotedIdentifier: function(stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n          while (stream[this._current] !== "\\"" && this._current < maxLength) {\n              // You can escape a double quote and you can escape an escape.\n              var current = this._current;\n              if (stream[current] === "\\\\" && (stream[current + 1] === "\\\\" ||\n                                               stream[current + 1] === "\\"")) {\n                  current += 2;\n              } else {\n                  current++;\n              }\n              this._current = current;\n          }\n          this._current++;\n          return JSON.parse(stream.slice(start, this._current));\n      },\n\n      _consumeRawStringLiteral: function(stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n          while (stream[this._current] !== "\'" && this._current < maxLength) {\n              // You can escape a single quote and you can escape an escape.\n              var current = this._current;\n              if (stream[current] === "\\\\" && (stream[current + 1] === "\\\\" ||\n                                               stream[current + 1] === "\'")) {\n                  current += 2;\n              } else {\n                  current++;\n              }\n              this._current = current;\n          }\n          this._current++;\n          var literal = stream.slice(start + 1, this._current - 1);\n          return literal.replace("\\\\\'", "\'");\n      },\n\n      _consumeNumber: function(stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n          while (isNum(stream[this._current]) && this._current < maxLength) {\n              this._current++;\n          }\n          var value = parseInt(stream.slice(start, this._current));\n          return {type: TOK_NUMBER, value: value, start: start};\n      },\n\n      _consumeLBracket: function(stream) {\n          var start = this._current;\n          this._current++;\n          if (stream[this._current] === "?") {\n              this._current++;\n              return {type: TOK_FILTER, value: "[?", start: start};\n          } else if (stream[this._current] === "]") {\n              this._current++;\n              return {type: TOK_FLATTEN, value: "[]", start: start};\n          } else {\n              return {type: TOK_LBRACKET, value: "[", start: start};\n          }\n      },\n\n      _consumeOperator: function(stream) {\n          var start = this._current;\n          var startingChar = stream[start];\n          this._current++;\n          if (startingChar === "!") {\n              if (stream[this._current] === "=") {\n                  this._current++;\n                  return {type: TOK_NE, value: "!=", start: start};\n              } else {\n                return {type: TOK_NOT, value: "!", start: start};\n              }\n          } else if (startingChar === "<") {\n              if (stream[this._current] === "=") {\n                  this._current++;\n                  return {type: TOK_LTE, value: "<=", start: start};\n              } else {\n                  return {type: TOK_LT, value: "<", start: start};\n              }\n          } else if (startingChar === ">") {\n              if (stream[this._current] === "=") {\n                  this._current++;\n                  return {type: TOK_GTE, value: ">=", start: start};\n              } else {\n                  return {type: TOK_GT, value: ">", start: start};\n              }\n          } else if (startingChar === "=") {\n              if (stream[this._current] === "=") {\n                  this._current++;\n                  return {type: TOK_EQ, value: "==", start: start};\n              }\n          }\n      },\n\n      _consumeLiteral: function(stream) {\n          this._current++;\n          var start = this._current;\n          var maxLength = stream.length;\n          var literal;\n          while(stream[this._current] !== "`" && this._current < maxLength) {\n              // You can escape a literal char or you can escape the escape.\n              var current = this._current;\n              if (stream[current] === "\\\\" && (stream[current + 1] === "\\\\" ||\n                                               stream[current + 1] === "`")) {\n                  current += 2;\n              } else {\n                  current++;\n              }\n              this._current = current;\n          }\n          var literalString = trimLeft(stream.slice(start, this._current));\n          literalString = literalString.replace("\\\\`", "`");\n          if (this._looksLikeJSON(literalString)) {\n              literal = JSON.parse(literalString);\n          } else {\n              // Try to JSON parse it as "<literal>"\n              literal = JSON.parse("\\"" + literalString + "\\"");\n          }\n          // +1 gets us to the ending "`", +1 to move on to the next char.\n          this._current++;\n          return literal;\n      },\n\n      _looksLikeJSON: function(literalString) {\n          var startingChars = "[{\\"";\n          var jsonLiterals = ["true", "false", "null"];\n          var numberLooking = "-0123456789";\n\n          if (literalString === "") {\n              return false;\n          } else if (startingChars.indexOf(literalString[0]) >= 0) {\n              return true;\n          } else if (jsonLiterals.indexOf(literalString) >= 0) {\n              return true;\n          } else if (numberLooking.indexOf(literalString[0]) >= 0) {\n              try {\n                  JSON.parse(literalString);\n                  return true;\n              } catch (ex) {\n                  return false;\n              }\n          } else {\n              return false;\n          }\n      }\n  };\n\n      var bindingPower = {};\n      bindingPower[TOK_EOF] = 0;\n      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;\n      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;\n      bindingPower[TOK_RBRACKET] = 0;\n      bindingPower[TOK_RPAREN] = 0;\n      bindingPower[TOK_COMMA] = 0;\n      bindingPower[TOK_RBRACE] = 0;\n      bindingPower[TOK_NUMBER] = 0;\n      bindingPower[TOK_CURRENT] = 0;\n      bindingPower[TOK_EXPREF] = 0;\n      bindingPower[TOK_PIPE] = 1;\n      bindingPower[TOK_OR] = 2;\n      bindingPower[TOK_AND] = 3;\n      bindingPower[TOK_EQ] = 5;\n      bindingPower[TOK_GT] = 5;\n      bindingPower[TOK_LT] = 5;\n      bindingPower[TOK_GTE] = 5;\n      bindingPower[TOK_LTE] = 5;\n      bindingPower[TOK_NE] = 5;\n      bindingPower[TOK_FLATTEN] = 9;\n      bindingPower[TOK_STAR] = 20;\n      bindingPower[TOK_FILTER] = 21;\n      bindingPower[TOK_DOT] = 40;\n      bindingPower[TOK_NOT] = 45;\n      bindingPower[TOK_LBRACE] = 50;\n      bindingPower[TOK_LBRACKET] = 55;\n      bindingPower[TOK_LPAREN] = 60;\n\n  function Parser() {\n  }\n\n  Parser.prototype = {\n      parse: function(expression) {\n          this._loadTokens(expression);\n          this.index = 0;\n          var ast = this.expression(0);\n          if (this._lookahead(0) !== TOK_EOF) {\n              var t = this._lookaheadToken(0);\n              var error = new Error(\n                  "Unexpected token type: " + t.type + ", value: " + t.value);\n              error.name = "ParserError";\n              throw error;\n          }\n          return ast;\n      },\n\n      _loadTokens: function(expression) {\n          var lexer = new Lexer();\n          var tokens = lexer.tokenize(expression);\n          tokens.push({type: TOK_EOF, value: "", start: expression.length});\n          this.tokens = tokens;\n      },\n\n      expression: function(rbp) {\n          var leftToken = this._lookaheadToken(0);\n          this._advance();\n          var left = this.nud(leftToken);\n          var currentToken = this._lookahead(0);\n          while (rbp < bindingPower[currentToken]) {\n              this._advance();\n              left = this.led(currentToken, left);\n              currentToken = this._lookahead(0);\n          }\n          return left;\n      },\n\n      _lookahead: function(number) {\n          return this.tokens[this.index + number].type;\n      },\n\n      _lookaheadToken: function(number) {\n          return this.tokens[this.index + number];\n      },\n\n      _advance: function() {\n          this.index++;\n      },\n\n      nud: function(token) {\n        var left;\n        var right;\n        var expression;\n        switch (token.type) {\n          case TOK_LITERAL:\n            return {type: "Literal", value: token.value};\n          case TOK_UNQUOTEDIDENTIFIER:\n            return {type: "Field", name: token.value};\n          case TOK_QUOTEDIDENTIFIER:\n            var node = {type: "Field", name: token.value};\n            if (this._lookahead(0) === TOK_LPAREN) {\n                throw new Error("Quoted identifier not allowed for function names.");\n            }\n            return node;\n          case TOK_NOT:\n            right = this.expression(bindingPower.Not);\n            return {type: "NotExpression", children: [right]};\n          case TOK_STAR:\n            left = {type: "Identity"};\n            right = null;\n            if (this._lookahead(0) === TOK_RBRACKET) {\n                // This can happen in a multiselect,\n                // [a, b, *]\n                right = {type: "Identity"};\n            } else {\n                right = this._parseProjectionRHS(bindingPower.Star);\n            }\n            return {type: "ValueProjection", children: [left, right]};\n          case TOK_FILTER:\n            return this.led(token.type, {type: "Identity"});\n          case TOK_LBRACE:\n            return this._parseMultiselectHash();\n          case TOK_FLATTEN:\n            left = {type: TOK_FLATTEN, children: [{type: "Identity"}]};\n            right = this._parseProjectionRHS(bindingPower.Flatten);\n            return {type: "Projection", children: [left, right]};\n          case TOK_LBRACKET:\n            if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {\n                right = this._parseIndexExpression();\n                return this._projectIfSlice({type: "Identity"}, right);\n            } else if (this._lookahead(0) === TOK_STAR &&\n                       this._lookahead(1) === TOK_RBRACKET) {\n                this._advance();\n                this._advance();\n                right = this._parseProjectionRHS(bindingPower.Star);\n                return {type: "Projection",\n                        children: [{type: "Identity"}, right]};\n            }\n            return this._parseMultiselectList();\n          case TOK_CURRENT:\n            return {type: TOK_CURRENT};\n          case TOK_EXPREF:\n            expression = this.expression(bindingPower.Expref);\n            return {type: "ExpressionReference", children: [expression]};\n          case TOK_LPAREN:\n            var args = [];\n            while (this._lookahead(0) !== TOK_RPAREN) {\n              if (this._lookahead(0) === TOK_CURRENT) {\n                expression = {type: TOK_CURRENT};\n                this._advance();\n              } else {\n                expression = this.expression(0);\n              }\n              args.push(expression);\n            }\n            this._match(TOK_RPAREN);\n            return args[0];\n          default:\n            this._errorToken(token);\n        }\n      },\n\n      led: function(tokenName, left) {\n        var right;\n        switch(tokenName) {\n          case TOK_DOT:\n            var rbp = bindingPower.Dot;\n            if (this._lookahead(0) !== TOK_STAR) {\n                right = this._parseDotRHS(rbp);\n                return {type: "Subexpression", children: [left, right]};\n            }\n            // Creating a projection.\n            this._advance();\n            right = this._parseProjectionRHS(rbp);\n            return {type: "ValueProjection", children: [left, right]};\n          case TOK_PIPE:\n            right = this.expression(bindingPower.Pipe);\n            return {type: TOK_PIPE, children: [left, right]};\n          case TOK_OR:\n            right = this.expression(bindingPower.Or);\n            return {type: "OrExpression", children: [left, right]};\n          case TOK_AND:\n            right = this.expression(bindingPower.And);\n            return {type: "AndExpression", children: [left, right]};\n          case TOK_LPAREN:\n            var name = left.name;\n            var args = [];\n            var expression, node;\n            while (this._lookahead(0) !== TOK_RPAREN) {\n              if (this._lookahead(0) === TOK_CURRENT) {\n                expression = {type: TOK_CURRENT};\n                this._advance();\n              } else {\n                expression = this.expression(0);\n              }\n              if (this._lookahead(0) === TOK_COMMA) {\n                this._match(TOK_COMMA);\n              }\n              args.push(expression);\n            }\n            this._match(TOK_RPAREN);\n            node = {type: "Function", name: name, children: args};\n            return node;\n          case TOK_FILTER:\n            var condition = this.expression(0);\n            this._match(TOK_RBRACKET);\n            if (this._lookahead(0) === TOK_FLATTEN) {\n              right = {type: "Identity"};\n            } else {\n              right = this._parseProjectionRHS(bindingPower.Filter);\n            }\n            return {type: "FilterProjection", children: [left, right, condition]};\n          case TOK_FLATTEN:\n            var leftNode = {type: TOK_FLATTEN, children: [left]};\n            var rightNode = this._parseProjectionRHS(bindingPower.Flatten);\n            return {type: "Projection", children: [leftNode, rightNode]};\n          case TOK_EQ:\n          case TOK_NE:\n          case TOK_GT:\n          case TOK_GTE:\n          case TOK_LT:\n          case TOK_LTE:\n            return this._parseComparator(left, tokenName);\n          case TOK_LBRACKET:\n            var token = this._lookaheadToken(0);\n            if (token.type === TOK_NUMBER || token.type === TOK_COLON) {\n                right = this._parseIndexExpression();\n                return this._projectIfSlice(left, right);\n            }\n            this._match(TOK_STAR);\n            this._match(TOK_RBRACKET);\n            right = this._parseProjectionRHS(bindingPower.Star);\n            return {type: "Projection", children: [left, right]};\n          default:\n            this._errorToken(this._lookaheadToken(0));\n        }\n      },\n\n      _match: function(tokenType) {\n          if (this._lookahead(0) === tokenType) {\n              this._advance();\n          } else {\n              var t = this._lookaheadToken(0);\n              var error = new Error("Expected " + tokenType + ", got: " + t.type);\n              error.name = "ParserError";\n              throw error;\n          }\n      },\n\n      _errorToken: function(token) {\n          var error = new Error("Invalid token (" +\n                                token.type + "): \\"" +\n                                token.value + "\\"");\n          error.name = "ParserError";\n          throw error;\n      },\n\n\n      _parseIndexExpression: function() {\n          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {\n              return this._parseSliceExpression();\n          } else {\n              var node = {\n                  type: "Index",\n                  value: this._lookaheadToken(0).value};\n              this._advance();\n              this._match(TOK_RBRACKET);\n              return node;\n          }\n      },\n\n      _projectIfSlice: function(left, right) {\n          var indexExpr = {type: "IndexExpression", children: [left, right]};\n          if (right.type === "Slice") {\n              return {\n                  type: "Projection",\n                  children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]\n              };\n          } else {\n              return indexExpr;\n          }\n      },\n\n      _parseSliceExpression: function() {\n          // [start:end:step] where each part is optional, as well as the last\n          // colon.\n          var parts = [null, null, null];\n          var index = 0;\n          var currentToken = this._lookahead(0);\n          while (currentToken !== TOK_RBRACKET && index < 3) {\n              if (currentToken === TOK_COLON) {\n                  index++;\n                  this._advance();\n              } else if (currentToken === TOK_NUMBER) {\n                  parts[index] = this._lookaheadToken(0).value;\n                  this._advance();\n              } else {\n                  var t = this._lookahead(0);\n                  var error = new Error("Syntax error, unexpected token: " +\n                                        t.value + "(" + t.type + ")");\n                  error.name = "Parsererror";\n                  throw error;\n              }\n              currentToken = this._lookahead(0);\n          }\n          this._match(TOK_RBRACKET);\n          return {\n              type: "Slice",\n              children: parts\n          };\n      },\n\n      _parseComparator: function(left, comparator) {\n        var right = this.expression(bindingPower[comparator]);\n        return {type: "Comparator", name: comparator, children: [left, right]};\n      },\n\n      _parseDotRHS: function(rbp) {\n          var lookahead = this._lookahead(0);\n          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];\n          if (exprTokens.indexOf(lookahead) >= 0) {\n              return this.expression(rbp);\n          } else if (lookahead === TOK_LBRACKET) {\n              this._match(TOK_LBRACKET);\n              return this._parseMultiselectList();\n          } else if (lookahead === TOK_LBRACE) {\n              this._match(TOK_LBRACE);\n              return this._parseMultiselectHash();\n          }\n      },\n\n      _parseProjectionRHS: function(rbp) {\n          var right;\n          if (bindingPower[this._lookahead(0)] < 10) {\n              right = {type: "Identity"};\n          } else if (this._lookahead(0) === TOK_LBRACKET) {\n              right = this.expression(rbp);\n          } else if (this._lookahead(0) === TOK_FILTER) {\n              right = this.expression(rbp);\n          } else if (this._lookahead(0) === TOK_DOT) {\n              this._match(TOK_DOT);\n              right = this._parseDotRHS(rbp);\n          } else {\n              var t = this._lookaheadToken(0);\n              var error = new Error("Sytanx error, unexpected token: " +\n                                    t.value + "(" + t.type + ")");\n              error.name = "ParserError";\n              throw error;\n          }\n          return right;\n      },\n\n      _parseMultiselectList: function() {\n          var expressions = [];\n          while (this._lookahead(0) !== TOK_RBRACKET) {\n              var expression = this.expression(0);\n              expressions.push(expression);\n              if (this._lookahead(0) === TOK_COMMA) {\n                  this._match(TOK_COMMA);\n                  if (this._lookahead(0) === TOK_RBRACKET) {\n                    throw new Error("Unexpected token Rbracket");\n                  }\n              }\n          }\n          this._match(TOK_RBRACKET);\n          return {type: "MultiSelectList", children: expressions};\n      },\n\n      _parseMultiselectHash: function() {\n        var pairs = [];\n        var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];\n        var keyToken, keyName, value, node;\n        for (;;) {\n          keyToken = this._lookaheadToken(0);\n          if (identifierTypes.indexOf(keyToken.type) < 0) {\n            throw new Error("Expecting an identifier token, got: " +\n                            keyToken.type);\n          }\n          keyName = keyToken.value;\n          this._advance();\n          this._match(TOK_COLON);\n          value = this.expression(0);\n          node = {type: "KeyValuePair", name: keyName, value: value};\n          pairs.push(node);\n          if (this._lookahead(0) === TOK_COMMA) {\n            this._match(TOK_COMMA);\n          } else if (this._lookahead(0) === TOK_RBRACE) {\n            this._match(TOK_RBRACE);\n            break;\n          }\n        }\n        return {type: "MultiSelectHash", children: pairs};\n      }\n  };\n\n\n  function TreeInterpreter(runtime) {\n    this.runtime = runtime;\n  }\n\n  TreeInterpreter.prototype = {\n      search: function(node, value) {\n          return this.visit(node, value);\n      },\n\n      visit: function(node, value) {\n          var matched, current, result, first, second, field, left, right, collected, i;\n          switch (node.type) {\n            case "Field":\n              if (value !== null && isObject(value)) {\n                  field = value[node.name];\n                  if (field === undefined) {\n                      return null;\n                  } else {\n                      return field;\n                  }\n              }\n              return null;\n            case "Subexpression":\n              result = this.visit(node.children[0], value);\n              for (i = 1; i < node.children.length; i++) {\n                  result = this.visit(node.children[1], result);\n                  if (result === null) {\n                      return null;\n                  }\n              }\n              return result;\n            case "IndexExpression":\n              left = this.visit(node.children[0], value);\n              right = this.visit(node.children[1], left);\n              return right;\n            case "Index":\n              if (!isArray(value)) {\n                return null;\n              }\n              var index = node.value;\n              if (index < 0) {\n                index = value.length + index;\n              }\n              result = value[index];\n              if (result === undefined) {\n                result = null;\n              }\n              return result;\n            case "Slice":\n              if (!isArray(value)) {\n                return null;\n              }\n              var sliceParams = node.children.slice(0);\n              var computed = this.computeSliceParams(value.length, sliceParams);\n              var start = computed[0];\n              var stop = computed[1];\n              var step = computed[2];\n              result = [];\n              if (step > 0) {\n                  for (i = start; i < stop; i += step) {\n                      result.push(value[i]);\n                  }\n              } else {\n                  for (i = start; i > stop; i += step) {\n                      result.push(value[i]);\n                  }\n              }\n              return result;\n            case "Projection":\n              // Evaluate left child.\n              var base = this.visit(node.children[0], value);\n              if (!isArray(base)) {\n                return null;\n              }\n              collected = [];\n              for (i = 0; i < base.length; i++) {\n                current = this.visit(node.children[1], base[i]);\n                if (current !== null) {\n                  collected.push(current);\n                }\n              }\n              return collected;\n            case "ValueProjection":\n              // Evaluate left child.\n              base = this.visit(node.children[0], value);\n              if (!isObject(base)) {\n                return null;\n              }\n              collected = [];\n              var values = objValues(base);\n              for (i = 0; i < values.length; i++) {\n                current = this.visit(node.children[1], values[i]);\n                if (current !== null) {\n                  collected.push(current);\n                }\n              }\n              return collected;\n            case "FilterProjection":\n              base = this.visit(node.children[0], value);\n              if (!isArray(base)) {\n                return null;\n              }\n              var filtered = [];\n              var finalResults = [];\n              for (i = 0; i < base.length; i++) {\n                matched = this.visit(node.children[2], base[i]);\n                if (!isFalse(matched)) {\n                  filtered.push(base[i]);\n                }\n              }\n              for (var j = 0; j < filtered.length; j++) {\n                current = this.visit(node.children[1], filtered[j]);\n                if (current !== null) {\n                  finalResults.push(current);\n                }\n              }\n              return finalResults;\n            case "Comparator":\n              first = this.visit(node.children[0], value);\n              second = this.visit(node.children[1], value);\n              switch(node.name) {\n                case TOK_EQ:\n                  result = strictDeepEqual(first, second);\n                  break;\n                case TOK_NE:\n                  result = !strictDeepEqual(first, second);\n                  break;\n                case TOK_GT:\n                  result = first > second;\n                  break;\n                case TOK_GTE:\n                  result = first >= second;\n                  break;\n                case TOK_LT:\n                  result = first < second;\n                  break;\n                case TOK_LTE:\n                  result = first <= second;\n                  break;\n                default:\n                  throw new Error("Unknown comparator: " + node.name);\n              }\n              return result;\n            case TOK_FLATTEN:\n              var original = this.visit(node.children[0], value);\n              if (!isArray(original)) {\n                return null;\n              }\n              var merged = [];\n              for (i = 0; i < original.length; i++) {\n                current = original[i];\n                if (isArray(current)) {\n                  merged.push.apply(merged, current);\n                } else {\n                  merged.push(current);\n                }\n              }\n              return merged;\n            case "Identity":\n              return value;\n            case "MultiSelectList":\n              if (value === null) {\n                return null;\n              }\n              collected = [];\n              for (i = 0; i < node.children.length; i++) {\n                  collected.push(this.visit(node.children[i], value));\n              }\n              return collected;\n            case "MultiSelectHash":\n              if (value === null) {\n                return null;\n              }\n              collected = {};\n              var child;\n              for (i = 0; i < node.children.length; i++) {\n                child = node.children[i];\n                collected[child.name] = this.visit(child.value, value);\n              }\n              return collected;\n            case "OrExpression":\n              matched = this.visit(node.children[0], value);\n              if (isFalse(matched)) {\n                  matched = this.visit(node.children[1], value);\n              }\n              return matched;\n            case "AndExpression":\n              first = this.visit(node.children[0], value);\n\n              if (isFalse(first) === true) {\n                return first;\n              }\n              return this.visit(node.children[1], value);\n            case "NotExpression":\n              first = this.visit(node.children[0], value);\n              return isFalse(first);\n            case "Literal":\n              return node.value;\n            case TOK_PIPE:\n              left = this.visit(node.children[0], value);\n              return this.visit(node.children[1], left);\n            case TOK_CURRENT:\n              return value;\n            case "Function":\n              var resolvedArgs = [];\n              for (i = 0; i < node.children.length; i++) {\n                  resolvedArgs.push(this.visit(node.children[i], value));\n              }\n              return this.runtime.callFunction(node.name, resolvedArgs);\n            case "ExpressionReference":\n              var refNode = node.children[0];\n              // Tag the node with a specific attribute so the type\n              // checker verify the type.\n              refNode.jmespathType = TOK_EXPREF;\n              return refNode;\n            default:\n              throw new Error("Unknown node type: " + node.type);\n          }\n      },\n\n      computeSliceParams: function(arrayLength, sliceParams) {\n        var start = sliceParams[0];\n        var stop = sliceParams[1];\n        var step = sliceParams[2];\n        var computed = [null, null, null];\n        if (step === null) {\n          step = 1;\n        } else if (step === 0) {\n          var error = new Error("Invalid slice, step cannot be 0");\n          error.name = "RuntimeError";\n          throw error;\n        }\n        var stepValueNegative = step < 0 ? true : false;\n\n        if (start === null) {\n            start = stepValueNegative ? arrayLength - 1 : 0;\n        } else {\n            start = this.capSliceRange(arrayLength, start, step);\n        }\n\n        if (stop === null) {\n            stop = stepValueNegative ? -1 : arrayLength;\n        } else {\n            stop = this.capSliceRange(arrayLength, stop, step);\n        }\n        computed[0] = start;\n        computed[1] = stop;\n        computed[2] = step;\n        return computed;\n      },\n\n      capSliceRange: function(arrayLength, actualValue, step) {\n          if (actualValue < 0) {\n              actualValue += arrayLength;\n              if (actualValue < 0) {\n                  actualValue = step < 0 ? -1 : 0;\n              }\n          } else if (actualValue >= arrayLength) {\n              actualValue = step < 0 ? arrayLength - 1 : arrayLength;\n          }\n          return actualValue;\n      }\n\n  };\n\n  function Runtime(interpreter) {\n    this._interpreter = interpreter;\n    this.functionTable = {\n        // name: [function, <signature>]\n        // The <signature> can be:\n        //\n        // {\n        //   args: [[type1, type2], [type1, type2]],\n        //   variadic: true|false\n        // }\n        //\n        // Each arg in the arg list is a list of valid types\n        // (if the function is overloaded and supports multiple\n        // types.  If the type is "any" then no type checking\n        // occurs on the argument.  Variadic is optional\n        // and if not provided is assumed to be false.\n        abs: {_func: this._functionAbs, _signature: [{types: [TYPE_NUMBER]}]},\n        avg: {_func: this._functionAvg, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},\n        ceil: {_func: this._functionCeil, _signature: [{types: [TYPE_NUMBER]}]},\n        contains: {\n            _func: this._functionContains,\n            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]},\n                        {types: [TYPE_ANY]}]},\n        "ends_with": {\n            _func: this._functionEndsWith,\n            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},\n        floor: {_func: this._functionFloor, _signature: [{types: [TYPE_NUMBER]}]},\n        length: {\n            _func: this._functionLength,\n            _signature: [{types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},\n        map: {\n            _func: this._functionMap,\n            _signature: [{types: [TYPE_EXPREF]}, {types: [TYPE_ARRAY]}]},\n        max: {\n            _func: this._functionMax,\n            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},\n        "merge": {\n            _func: this._functionMerge,\n            _signature: [{types: [TYPE_OBJECT], variadic: true}]\n        },\n        "max_by": {\n          _func: this._functionMaxBy,\n          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]\n        },\n        sum: {_func: this._functionSum, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},\n        "starts_with": {\n            _func: this._functionStartsWith,\n            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},\n        min: {\n            _func: this._functionMin,\n            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},\n        "min_by": {\n          _func: this._functionMinBy,\n          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]\n        },\n        type: {_func: this._functionType, _signature: [{types: [TYPE_ANY]}]},\n        keys: {_func: this._functionKeys, _signature: [{types: [TYPE_OBJECT]}]},\n        values: {_func: this._functionValues, _signature: [{types: [TYPE_OBJECT]}]},\n        sort: {_func: this._functionSort, _signature: [{types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},\n        "sort_by": {\n          _func: this._functionSortBy,\n          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]\n        },\n        join: {\n            _func: this._functionJoin,\n            _signature: [\n                {types: [TYPE_STRING]},\n                {types: [TYPE_ARRAY_STRING]}\n            ]\n        },\n        reverse: {\n            _func: this._functionReverse,\n            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]}]},\n        "to_array": {_func: this._functionToArray, _signature: [{types: [TYPE_ANY]}]},\n        "to_string": {_func: this._functionToString, _signature: [{types: [TYPE_ANY]}]},\n        "to_number": {_func: this._functionToNumber, _signature: [{types: [TYPE_ANY]}]},\n        "not_null": {\n            _func: this._functionNotNull,\n            _signature: [{types: [TYPE_ANY], variadic: true}]\n        }\n    };\n  }\n\n  Runtime.prototype = {\n    callFunction: function(name, resolvedArgs) {\n      var functionEntry = this.functionTable[name];\n      if (functionEntry === undefined) {\n          throw new Error("Unknown function: " + name + "()");\n      }\n      this._validateArgs(name, resolvedArgs, functionEntry._signature);\n      return functionEntry._func.call(this, resolvedArgs);\n    },\n\n    _validateArgs: function(name, args, signature) {\n        // Validating the args requires validating\n        // the correct arity and the correct type of each arg.\n        // If the last argument is declared as variadic, then we need\n        // a minimum number of args to be required.  Otherwise it has to\n        // be an exact amount.\n        var pluralized;\n        if (signature[signature.length - 1].variadic) {\n            if (args.length < signature.length) {\n                pluralized = signature.length === 1 ? " argument" : " arguments";\n                throw new Error("ArgumentError: " + name + "() " +\n                                "takes at least" + signature.length + pluralized +\n                                " but received " + args.length);\n            }\n        } else if (args.length !== signature.length) {\n            pluralized = signature.length === 1 ? " argument" : " arguments";\n            throw new Error("ArgumentError: " + name + "() " +\n                            "takes " + signature.length + pluralized +\n                            " but received " + args.length);\n        }\n        var currentSpec;\n        var actualType;\n        var typeMatched;\n        for (var i = 0; i < signature.length; i++) {\n            typeMatched = false;\n            currentSpec = signature[i].types;\n            actualType = this._getTypeName(args[i]);\n            for (var j = 0; j < currentSpec.length; j++) {\n                if (this._typeMatches(actualType, currentSpec[j], args[i])) {\n                    typeMatched = true;\n                    break;\n                }\n            }\n            if (!typeMatched) {\n                var expected = currentSpec\n                    .map(function(typeIdentifier) {\n                        return TYPE_NAME_TABLE[typeIdentifier];\n                    })\n                    .join(\',\');\n                throw new Error("TypeError: " + name + "() " +\n                                "expected argument " + (i + 1) +\n                                " to be type " + expected +\n                                " but received type " +\n                                TYPE_NAME_TABLE[actualType] + " instead.");\n            }\n        }\n    },\n\n    _typeMatches: function(actual, expected, argValue) {\n        if (expected === TYPE_ANY) {\n            return true;\n        }\n        if (expected === TYPE_ARRAY_STRING ||\n            expected === TYPE_ARRAY_NUMBER ||\n            expected === TYPE_ARRAY) {\n            // The expected type can either just be array,\n            // or it can require a specific subtype (array of numbers).\n            //\n            // The simplest case is if "array" with no subtype is specified.\n            if (expected === TYPE_ARRAY) {\n                return actual === TYPE_ARRAY;\n            } else if (actual === TYPE_ARRAY) {\n                // Otherwise we need to check subtypes.\n                // I think this has potential to be improved.\n                var subtype;\n                if (expected === TYPE_ARRAY_NUMBER) {\n                  subtype = TYPE_NUMBER;\n                } else if (expected === TYPE_ARRAY_STRING) {\n                  subtype = TYPE_STRING;\n                }\n                for (var i = 0; i < argValue.length; i++) {\n                    if (!this._typeMatches(\n                            this._getTypeName(argValue[i]), subtype,\n                                             argValue[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        } else {\n            return actual === expected;\n        }\n    },\n    _getTypeName: function(obj) {\n        switch (Object.prototype.toString.call(obj)) {\n            case "[object String]":\n              return TYPE_STRING;\n            case "[object Number]":\n              return TYPE_NUMBER;\n            case "[object Array]":\n              return TYPE_ARRAY;\n            case "[object Boolean]":\n              return TYPE_BOOLEAN;\n            case "[object Null]":\n              return TYPE_NULL;\n            case "[object Object]":\n              // Check if it\'s an expref.  If it has, it\'s been\n              // tagged with a jmespathType attr of \'Expref\';\n              if (obj.jmespathType === TOK_EXPREF) {\n                return TYPE_EXPREF;\n              } else {\n                return TYPE_OBJECT;\n              }\n        }\n    },\n\n    _functionStartsWith: function(resolvedArgs) {\n        return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;\n    },\n\n    _functionEndsWith: function(resolvedArgs) {\n        var searchStr = resolvedArgs[0];\n        var suffix = resolvedArgs[1];\n        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;\n    },\n\n    _functionReverse: function(resolvedArgs) {\n        var typeName = this._getTypeName(resolvedArgs[0]);\n        if (typeName === TYPE_STRING) {\n          var originalStr = resolvedArgs[0];\n          var reversedStr = "";\n          for (var i = originalStr.length - 1; i >= 0; i--) {\n              reversedStr += originalStr[i];\n          }\n          return reversedStr;\n        } else {\n          var reversedArray = resolvedArgs[0].slice(0);\n          reversedArray.reverse();\n          return reversedArray;\n        }\n    },\n\n    _functionAbs: function(resolvedArgs) {\n      return Math.abs(resolvedArgs[0]);\n    },\n\n    _functionCeil: function(resolvedArgs) {\n        return Math.ceil(resolvedArgs[0]);\n    },\n\n    _functionAvg: function(resolvedArgs) {\n        var sum = 0;\n        var inputArray = resolvedArgs[0];\n        for (var i = 0; i < inputArray.length; i++) {\n            sum += inputArray[i];\n        }\n        return sum / inputArray.length;\n    },\n\n    _functionContains: function(resolvedArgs) {\n        return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;\n    },\n\n    _functionFloor: function(resolvedArgs) {\n        return Math.floor(resolvedArgs[0]);\n    },\n\n    _functionLength: function(resolvedArgs) {\n       if (!isObject(resolvedArgs[0])) {\n         return resolvedArgs[0].length;\n       } else {\n         // As far as I can tell, there\'s no way to get the length\n         // of an object without O(n) iteration through the object.\n         return Object.keys(resolvedArgs[0]).length;\n       }\n    },\n\n    _functionMap: function(resolvedArgs) {\n      var mapped = [];\n      var interpreter = this._interpreter;\n      var exprefNode = resolvedArgs[0];\n      var elements = resolvedArgs[1];\n      for (var i = 0; i < elements.length; i++) {\n          mapped.push(interpreter.visit(exprefNode, elements[i]));\n      }\n      return mapped;\n    },\n\n    _functionMerge: function(resolvedArgs) {\n      var merged = {};\n      for (var i = 0; i < resolvedArgs.length; i++) {\n        var current = resolvedArgs[i];\n        for (var key in current) {\n          merged[key] = current[key];\n        }\n      }\n      return merged;\n    },\n\n    _functionMax: function(resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n        if (typeName === TYPE_NUMBER) {\n          return Math.max.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var maxElement = elements[0];\n          for (var i = 1; i < elements.length; i++) {\n              if (maxElement.localeCompare(elements[i]) < 0) {\n                  maxElement = elements[i];\n              }\n          }\n          return maxElement;\n        }\n      } else {\n          return null;\n      }\n    },\n\n    _functionMin: function(resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n        if (typeName === TYPE_NUMBER) {\n          return Math.min.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var minElement = elements[0];\n          for (var i = 1; i < elements.length; i++) {\n              if (elements[i].localeCompare(minElement) < 0) {\n                  minElement = elements[i];\n              }\n          }\n          return minElement;\n        }\n      } else {\n        return null;\n      }\n    },\n\n    _functionSum: function(resolvedArgs) {\n      var sum = 0;\n      var listToSum = resolvedArgs[0];\n      for (var i = 0; i < listToSum.length; i++) {\n        sum += listToSum[i];\n      }\n      return sum;\n    },\n\n    _functionType: function(resolvedArgs) {\n        switch (this._getTypeName(resolvedArgs[0])) {\n          case TYPE_NUMBER:\n            return "number";\n          case TYPE_STRING:\n            return "string";\n          case TYPE_ARRAY:\n            return "array";\n          case TYPE_OBJECT:\n            return "object";\n          case TYPE_BOOLEAN:\n            return "boolean";\n          case TYPE_EXPREF:\n            return "expref";\n          case TYPE_NULL:\n            return "null";\n        }\n    },\n\n    _functionKeys: function(resolvedArgs) {\n        return Object.keys(resolvedArgs[0]);\n    },\n\n    _functionValues: function(resolvedArgs) {\n        var obj = resolvedArgs[0];\n        var keys = Object.keys(obj);\n        var values = [];\n        for (var i = 0; i < keys.length; i++) {\n            values.push(obj[keys[i]]);\n        }\n        return values;\n    },\n\n    _functionJoin: function(resolvedArgs) {\n        var joinChar = resolvedArgs[0];\n        var listJoin = resolvedArgs[1];\n        return listJoin.join(joinChar);\n    },\n\n    _functionToArray: function(resolvedArgs) {\n        if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {\n            return resolvedArgs[0];\n        } else {\n            return [resolvedArgs[0]];\n        }\n    },\n\n    _functionToString: function(resolvedArgs) {\n        if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {\n            return resolvedArgs[0];\n        } else {\n            return JSON.stringify(resolvedArgs[0]);\n        }\n    },\n\n    _functionToNumber: function(resolvedArgs) {\n        var typeName = this._getTypeName(resolvedArgs[0]);\n        var convertedValue;\n        if (typeName === TYPE_NUMBER) {\n            return resolvedArgs[0];\n        } else if (typeName === TYPE_STRING) {\n            convertedValue = +resolvedArgs[0];\n            if (!isNaN(convertedValue)) {\n                return convertedValue;\n            }\n        }\n        return null;\n    },\n\n    _functionNotNull: function(resolvedArgs) {\n        for (var i = 0; i < resolvedArgs.length; i++) {\n            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {\n                return resolvedArgs[i];\n            }\n        }\n        return null;\n    },\n\n    _functionSort: function(resolvedArgs) {\n        var sortedArray = resolvedArgs[0].slice(0);\n        sortedArray.sort();\n        return sortedArray;\n    },\n\n    _functionSortBy: function(resolvedArgs) {\n        var sortedArray = resolvedArgs[0].slice(0);\n        if (sortedArray.length === 0) {\n            return sortedArray;\n        }\n        var interpreter = this._interpreter;\n        var exprefNode = resolvedArgs[1];\n        var requiredType = this._getTypeName(\n            interpreter.visit(exprefNode, sortedArray[0]));\n        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {\n            throw new Error("TypeError");\n        }\n        var that = this;\n        // In order to get a stable sort out of an unstable\n        // sort algorithm, we decorate/sort/undecorate (DSU)\n        // by creating a new list of [index, element] pairs.\n        // In the cmp function, if the evaluated elements are\n        // equal, then the index will be used as the tiebreaker.\n        // After the decorated list has been sorted, it will be\n        // undecorated to extract the original elements.\n        var decorated = [];\n        for (var i = 0; i < sortedArray.length; i++) {\n          decorated.push([i, sortedArray[i]]);\n        }\n        decorated.sort(function(a, b) {\n          var exprA = interpreter.visit(exprefNode, a[1]);\n          var exprB = interpreter.visit(exprefNode, b[1]);\n          if (that._getTypeName(exprA) !== requiredType) {\n              throw new Error(\n                  "TypeError: expected " + requiredType + ", received " +\n                  that._getTypeName(exprA));\n          } else if (that._getTypeName(exprB) !== requiredType) {\n              throw new Error(\n                  "TypeError: expected " + requiredType + ", received " +\n                  that._getTypeName(exprB));\n          }\n          if (exprA > exprB) {\n            return 1;\n          } else if (exprA < exprB) {\n            return -1;\n          } else {\n            // If they\'re equal compare the items by their\n            // order to maintain relative order of equal keys\n            // (i.e. to get a stable sort).\n            return a[0] - b[0];\n          }\n        });\n        // Undecorate: extract out the original list elements.\n        for (var j = 0; j < decorated.length; j++) {\n          sortedArray[j] = decorated[j][1];\n        }\n        return sortedArray;\n    },\n\n    _functionMaxBy: function(resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var maxNumber = -Infinity;\n      var maxRecord;\n      var current;\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n        if (current > maxNumber) {\n          maxNumber = current;\n          maxRecord = resolvedArray[i];\n        }\n      }\n      return maxRecord;\n    },\n\n    _functionMinBy: function(resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var minNumber = Infinity;\n      var minRecord;\n      var current;\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n        if (current < minNumber) {\n          minNumber = current;\n          minRecord = resolvedArray[i];\n        }\n      }\n      return minRecord;\n    },\n\n    createKeyFunction: function(exprefNode, allowedTypes) {\n      var that = this;\n      var interpreter = this._interpreter;\n      var keyFunc = function(x) {\n        var current = interpreter.visit(exprefNode, x);\n        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {\n          var msg = "TypeError: expected one of " + allowedTypes +\n                    ", received " + that._getTypeName(current);\n          throw new Error(msg);\n        }\n        return current;\n      };\n      return keyFunc;\n    }\n\n  };\n\n  function compile(stream) {\n    var parser = new Parser();\n    var ast = parser.parse(stream);\n    return ast;\n  }\n\n  function tokenize(stream) {\n      var lexer = new Lexer();\n      return lexer.tokenize(stream);\n  }\n\n  function search(data, expression) {\n      var parser = new Parser();\n      // This needs to be improved.  Both the interpreter and runtime depend on\n      // each other.  The runtime needs the interpreter to support exprefs.\n      // There\'s likely a clean way to avoid the cyclic dependency.\n      var runtime = new Runtime();\n      var interpreter = new TreeInterpreter(runtime);\n      runtime._interpreter = interpreter;\n      var node = parser.parse(expression);\n      return interpreter.search(node, data);\n  }\n\n  exports.tokenize = tokenize;\n  exports.compile = compile;\n  exports.search = search;\n  exports.strictDeepEqual = strictDeepEqual;\n})( false ? 0 : exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ptZXNwYXRoQDAuMTYuMC9ub2RlX21vZHVsZXMvam1lc3BhdGgvam1lc3BhdGguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxNQUE4QixHQUFHLENBQWtCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWl0by1mb3Jtcy9idWxtYS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vam1lc3BhdGhAMC4xNi4wL25vZGVfbW9kdWxlcy9qbWVzcGF0aC9qbWVzcGF0aC5qcz9mNjQ4Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbihleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgaWYgKG9iaiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICBpZiAob2JqICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpY3REZWVwRXF1YWwoZmlyc3QsIHNlY29uZCkge1xuICAgIC8vIENoZWNrIHRoZSBzY2FsYXIgY2FzZSBmaXJzdC5cbiAgICBpZiAoZmlyc3QgPT09IHNlY29uZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhleSBhcmUgdGhlIHNhbWUgdHlwZS5cbiAgICB2YXIgZmlyc3RUeXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZpcnN0KTtcbiAgICBpZiAoZmlyc3RUeXBlICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc2Vjb25kKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBXZSBrbm93IHRoYXQgZmlyc3QgYW5kIHNlY29uZCBoYXZlIHRoZSBzYW1lIHR5cGUgc28gd2UgY2FuIGp1c3QgY2hlY2sgdGhlXG4gICAgLy8gZmlyc3QgdHlwZSBmcm9tIG5vdyBvbi5cbiAgICBpZiAoaXNBcnJheShmaXJzdCkgPT09IHRydWUpIHtcbiAgICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgdGhleSdyZSBub3QgdGhlIHNhbWUgbGVuZ3RoO1xuICAgICAgaWYgKGZpcnN0Lmxlbmd0aCAhPT0gc2Vjb25kLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpY3REZWVwRXF1YWwoZmlyc3RbaV0sIHNlY29uZFtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGZpcnN0KSA9PT0gdHJ1ZSkge1xuICAgICAgLy8gQW4gb2JqZWN0IGlzIGVxdWFsIGlmIGl0IGhhcyB0aGUgc2FtZSBrZXkvdmFsdWUgcGFpcnMuXG4gICAgICB2YXIga2V5c1NlZW4gPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBmaXJzdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmaXJzdCwga2V5KSkge1xuICAgICAgICAgIGlmIChzdHJpY3REZWVwRXF1YWwoZmlyc3Rba2V5XSwgc2Vjb25kW2tleV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlzU2VlbltrZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTm93IGNoZWNrIHRoYXQgdGhlcmUgYXJlbid0IGFueSBrZXlzIGluIHNlY29uZCB0aGF0IHdlcmVuJ3RcbiAgICAgIC8vIGluIGZpcnN0LlxuICAgICAgZm9yICh2YXIga2V5MiBpbiBzZWNvbmQpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc2Vjb25kLCBrZXkyKSkge1xuICAgICAgICAgIGlmIChrZXlzU2VlbltrZXkyXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRmFsc2Uob2JqKSB7XG4gICAgLy8gRnJvbSB0aGUgc3BlYzpcbiAgICAvLyBBIGZhbHNlIHZhbHVlIGNvcnJlc3BvbmRzIHRvIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICAgIC8vIEVtcHR5IGxpc3RcbiAgICAvLyBFbXB0eSBvYmplY3RcbiAgICAvLyBFbXB0eSBzdHJpbmdcbiAgICAvLyBGYWxzZSBib29sZWFuXG4gICAgLy8gbnVsbCB2YWx1ZVxuXG4gICAgLy8gRmlyc3QgY2hlY2sgdGhlIHNjYWxhciB2YWx1ZXMuXG4gICAgaWYgKG9iaiA9PT0gXCJcIiB8fCBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbiBlbXB0eSBhcnJheS5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChvYmopKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbiBlbXB0eSBvYmplY3QuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhbnkga2V5cywgdGhlblxuICAgICAgICAgICAgLy8gdGhlIG9iamVjdCBpcyBub3QgZW1wdHkgc28gdGhlIG9iamVjdFxuICAgICAgICAgICAgLy8gaXMgbm90IGZhbHNlLlxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb2JqVmFsdWVzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXMucHVzaChvYmpba2V5c1tpXV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xuICAgICAgdmFyIG1lcmdlZCA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgICBtZXJnZWRba2V5XSA9IGFba2V5XTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleTIgaW4gYikge1xuICAgICAgICAgIG1lcmdlZFtrZXkyXSA9IGJba2V5Ml07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkO1xuICB9XG5cbiAgdmFyIHRyaW1MZWZ0O1xuICBpZiAodHlwZW9mIFN0cmluZy5wcm90b3R5cGUudHJpbUxlZnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRyaW1MZWZ0ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnRyaW1MZWZ0KCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0cmltTGVmdCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5tYXRjaCgvXlxccyooLiopLylbMV07XG4gICAgfTtcbiAgfVxuXG4gIC8vIFR5cGUgY29uc3RhbnRzIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9ucy5cbiAgdmFyIFRZUEVfTlVNQkVSID0gMDtcbiAgdmFyIFRZUEVfQU5ZID0gMTtcbiAgdmFyIFRZUEVfU1RSSU5HID0gMjtcbiAgdmFyIFRZUEVfQVJSQVkgPSAzO1xuICB2YXIgVFlQRV9PQkpFQ1QgPSA0O1xuICB2YXIgVFlQRV9CT09MRUFOID0gNTtcbiAgdmFyIFRZUEVfRVhQUkVGID0gNjtcbiAgdmFyIFRZUEVfTlVMTCA9IDc7XG4gIHZhciBUWVBFX0FSUkFZX05VTUJFUiA9IDg7XG4gIHZhciBUWVBFX0FSUkFZX1NUUklORyA9IDk7XG4gIHZhciBUWVBFX05BTUVfVEFCTEUgPSB7XG4gICAgMDogJ251bWJlcicsXG4gICAgMTogJ2FueScsXG4gICAgMjogJ3N0cmluZycsXG4gICAgMzogJ2FycmF5JyxcbiAgICA0OiAnb2JqZWN0JyxcbiAgICA1OiAnYm9vbGVhbicsXG4gICAgNjogJ2V4cHJlc3Npb24nLFxuICAgIDc6ICdudWxsJyxcbiAgICA4OiAnQXJyYXk8bnVtYmVyPicsXG4gICAgOTogJ0FycmF5PHN0cmluZz4nXG4gIH07XG5cbiAgdmFyIFRPS19FT0YgPSBcIkVPRlwiO1xuICB2YXIgVE9LX1VOUVVPVEVESURFTlRJRklFUiA9IFwiVW5xdW90ZWRJZGVudGlmaWVyXCI7XG4gIHZhciBUT0tfUVVPVEVESURFTlRJRklFUiA9IFwiUXVvdGVkSWRlbnRpZmllclwiO1xuICB2YXIgVE9LX1JCUkFDS0VUID0gXCJSYnJhY2tldFwiO1xuICB2YXIgVE9LX1JQQVJFTiA9IFwiUnBhcmVuXCI7XG4gIHZhciBUT0tfQ09NTUEgPSBcIkNvbW1hXCI7XG4gIHZhciBUT0tfQ09MT04gPSBcIkNvbG9uXCI7XG4gIHZhciBUT0tfUkJSQUNFID0gXCJSYnJhY2VcIjtcbiAgdmFyIFRPS19OVU1CRVIgPSBcIk51bWJlclwiO1xuICB2YXIgVE9LX0NVUlJFTlQgPSBcIkN1cnJlbnRcIjtcbiAgdmFyIFRPS19FWFBSRUYgPSBcIkV4cHJlZlwiO1xuICB2YXIgVE9LX1BJUEUgPSBcIlBpcGVcIjtcbiAgdmFyIFRPS19PUiA9IFwiT3JcIjtcbiAgdmFyIFRPS19BTkQgPSBcIkFuZFwiO1xuICB2YXIgVE9LX0VRID0gXCJFUVwiO1xuICB2YXIgVE9LX0dUID0gXCJHVFwiO1xuICB2YXIgVE9LX0xUID0gXCJMVFwiO1xuICB2YXIgVE9LX0dURSA9IFwiR1RFXCI7XG4gIHZhciBUT0tfTFRFID0gXCJMVEVcIjtcbiAgdmFyIFRPS19ORSA9IFwiTkVcIjtcbiAgdmFyIFRPS19GTEFUVEVOID0gXCJGbGF0dGVuXCI7XG4gIHZhciBUT0tfU1RBUiA9IFwiU3RhclwiO1xuICB2YXIgVE9LX0ZJTFRFUiA9IFwiRmlsdGVyXCI7XG4gIHZhciBUT0tfRE9UID0gXCJEb3RcIjtcbiAgdmFyIFRPS19OT1QgPSBcIk5vdFwiO1xuICB2YXIgVE9LX0xCUkFDRSA9IFwiTGJyYWNlXCI7XG4gIHZhciBUT0tfTEJSQUNLRVQgPSBcIkxicmFja2V0XCI7XG4gIHZhciBUT0tfTFBBUkVOPSBcIkxwYXJlblwiO1xuICB2YXIgVE9LX0xJVEVSQUw9IFwiTGl0ZXJhbFwiO1xuXG4gIC8vIFRoZSBcIiZcIiwgXCJbXCIsIFwiPFwiLCBcIj5cIiB0b2tlbnNcbiAgLy8gYXJlIG5vdCBpbiBiYXNpY1Rva2VuIGJlY2F1c2VcbiAgLy8gdGhlcmUgYXJlIHR3byB0b2tlbiB2YXJpYW50c1xuICAvLyAoXCImJlwiLCBcIls/XCIsIFwiPD1cIiwgXCI+PVwiKS4gIFRoaXMgaXMgc3BlY2lhbGx5IGhhbmRsZWRcbiAgLy8gYmVsb3cuXG5cbiAgdmFyIGJhc2ljVG9rZW5zID0ge1xuICAgIFwiLlwiOiBUT0tfRE9ULFxuICAgIFwiKlwiOiBUT0tfU1RBUixcbiAgICBcIixcIjogVE9LX0NPTU1BLFxuICAgIFwiOlwiOiBUT0tfQ09MT04sXG4gICAgXCJ7XCI6IFRPS19MQlJBQ0UsXG4gICAgXCJ9XCI6IFRPS19SQlJBQ0UsXG4gICAgXCJdXCI6IFRPS19SQlJBQ0tFVCxcbiAgICBcIihcIjogVE9LX0xQQVJFTixcbiAgICBcIilcIjogVE9LX1JQQVJFTixcbiAgICBcIkBcIjogVE9LX0NVUlJFTlRcbiAgfTtcblxuICB2YXIgb3BlcmF0b3JTdGFydFRva2VuID0ge1xuICAgICAgXCI8XCI6IHRydWUsXG4gICAgICBcIj5cIjogdHJ1ZSxcbiAgICAgIFwiPVwiOiB0cnVlLFxuICAgICAgXCIhXCI6IHRydWVcbiAgfTtcblxuICB2YXIgc2tpcENoYXJzID0ge1xuICAgICAgXCIgXCI6IHRydWUsXG4gICAgICBcIlxcdFwiOiB0cnVlLFxuICAgICAgXCJcXG5cIjogdHJ1ZVxuICB9O1xuXG5cbiAgZnVuY3Rpb24gaXNBbHBoYShjaCkge1xuICAgICAgcmV0dXJuIChjaCA+PSBcImFcIiAmJiBjaCA8PSBcInpcIikgfHxcbiAgICAgICAgICAgICAoY2ggPj0gXCJBXCIgJiYgY2ggPD0gXCJaXCIpIHx8XG4gICAgICAgICAgICAgY2ggPT09IFwiX1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOdW0oY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPj0gXCIwXCIgJiYgY2ggPD0gXCI5XCIpIHx8XG4gICAgICAgICAgICAgY2ggPT09IFwiLVwiO1xuICB9XG4gIGZ1bmN0aW9uIGlzQWxwaGFOdW0oY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPj0gXCJhXCIgJiYgY2ggPD0gXCJ6XCIpIHx8XG4gICAgICAgICAgICAgKGNoID49IFwiQVwiICYmIGNoIDw9IFwiWlwiKSB8fFxuICAgICAgICAgICAgIChjaCA+PSBcIjBcIiAmJiBjaCA8PSBcIjlcIikgfHxcbiAgICAgICAgICAgICBjaCA9PT0gXCJfXCI7XG4gIH1cblxuICBmdW5jdGlvbiBMZXhlcigpIHtcbiAgfVxuICBMZXhlci5wcm90b3R5cGUgPSB7XG4gICAgICB0b2tlbml6ZTogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSAwO1xuICAgICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgICB2YXIgaWRlbnRpZmllcjtcbiAgICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnJlbnQgPCBzdHJlYW0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChpc0FscGhhKHN0cmVhbVt0aGlzLl9jdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSB0aGlzLl9jb25zdW1lVW5xdW90ZWRJZGVudGlmaWVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogVE9LX1VOUVVPVEVESURFTlRJRklFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChiYXNpY1Rva2Vuc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBiYXNpY1Rva2Vuc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0cmVhbVt0aGlzLl9jdXJyZW50XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLl9jdXJyZW50fSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOdW0oc3RyZWFtW3RoaXMuX2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLl9jb25zdW1lTnVtYmVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBpbmNyZW1lbnQgdGhpcy5fY3VycmVudC4gIFRoaXMgaGFwcGVuc1xuICAgICAgICAgICAgICAgICAgLy8gaW4gX2NvbnN1bWVMQnJhY2tldFxuICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLl9jb25zdW1lTEJyYWNrZXQoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiXFxcIlwiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gdGhpcy5fY29uc3VtZVF1b3RlZElkZW50aWZpZXIoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfUVVPVEVESURFTlRJRklFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gdGhpcy5fY29uc3VtZVJhd1N0cmluZ0xpdGVyYWwoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfTElURVJBTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiYFwiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHRoaXMuX2NvbnN1bWVMaXRlcmFsKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogVE9LX0xJVEVSQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxpdGVyYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3JTdGFydFRva2VuW3N0cmVhbVt0aGlzLl9jdXJyZW50XV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcy5fY29uc3VtZU9wZXJhdG9yKHN0cmVhbSkpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNraXBDaGFyc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCImXCIpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiJlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfQU5ELCB2YWx1ZTogXCImJlwiLCBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19FWFBSRUYsIHZhbHVlOiBcIiZcIiwgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcInxcIikge1xuICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19PUiwgdmFsdWU6IFwifHxcIiwgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfUElQRSwgdmFsdWU6IFwifFwiLCBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlVua25vd24gY2hhcmFjdGVyOlwiICsgc3RyZWFtW3RoaXMuX2N1cnJlbnRdKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIkxleGVyRXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZVVucXVvdGVkSWRlbnRpZmllcjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnJlbnQgPCBzdHJlYW0ubGVuZ3RoICYmIGlzQWxwaGFOdW0oc3RyZWFtW3RoaXMuX2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHJlYW0uc2xpY2Uoc3RhcnQsIHRoaXMuX2N1cnJlbnQpO1xuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVRdW90ZWRJZGVudGlmaWVyOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdICE9PSBcIlxcXCJcIiAmJiB0aGlzLl9jdXJyZW50IDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIFlvdSBjYW4gZXNjYXBlIGEgZG91YmxlIHF1b3RlIGFuZCB5b3UgY2FuIGVzY2FwZSBhbiBlc2NhcGUuXG4gICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVtjdXJyZW50XSA9PT0gXCJcXFxcXCIgJiYgKHN0cmVhbVtjdXJyZW50ICsgMV0gPT09IFwiXFxcXFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbVtjdXJyZW50ICsgMV0gPT09IFwiXFxcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudCArPSAyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyZWFtLnNsaWNlKHN0YXJ0LCB0aGlzLl9jdXJyZW50KSk7XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZVJhd1N0cmluZ0xpdGVyYWw6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHZhciBtYXhMZW5ndGggPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzdHJlYW1bdGhpcy5fY3VycmVudF0gIT09IFwiJ1wiICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gWW91IGNhbiBlc2NhcGUgYSBzaW5nbGUgcXVvdGUgYW5kIHlvdSBjYW4gZXNjYXBlIGFuIGVzY2FwZS5cbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW2N1cnJlbnRdID09PSBcIlxcXFxcIiAmJiAoc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJcXFxcXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCInXCIpKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHN0cmVhbS5zbGljZShzdGFydCArIDEsIHRoaXMuX2N1cnJlbnQgLSAxKTtcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbC5yZXBsYWNlKFwiXFxcXCdcIiwgXCInXCIpO1xuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVOdW1iZXI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHZhciBtYXhMZW5ndGggPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpc051bShzdHJlYW1bdGhpcy5fY3VycmVudF0pICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUludChzdHJlYW0uc2xpY2Uoc3RhcnQsIHRoaXMuX2N1cnJlbnQpKTtcbiAgICAgICAgICByZXR1cm4ge3R5cGU6IFRPS19OVU1CRVIsIHZhbHVlOiB2YWx1ZSwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgIH0sXG5cbiAgICAgIF9jb25zdW1lTEJyYWNrZXQ6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfRklMVEVSLCB2YWx1ZTogXCJbP1wiLCBzdGFydDogc3RhcnR9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIl1cIikge1xuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0ZMQVRURU4sIHZhbHVlOiBcIltdXCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTEJSQUNLRVQsIHZhbHVlOiBcIltcIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZU9wZXJhdG9yOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgIHZhciBzdGFydGluZ0NoYXIgPSBzdHJlYW1bc3RhcnRdO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICBpZiAoc3RhcnRpbmdDaGFyID09PSBcIiFcIikge1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIj1cIikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTkUsIHZhbHVlOiBcIiE9XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTk9ULCB2YWx1ZTogXCIhXCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI8XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0xURSwgdmFsdWU6IFwiPD1cIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0xULCB2YWx1ZTogXCI8XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0dURSwgdmFsdWU6IFwiPj1cIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0dULCB2YWx1ZTogXCI+XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0VRLCB2YWx1ZTogXCI9PVwiLCBzdGFydDogc3RhcnR9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVMaXRlcmFsOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICB2YXIgbGl0ZXJhbDtcbiAgICAgICAgICB3aGlsZShzdHJlYW1bdGhpcy5fY3VycmVudF0gIT09IFwiYFwiICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gWW91IGNhbiBlc2NhcGUgYSBsaXRlcmFsIGNoYXIgb3IgeW91IGNhbiBlc2NhcGUgdGhlIGVzY2FwZS5cbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW2N1cnJlbnRdID09PSBcIlxcXFxcIiAmJiAoc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJcXFxcXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJgXCIpKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsaXRlcmFsU3RyaW5nID0gdHJpbUxlZnQoc3RyZWFtLnNsaWNlKHN0YXJ0LCB0aGlzLl9jdXJyZW50KSk7XG4gICAgICAgICAgbGl0ZXJhbFN0cmluZyA9IGxpdGVyYWxTdHJpbmcucmVwbGFjZShcIlxcXFxgXCIsIFwiYFwiKTtcbiAgICAgICAgICBpZiAodGhpcy5fbG9va3NMaWtlSlNPTihsaXRlcmFsU3RyaW5nKSkge1xuICAgICAgICAgICAgICBsaXRlcmFsID0gSlNPTi5wYXJzZShsaXRlcmFsU3RyaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBUcnkgdG8gSlNPTiBwYXJzZSBpdCBhcyBcIjxsaXRlcmFsPlwiXG4gICAgICAgICAgICAgIGxpdGVyYWwgPSBKU09OLnBhcnNlKFwiXFxcIlwiICsgbGl0ZXJhbFN0cmluZyArIFwiXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gKzEgZ2V0cyB1cyB0byB0aGUgZW5kaW5nIFwiYFwiLCArMSB0byBtb3ZlIG9uIHRvIHRoZSBuZXh0IGNoYXIuXG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHJldHVybiBsaXRlcmFsO1xuICAgICAgfSxcblxuICAgICAgX2xvb2tzTGlrZUpTT046IGZ1bmN0aW9uKGxpdGVyYWxTdHJpbmcpIHtcbiAgICAgICAgICB2YXIgc3RhcnRpbmdDaGFycyA9IFwiW3tcXFwiXCI7XG4gICAgICAgICAgdmFyIGpzb25MaXRlcmFscyA9IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcIm51bGxcIl07XG4gICAgICAgICAgdmFyIG51bWJlckxvb2tpbmcgPSBcIi0wMTIzNDU2Nzg5XCI7XG5cbiAgICAgICAgICBpZiAobGl0ZXJhbFN0cmluZyA9PT0gXCJcIikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydGluZ0NoYXJzLmluZGV4T2YobGl0ZXJhbFN0cmluZ1swXSkgPj0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGpzb25MaXRlcmFscy5pbmRleE9mKGxpdGVyYWxTdHJpbmcpID49IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChudW1iZXJMb29raW5nLmluZGV4T2YobGl0ZXJhbFN0cmluZ1swXSkgPj0gMCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShsaXRlcmFsU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfTtcblxuICAgICAgdmFyIGJpbmRpbmdQb3dlciA9IHt9O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19FT0ZdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfVU5RVU9URURJREVOVElGSUVSXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1FVT1RFRElERU5USUZJRVJdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUkJSQUNLRVRdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUlBBUkVOXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0NPTU1BXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1JCUkFDRV0gPSAwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19OVU1CRVJdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfQ1VSUkVOVF0gPSAwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19FWFBSRUZdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUElQRV0gPSAxO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19PUl0gPSAyO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19BTkRdID0gMztcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfRVFdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfR1RdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfTFRdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfR1RFXSA9IDU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xURV0gPSA1O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19ORV0gPSA1O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19GTEFUVEVOXSA9IDk7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1NUQVJdID0gMjA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0ZJTFRFUl0gPSAyMTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfRE9UXSA9IDQwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19OT1RdID0gNDU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xCUkFDRV0gPSA1MDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfTEJSQUNLRVRdID0gNTU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xQQVJFTl0gPSA2MDtcblxuICBmdW5jdGlvbiBQYXJzZXIoKSB7XG4gIH1cblxuICBQYXJzZXIucHJvdG90eXBlID0ge1xuICAgICAgcGFyc2U6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLl9sb2FkVG9rZW5zKGV4cHJlc3Npb24pO1xuICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgIHZhciBhc3QgPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX0VPRikge1xuICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgdG9rZW4gdHlwZTogXCIgKyB0LnR5cGUgKyBcIiwgdmFsdWU6IFwiICsgdC52YWx1ZSk7XG4gICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIlBhcnNlckVycm9yXCI7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfSxcblxuICAgICAgX2xvYWRUb2tlbnM6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIoKTtcbiAgICAgICAgICB2YXIgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoZXhwcmVzc2lvbik7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19FT0YsIHZhbHVlOiBcIlwiLCBzdGFydDogZXhwcmVzc2lvbi5sZW5ndGh9KTtcbiAgICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgIH0sXG5cbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKHJicCkge1xuICAgICAgICAgIHZhciBsZWZ0VG9rZW4gPSB0aGlzLl9sb29rYWhlYWRUb2tlbigwKTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLm51ZChsZWZ0VG9rZW4pO1xuICAgICAgICAgIHZhciBjdXJyZW50VG9rZW4gPSB0aGlzLl9sb29rYWhlYWQoMCk7XG4gICAgICAgICAgd2hpbGUgKHJicCA8IGJpbmRpbmdQb3dlcltjdXJyZW50VG9rZW5dKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgbGVmdCA9IHRoaXMubGVkKGN1cnJlbnRUb2tlbiwgbGVmdCk7XG4gICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICB9LFxuXG4gICAgICBfbG9va2FoZWFkOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pbmRleCArIG51bWJlcl0udHlwZTtcbiAgICAgIH0sXG5cbiAgICAgIF9sb29rYWhlYWRUb2tlbjogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaW5kZXggKyBudW1iZXJdO1xuICAgICAgfSxcblxuICAgICAgX2FkdmFuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgIH0sXG5cbiAgICAgIG51ZDogZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgdmFyIGxlZnQ7XG4gICAgICAgIHZhciByaWdodDtcbiAgICAgICAgdmFyIGV4cHJlc3Npb247XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgIGNhc2UgVE9LX0xJVEVSQUw6XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiTGl0ZXJhbFwiLCB2YWx1ZTogdG9rZW4udmFsdWV9O1xuICAgICAgICAgIGNhc2UgVE9LX1VOUVVPVEVESURFTlRJRklFUjpcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJGaWVsZFwiLCBuYW1lOiB0b2tlbi52YWx1ZX07XG4gICAgICAgICAgY2FzZSBUT0tfUVVPVEVESURFTlRJRklFUjpcbiAgICAgICAgICAgIHZhciBub2RlID0ge3R5cGU6IFwiRmllbGRcIiwgbmFtZTogdG9rZW4udmFsdWV9O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0xQQVJFTikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1b3RlZCBpZGVudGlmaWVyIG5vdCBhbGxvd2VkIGZvciBmdW5jdGlvbiBuYW1lcy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICBjYXNlIFRPS19OT1Q6XG4gICAgICAgICAgICByaWdodCA9IHRoaXMuZXhwcmVzc2lvbihiaW5kaW5nUG93ZXIuTm90KTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJOb3RFeHByZXNzaW9uXCIsIGNoaWxkcmVuOiBbcmlnaHRdfTtcbiAgICAgICAgICBjYXNlIFRPS19TVEFSOlxuICAgICAgICAgICAgbGVmdCA9IHt0eXBlOiBcIklkZW50aXR5XCJ9O1xuICAgICAgICAgICAgcmlnaHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX1JCUkFDS0VUKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGluIGEgbXVsdGlzZWxlY3QsXG4gICAgICAgICAgICAgICAgLy8gW2EsIGIsICpdXG4gICAgICAgICAgICAgICAgcmlnaHQgPSB7dHlwZTogXCJJZGVudGl0eVwifTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLlN0YXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlZhbHVlUHJvamVjdGlvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0XX07XG4gICAgICAgICAgY2FzZSBUT0tfRklMVEVSOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVkKHRva2VuLnR5cGUsIHt0eXBlOiBcIklkZW50aXR5XCJ9KTtcbiAgICAgICAgICBjYXNlIFRPS19MQlJBQ0U6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VNdWx0aXNlbGVjdEhhc2goKTtcbiAgICAgICAgICBjYXNlIFRPS19GTEFUVEVOOlxuICAgICAgICAgICAgbGVmdCA9IHt0eXBlOiBUT0tfRkxBVFRFTiwgY2hpbGRyZW46IFt7dHlwZTogXCJJZGVudGl0eVwifV19O1xuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLkZsYXR0ZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlByb2plY3Rpb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0xCUkFDS0VUOlxuICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX05VTUJFUiB8fCB0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT0xPTikge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VJbmRleEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvamVjdElmU2xpY2Uoe3R5cGU6IFwiSWRlbnRpdHlcIn0sIHJpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfU1RBUiAmJlxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb29rYWhlYWQoMSkgPT09IFRPS19SQlJBQ0tFVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLlN0YXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJQcm9qZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW3t0eXBlOiBcIklkZW50aXR5XCJ9LCByaWdodF19O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlTXVsdGlzZWxlY3RMaXN0KCk7XG4gICAgICAgICAgY2FzZSBUT0tfQ1VSUkVOVDpcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0NVUlJFTlR9O1xuICAgICAgICAgIGNhc2UgVE9LX0VYUFJFRjpcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLkV4cHJlZik7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiRXhwcmVzc2lvblJlZmVyZW5jZVwiLCBjaGlsZHJlbjogW2V4cHJlc3Npb25dfTtcbiAgICAgICAgICBjYXNlIFRPS19MUEFSRU46XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX1JQQVJFTikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ1VSUkVOVCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB7dHlwZTogVE9LX0NVUlJFTlR9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFyZ3MucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SUEFSRU4pO1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yVG9rZW4odG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBsZWQ6IGZ1bmN0aW9uKHRva2VuTmFtZSwgbGVmdCkge1xuICAgICAgICB2YXIgcmlnaHQ7XG4gICAgICAgIHN3aXRjaCh0b2tlbk5hbWUpIHtcbiAgICAgICAgICBjYXNlIFRPS19ET1Q6XG4gICAgICAgICAgICB2YXIgcmJwID0gYmluZGluZ1Bvd2VyLkRvdDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgIT09IFRPS19TVEFSKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZURvdFJIUyhyYnApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJTdWJleHByZXNzaW9uXCIsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENyZWF0aW5nIGEgcHJvamVjdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKHJicCk7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiVmFsdWVQcm9qZWN0aW9uXCIsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgICAgICBjYXNlIFRPS19QSVBFOlxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLlBpcGUpO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfUElQRSwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX09SOlxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLk9yKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJPckV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0FORDpcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKGJpbmRpbmdQb3dlci5BbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIkFuZEV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0xQQVJFTjpcbiAgICAgICAgICAgIHZhciBuYW1lID0gbGVmdC5uYW1lO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uLCBub2RlO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX1JQQVJFTikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ1VSUkVOVCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB7dHlwZTogVE9LX0NVUlJFTlR9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT01NQSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19DT01NQSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JQQVJFTik7XG4gICAgICAgICAgICBub2RlID0ge3R5cGU6IFwiRnVuY3Rpb25cIiwgbmFtZTogbmFtZSwgY2hpbGRyZW46IGFyZ3N9O1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgY2FzZSBUT0tfRklMVEVSOlxuICAgICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0tFVCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfRkxBVFRFTikge1xuICAgICAgICAgICAgICByaWdodCA9IHt0eXBlOiBcIklkZW50aXR5XCJ9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLkZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiRmlsdGVyUHJvamVjdGlvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0LCBjb25kaXRpb25dfTtcbiAgICAgICAgICBjYXNlIFRPS19GTEFUVEVOOlxuICAgICAgICAgICAgdmFyIGxlZnROb2RlID0ge3R5cGU6IFRPS19GTEFUVEVOLCBjaGlsZHJlbjogW2xlZnRdfTtcbiAgICAgICAgICAgIHZhciByaWdodE5vZGUgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLkZsYXR0ZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlByb2plY3Rpb25cIiwgY2hpbGRyZW46IFtsZWZ0Tm9kZSwgcmlnaHROb2RlXX07XG4gICAgICAgICAgY2FzZSBUT0tfRVE6XG4gICAgICAgICAgY2FzZSBUT0tfTkU6XG4gICAgICAgICAgY2FzZSBUT0tfR1Q6XG4gICAgICAgICAgY2FzZSBUT0tfR1RFOlxuICAgICAgICAgIGNhc2UgVE9LX0xUOlxuICAgICAgICAgIGNhc2UgVE9LX0xURTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZUNvbXBhcmF0b3IobGVmdCwgdG9rZW5OYW1lKTtcbiAgICAgICAgICBjYXNlIFRPS19MQlJBQ0tFVDpcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRPS19OVU1CRVIgfHwgdG9rZW4udHlwZSA9PT0gVE9LX0NPTE9OKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZUluZGV4RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0SWZTbGljZShsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfU1RBUik7XG4gICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfUkJSQUNLRVQpO1xuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLlN0YXIpO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlByb2plY3Rpb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLl9lcnJvclRva2VuKHRoaXMuX2xvb2thaGVhZFRva2VuKDApKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX21hdGNoOiBmdW5jdGlvbih0b2tlblR5cGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSB0b2tlblR5cGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5fbG9va2FoZWFkVG9rZW4oMCk7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiICsgdG9rZW5UeXBlICsgXCIsIGdvdDogXCIgKyB0LnR5cGUpO1xuICAgICAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJFcnJvclwiO1xuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfZXJyb3JUb2tlbjogZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJJbnZhbGlkIHRva2VuIChcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgKyBcIik6IFxcXCJcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlICsgXCJcXFwiXCIpO1xuICAgICAgICAgIGVycm9yLm5hbWUgPSBcIlBhcnNlckVycm9yXCI7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9LFxuXG5cbiAgICAgIF9wYXJzZUluZGV4RXhwcmVzc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0NPTE9OIHx8IHRoaXMuX2xvb2thaGVhZCgxKSA9PT0gVE9LX0NPTE9OKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZVNsaWNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBub2RlID0ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJJbmRleFwiLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuX2xvb2thaGVhZFRva2VuKDApLnZhbHVlfTtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfUkJSQUNLRVQpO1xuICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfcHJvamVjdElmU2xpY2U6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgdmFyIGluZGV4RXhwciA9IHt0eXBlOiBcIkluZGV4RXhwcmVzc2lvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0XX07XG4gICAgICAgICAgaWYgKHJpZ2h0LnR5cGUgPT09IFwiU2xpY2VcIikge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJQcm9qZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW2luZGV4RXhwciwgdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKV1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gaW5kZXhFeHByO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9wYXJzZVNsaWNlRXhwcmVzc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gW3N0YXJ0OmVuZDpzdGVwXSB3aGVyZSBlYWNoIHBhcnQgaXMgb3B0aW9uYWwsIGFzIHdlbGwgYXMgdGhlIGxhc3RcbiAgICAgICAgICAvLyBjb2xvbi5cbiAgICAgICAgICB2YXIgcGFydHMgPSBbbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgICB2YXIgY3VycmVudFRva2VuID0gdGhpcy5fbG9va2FoZWFkKDApO1xuICAgICAgICAgIHdoaWxlIChjdXJyZW50VG9rZW4gIT09IFRPS19SQlJBQ0tFVCAmJiBpbmRleCA8IDMpIHtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUb2tlbiA9PT0gVE9LX0NPTE9OKSB7XG4gICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRUb2tlbiA9PT0gVE9LX05VTUJFUikge1xuICAgICAgICAgICAgICAgICAgcGFydHNbaW5kZXhdID0gdGhpcy5fbG9va2FoZWFkVG9rZW4oMCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlN5bnRheCBlcnJvciwgdW5leHBlY3RlZCB0b2tlbjogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQudmFsdWUgKyBcIihcIiArIHQudHlwZSArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIlBhcnNlcmVycm9yXCI7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSB0aGlzLl9sb29rYWhlYWQoMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0tFVCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJTbGljZVwiLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogcGFydHNcbiAgICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgX3BhcnNlQ29tcGFyYXRvcjogZnVuY3Rpb24obGVmdCwgY29tcGFyYXRvcikge1xuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyW2NvbXBhcmF0b3JdKTtcbiAgICAgICAgcmV0dXJuIHt0eXBlOiBcIkNvbXBhcmF0b3JcIiwgbmFtZTogY29tcGFyYXRvciwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgfSxcblxuICAgICAgX3BhcnNlRG90UkhTOiBmdW5jdGlvbihyYnApIHtcbiAgICAgICAgICB2YXIgbG9va2FoZWFkID0gdGhpcy5fbG9va2FoZWFkKDApO1xuICAgICAgICAgIHZhciBleHByVG9rZW5zID0gW1RPS19VTlFVT1RFRElERU5USUZJRVIsIFRPS19RVU9URURJREVOVElGSUVSLCBUT0tfU1RBUl07XG4gICAgICAgICAgaWYgKGV4cHJUb2tlbnMuaW5kZXhPZihsb29rYWhlYWQpID49IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbihyYnApO1xuICAgICAgICAgIH0gZWxzZSBpZiAobG9va2FoZWFkID09PSBUT0tfTEJSQUNLRVQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX0xCUkFDS0VUKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlTXVsdGlzZWxlY3RMaXN0KCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsb29rYWhlYWQgPT09IFRPS19MQlJBQ0UpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX0xCUkFDRSk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZU11bHRpc2VsZWN0SGFzaCgpO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9wYXJzZVByb2plY3Rpb25SSFM6IGZ1bmN0aW9uKHJicCkge1xuICAgICAgICAgIHZhciByaWdodDtcbiAgICAgICAgICBpZiAoYmluZGluZ1Bvd2VyW3RoaXMuX2xvb2thaGVhZCgwKV0gPCAxMCkge1xuICAgICAgICAgICAgICByaWdodCA9IHt0eXBlOiBcIklkZW50aXR5XCJ9O1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfTEJSQUNLRVQpIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24ocmJwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0ZJTFRFUikge1xuICAgICAgICAgICAgICByaWdodCA9IHRoaXMuZXhwcmVzc2lvbihyYnApO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfRE9UKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19ET1QpO1xuICAgICAgICAgICAgICByaWdodCA9IHRoaXMuX3BhcnNlRG90UkhTKHJicCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLl9sb29rYWhlYWRUb2tlbigwKTtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiU3l0YW54IGVycm9yLCB1bmV4cGVjdGVkIHRva2VuOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnZhbHVlICsgXCIoXCIgKyB0LnR5cGUgKyBcIilcIik7XG4gICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIlBhcnNlckVycm9yXCI7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICB9LFxuXG4gICAgICBfcGFyc2VNdWx0aXNlbGVjdExpc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICAgIHdoaWxlICh0aGlzLl9sb29rYWhlYWQoMCkgIT09IFRPS19SQlJBQ0tFVCkge1xuICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0NPTU1BKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfQ09NTUEpO1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX1JCUkFDS0VUKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gUmJyYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JCUkFDS0VUKTtcbiAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiTXVsdGlTZWxlY3RMaXN0XCIsIGNoaWxkcmVuOiBleHByZXNzaW9uc307XG4gICAgICB9LFxuXG4gICAgICBfcGFyc2VNdWx0aXNlbGVjdEhhc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICAgICAgdmFyIGlkZW50aWZpZXJUeXBlcyA9IFtUT0tfVU5RVU9URURJREVOVElGSUVSLCBUT0tfUVVPVEVESURFTlRJRklFUl07XG4gICAgICAgIHZhciBrZXlUb2tlbiwga2V5TmFtZSwgdmFsdWUsIG5vZGU7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBrZXlUb2tlbiA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgIGlmIChpZGVudGlmaWVyVHlwZXMuaW5kZXhPZihrZXlUb2tlbi50eXBlKSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGluZyBhbiBpZGVudGlmaWVyIHRva2VuLCBnb3Q6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlUb2tlbi50eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5TmFtZSA9IGtleVRva2VuLnZhbHVlO1xuICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfQ09MT04pO1xuICAgICAgICAgIHZhbHVlID0gdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgIG5vZGUgPSB7dHlwZTogXCJLZXlWYWx1ZVBhaXJcIiwgbmFtZToga2V5TmFtZSwgdmFsdWU6IHZhbHVlfTtcbiAgICAgICAgICBwYWlycy5wdXNoKG5vZGUpO1xuICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT01NQSkge1xuICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX0NPTU1BKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX1JCUkFDRSkge1xuICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JCUkFDRSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt0eXBlOiBcIk11bHRpU2VsZWN0SGFzaFwiLCBjaGlsZHJlbjogcGFpcnN9O1xuICAgICAgfVxuICB9O1xuXG5cbiAgZnVuY3Rpb24gVHJlZUludGVycHJldGVyKHJ1bnRpbWUpIHtcbiAgICB0aGlzLnJ1bnRpbWUgPSBydW50aW1lO1xuICB9XG5cbiAgVHJlZUludGVycHJldGVyLnByb3RvdHlwZSA9IHtcbiAgICAgIHNlYXJjaDogZnVuY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdChub2RlLCB2YWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICB2aXNpdDogZnVuY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgbWF0Y2hlZCwgY3VycmVudCwgcmVzdWx0LCBmaXJzdCwgc2Vjb25kLCBmaWVsZCwgbGVmdCwgcmlnaHQsIGNvbGxlY3RlZCwgaTtcbiAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIkZpZWxkXCI6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIGZpZWxkID0gdmFsdWVbbm9kZS5uYW1lXTtcbiAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgXCJTdWJleHByZXNzaW9uXCI6XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlIFwiSW5kZXhFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICAgIGxlZnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMV0sIGxlZnQpO1xuICAgICAgICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICAgICAgICBjYXNlIFwiSW5kZXhcIjpcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IG5vZGUudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHZhbHVlLmxlbmd0aCArIGluZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgY2FzZSBcIlNsaWNlXCI6XG4gICAgICAgICAgICAgIGlmICghaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgc2xpY2VQYXJhbXMgPSBub2RlLmNoaWxkcmVuLnNsaWNlKDApO1xuICAgICAgICAgICAgICB2YXIgY29tcHV0ZWQgPSB0aGlzLmNvbXB1dGVTbGljZVBhcmFtcyh2YWx1ZS5sZW5ndGgsIHNsaWNlUGFyYW1zKTtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY29tcHV0ZWRbMF07XG4gICAgICAgICAgICAgIHZhciBzdG9wID0gY29tcHV0ZWRbMV07XG4gICAgICAgICAgICAgIHZhciBzdGVwID0gY29tcHV0ZWRbMl07XG4gICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RvcDsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPiBzdG9wOyBpICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGNhc2UgXCJQcm9qZWN0aW9uXCI6XG4gICAgICAgICAgICAgIC8vIEV2YWx1YXRlIGxlZnQgY2hpbGQuXG4gICAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmICghaXNBcnJheShiYXNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmFzZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMV0sIGJhc2VbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcbiAgICAgICAgICAgIGNhc2UgXCJWYWx1ZVByb2plY3Rpb25cIjpcbiAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgbGVmdCBjaGlsZC5cbiAgICAgICAgICAgICAgYmFzZSA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29sbGVjdGVkID0gW107XG4gICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBvYmpWYWx1ZXMoYmFzZSk7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcbiAgICAgICAgICAgIGNhc2UgXCJGaWx0ZXJQcm9qZWN0aW9uXCI6XG4gICAgICAgICAgICAgIGJhc2UgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gW107XG4gICAgICAgICAgICAgIHZhciBmaW5hbFJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJhc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzJdLCBiYXNlW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmFsc2UobWF0Y2hlZCkpIHtcbiAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnB1c2goYmFzZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmlsdGVyZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCBmaWx0ZXJlZFtqXSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmluYWxSZXN1bHRzO1xuICAgICAgICAgICAgY2FzZSBcIkNvbXBhcmF0b3JcIjpcbiAgICAgICAgICAgICAgZmlyc3QgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgc2Vjb25kID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHN3aXRjaChub2RlLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19FUTpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHN0cmljdERlZXBFcXVhbChmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVE9LX05FOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gIXN0cmljdERlZXBFcXVhbChmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVE9LX0dUOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3QgPiBzZWNvbmQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19HVEU6XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBmaXJzdCA+PSBzZWNvbmQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19MVDpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpcnN0IDwgc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUT0tfTFRFOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3QgPD0gc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29tcGFyYXRvcjogXCIgKyBub2RlLm5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlIFRPS19GTEFUVEVOOlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBtZXJnZWQgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9yaWdpbmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG9yaWdpbmFsW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICBtZXJnZWQucHVzaC5hcHBseShtZXJnZWQsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgICAgIGNhc2UgXCJJZGVudGl0eVwiOlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlTZWxlY3RMaXN0XCI6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29sbGVjdGVkLnB1c2godGhpcy52aXNpdChub2RlLmNoaWxkcmVuW2ldLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlTZWxlY3RIYXNoXCI6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IHt9O1xuICAgICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNvbGxlY3RlZFtjaGlsZC5uYW1lXSA9IHRoaXMudmlzaXQoY2hpbGQudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xuICAgICAgICAgICAgY2FzZSBcIk9yRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmIChpc0ZhbHNlKG1hdGNoZWQpKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgICAgICAgICBjYXNlIFwiQW5kRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBmaXJzdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgIGlmIChpc0ZhbHNlKGZpcnN0KSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwiTm90RXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBmaXJzdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICByZXR1cm4gaXNGYWxzZShmaXJzdCk7XG4gICAgICAgICAgICBjYXNlIFwiTGl0ZXJhbFwiOlxuICAgICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgVE9LX1BJUEU6XG4gICAgICAgICAgICAgIGxlZnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblsxXSwgbGVmdCk7XG4gICAgICAgICAgICBjYXNlIFRPS19DVVJSRU5UOlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwiRnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgdmFyIHJlc29sdmVkQXJncyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcmdzLnB1c2godGhpcy52aXNpdChub2RlLmNoaWxkcmVuW2ldLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bnRpbWUuY2FsbEZ1bmN0aW9uKG5vZGUubmFtZSwgcmVzb2x2ZWRBcmdzKTtcbiAgICAgICAgICAgIGNhc2UgXCJFeHByZXNzaW9uUmVmZXJlbmNlXCI6XG4gICAgICAgICAgICAgIHZhciByZWZOb2RlID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgLy8gVGFnIHRoZSBub2RlIHdpdGggYSBzcGVjaWZpYyBhdHRyaWJ1dGUgc28gdGhlIHR5cGVcbiAgICAgICAgICAgICAgLy8gY2hlY2tlciB2ZXJpZnkgdGhlIHR5cGUuXG4gICAgICAgICAgICAgIHJlZk5vZGUuam1lc3BhdGhUeXBlID0gVE9LX0VYUFJFRjtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlZk5vZGU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIgKyBub2RlLnR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGNvbXB1dGVTbGljZVBhcmFtczogZnVuY3Rpb24oYXJyYXlMZW5ndGgsIHNsaWNlUGFyYW1zKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHNsaWNlUGFyYW1zWzBdO1xuICAgICAgICB2YXIgc3RvcCA9IHNsaWNlUGFyYW1zWzFdO1xuICAgICAgICB2YXIgc3RlcCA9IHNsaWNlUGFyYW1zWzJdO1xuICAgICAgICB2YXIgY29tcHV0ZWQgPSBbbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgICAgIGlmIChzdGVwID09PSBudWxsKSB7XG4gICAgICAgICAgc3RlcCA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkludmFsaWQgc2xpY2UsIHN0ZXAgY2Fubm90IGJlIDBcIik7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IFwiUnVudGltZUVycm9yXCI7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ZXBWYWx1ZU5lZ2F0aXZlID0gc3RlcCA8IDAgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydCA9IHN0ZXBWYWx1ZU5lZ2F0aXZlID8gYXJyYXlMZW5ndGggLSAxIDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5jYXBTbGljZVJhbmdlKGFycmF5TGVuZ3RoLCBzdGFydCwgc3RlcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RvcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RvcCA9IHN0ZXBWYWx1ZU5lZ2F0aXZlID8gLTEgOiBhcnJheUxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3AgPSB0aGlzLmNhcFNsaWNlUmFuZ2UoYXJyYXlMZW5ndGgsIHN0b3AsIHN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVkWzBdID0gc3RhcnQ7XG4gICAgICAgIGNvbXB1dGVkWzFdID0gc3RvcDtcbiAgICAgICAgY29tcHV0ZWRbMl0gPSBzdGVwO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgICB9LFxuXG4gICAgICBjYXBTbGljZVJhbmdlOiBmdW5jdGlvbihhcnJheUxlbmd0aCwgYWN0dWFsVmFsdWUsIHN0ZXApIHtcbiAgICAgICAgICBpZiAoYWN0dWFsVmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgIGFjdHVhbFZhbHVlICs9IGFycmF5TGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoYWN0dWFsVmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBhY3R1YWxWYWx1ZSA9IHN0ZXAgPCAwID8gLTEgOiAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhY3R1YWxWYWx1ZSA+PSBhcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICBhY3R1YWxWYWx1ZSA9IHN0ZXAgPCAwID8gYXJyYXlMZW5ndGggLSAxIDogYXJyYXlMZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhY3R1YWxWYWx1ZTtcbiAgICAgIH1cblxuICB9O1xuXG4gIGZ1bmN0aW9uIFJ1bnRpbWUoaW50ZXJwcmV0ZXIpIHtcbiAgICB0aGlzLl9pbnRlcnByZXRlciA9IGludGVycHJldGVyO1xuICAgIHRoaXMuZnVuY3Rpb25UYWJsZSA9IHtcbiAgICAgICAgLy8gbmFtZTogW2Z1bmN0aW9uLCA8c2lnbmF0dXJlPl1cbiAgICAgICAgLy8gVGhlIDxzaWduYXR1cmU+IGNhbiBiZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgIGFyZ3M6IFtbdHlwZTEsIHR5cGUyXSwgW3R5cGUxLCB0eXBlMl1dLFxuICAgICAgICAvLyAgIHZhcmlhZGljOiB0cnVlfGZhbHNlXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRWFjaCBhcmcgaW4gdGhlIGFyZyBsaXN0IGlzIGEgbGlzdCBvZiB2YWxpZCB0eXBlc1xuICAgICAgICAvLyAoaWYgdGhlIGZ1bmN0aW9uIGlzIG92ZXJsb2FkZWQgYW5kIHN1cHBvcnRzIG11bHRpcGxlXG4gICAgICAgIC8vIHR5cGVzLiAgSWYgdGhlIHR5cGUgaXMgXCJhbnlcIiB0aGVuIG5vIHR5cGUgY2hlY2tpbmdcbiAgICAgICAgLy8gb2NjdXJzIG9uIHRoZSBhcmd1bWVudC4gIFZhcmlhZGljIGlzIG9wdGlvbmFsXG4gICAgICAgIC8vIGFuZCBpZiBub3QgcHJvdmlkZWQgaXMgYXNzdW1lZCB0byBiZSBmYWxzZS5cbiAgICAgICAgYWJzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uQWJzLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBhdmc6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25BdmcsIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZX05VTUJFUl19XX0sXG4gICAgICAgIGNlaWw6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25DZWlsLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBjb250YWluczoge1xuICAgICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uQ29udGFpbnMsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkcsIFRZUEVfQVJSQVldfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlczogW1RZUEVfQU5ZXX1dfSxcbiAgICAgICAgXCJlbmRzX3dpdGhcIjoge1xuICAgICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uRW5kc1dpdGgsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkddfSwge3R5cGVzOiBbVFlQRV9TVFJJTkddfV19LFxuICAgICAgICBmbG9vcjoge19mdW5jOiB0aGlzLl9mdW5jdGlvbkZsb29yLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbkxlbmd0aCxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX1NUUklORywgVFlQRV9BUlJBWSwgVFlQRV9PQkpFQ1RdfV19LFxuICAgICAgICBtYXA6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1hcCxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0VYUFJFRl19LCB7dHlwZXM6IFtUWVBFX0FSUkFZXX1dfSxcbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NYXgsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BUlJBWV9OVU1CRVIsIFRZUEVfQVJSQVlfU1RSSU5HXX1dfSxcbiAgICAgICAgXCJtZXJnZVwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NZXJnZSxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX09CSkVDVF0sIHZhcmlhZGljOiB0cnVlfV1cbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXhfYnlcIjoge1xuICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1heEJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIHN1bToge19mdW5jOiB0aGlzLl9mdW5jdGlvblN1bSwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQVJSQVlfTlVNQkVSXX1dfSxcbiAgICAgICAgXCJzdGFydHNfd2l0aFwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25TdGFydHNXaXRoLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfU1RSSU5HXX0sIHt0eXBlczogW1RZUEVfU1RSSU5HXX1dfSxcbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NaW4sXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BUlJBWV9OVU1CRVIsIFRZUEVfQVJSQVlfU1RSSU5HXX1dfSxcbiAgICAgICAgXCJtaW5fYnlcIjoge1xuICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1pbkJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25UeXBlLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BTlldfV19LFxuICAgICAgICBrZXlzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uS2V5cywgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfT0JKRUNUXX1dfSxcbiAgICAgICAgdmFsdWVzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uVmFsdWVzLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9PQkpFQ1RdfV19LFxuICAgICAgICBzb3J0OiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uU29ydCwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQVJSQVlfU1RSSU5HLCBUWVBFX0FSUkFZX05VTUJFUl19XX0sXG4gICAgICAgIFwic29ydF9ieVwiOiB7XG4gICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uU29ydEJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIGpvaW46IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbkpvaW4sXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbXG4gICAgICAgICAgICAgICAge3R5cGVzOiBbVFlQRV9TVFJJTkddfSxcbiAgICAgICAgICAgICAgICB7dHlwZXM6IFtUWVBFX0FSUkFZX1NUUklOR119XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHJldmVyc2U6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvblJldmVyc2UsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkcsIFRZUEVfQVJSQVldfV19LFxuICAgICAgICBcInRvX2FycmF5XCI6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25Ub0FycmF5LCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BTlldfV19LFxuICAgICAgICBcInRvX3N0cmluZ1wiOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uVG9TdHJpbmcsIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FOWV19XX0sXG4gICAgICAgIFwidG9fbnVtYmVyXCI6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25Ub051bWJlciwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQU5ZXX1dfSxcbiAgICAgICAgXCJub3RfbnVsbFwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25Ob3ROdWxsLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQU5ZXSwgdmFyaWFkaWM6IHRydWV9XVxuICAgICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIFJ1bnRpbWUucHJvdG90eXBlID0ge1xuICAgIGNhbGxGdW5jdGlvbjogZnVuY3Rpb24obmFtZSwgcmVzb2x2ZWRBcmdzKSB7XG4gICAgICB2YXIgZnVuY3Rpb25FbnRyeSA9IHRoaXMuZnVuY3Rpb25UYWJsZVtuYW1lXTtcbiAgICAgIGlmIChmdW5jdGlvbkVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGZ1bmN0aW9uOiBcIiArIG5hbWUgKyBcIigpXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdmFsaWRhdGVBcmdzKG5hbWUsIHJlc29sdmVkQXJncywgZnVuY3Rpb25FbnRyeS5fc2lnbmF0dXJlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbkVudHJ5Ll9mdW5jLmNhbGwodGhpcywgcmVzb2x2ZWRBcmdzKTtcbiAgICB9LFxuXG4gICAgX3ZhbGlkYXRlQXJnczogZnVuY3Rpb24obmFtZSwgYXJncywgc2lnbmF0dXJlKSB7XG4gICAgICAgIC8vIFZhbGlkYXRpbmcgdGhlIGFyZ3MgcmVxdWlyZXMgdmFsaWRhdGluZ1xuICAgICAgICAvLyB0aGUgY29ycmVjdCBhcml0eSBhbmQgdGhlIGNvcnJlY3QgdHlwZSBvZiBlYWNoIGFyZy5cbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgYXJndW1lbnQgaXMgZGVjbGFyZWQgYXMgdmFyaWFkaWMsIHRoZW4gd2UgbmVlZFxuICAgICAgICAvLyBhIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3MgdG8gYmUgcmVxdWlyZWQuICBPdGhlcndpc2UgaXQgaGFzIHRvXG4gICAgICAgIC8vIGJlIGFuIGV4YWN0IGFtb3VudC5cbiAgICAgICAgdmFyIHBsdXJhbGl6ZWQ7XG4gICAgICAgIGlmIChzaWduYXR1cmVbc2lnbmF0dXJlLmxlbmd0aCAtIDFdLnZhcmlhZGljKSB7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBzaWduYXR1cmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGx1cmFsaXplZCA9IHNpZ25hdHVyZS5sZW5ndGggPT09IDEgPyBcIiBhcmd1bWVudFwiIDogXCIgYXJndW1lbnRzXCI7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnRFcnJvcjogXCIgKyBuYW1lICsgXCIoKSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGFrZXMgYXQgbGVhc3RcIiArIHNpZ25hdHVyZS5sZW5ndGggKyBwbHVyYWxpemVkICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIFwiICsgYXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoICE9PSBzaWduYXR1cmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBwbHVyYWxpemVkID0gc2lnbmF0dXJlLmxlbmd0aCA9PT0gMSA/IFwiIGFyZ3VtZW50XCIgOiBcIiBhcmd1bWVudHNcIjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50RXJyb3I6IFwiICsgbmFtZSArIFwiKCkgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGFrZXMgXCIgKyBzaWduYXR1cmUubGVuZ3RoICsgcGx1cmFsaXplZCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIFwiICsgYXJncy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50U3BlYztcbiAgICAgICAgdmFyIGFjdHVhbFR5cGU7XG4gICAgICAgIHZhciB0eXBlTWF0Y2hlZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWduYXR1cmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHR5cGVNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjdXJyZW50U3BlYyA9IHNpZ25hdHVyZVtpXS50eXBlcztcbiAgICAgICAgICAgIGFjdHVhbFR5cGUgPSB0aGlzLl9nZXRUeXBlTmFtZShhcmdzW2ldKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3VycmVudFNwZWMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHlwZU1hdGNoZXMoYWN0dWFsVHlwZSwgY3VycmVudFNwZWNbal0sIGFyZ3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0eXBlTWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIHZhciBleHBlY3RlZCA9IGN1cnJlbnRTcGVjXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odHlwZUlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBUWVBFX05BTUVfVEFCTEVbdHlwZUlkZW50aWZpZXJdO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCcpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGVFcnJvcjogXCIgKyBuYW1lICsgXCIoKSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgYXJndW1lbnQgXCIgKyAoaSArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgdG8gYmUgdHlwZSBcIiArIGV4cGVjdGVkICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIHR5cGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUWVBFX05BTUVfVEFCTEVbYWN0dWFsVHlwZV0gKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdHlwZU1hdGNoZXM6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIGFyZ1ZhbHVlKSB7XG4gICAgICAgIGlmIChleHBlY3RlZCA9PT0gVFlQRV9BTlkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBlY3RlZCA9PT0gVFlQRV9BUlJBWV9TVFJJTkcgfHxcbiAgICAgICAgICAgIGV4cGVjdGVkID09PSBUWVBFX0FSUkFZX05VTUJFUiB8fFxuICAgICAgICAgICAgZXhwZWN0ZWQgPT09IFRZUEVfQVJSQVkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBleHBlY3RlZCB0eXBlIGNhbiBlaXRoZXIganVzdCBiZSBhcnJheSxcbiAgICAgICAgICAgIC8vIG9yIGl0IGNhbiByZXF1aXJlIGEgc3BlY2lmaWMgc3VidHlwZSAoYXJyYXkgb2YgbnVtYmVycykuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhlIHNpbXBsZXN0IGNhc2UgaXMgaWYgXCJhcnJheVwiIHdpdGggbm8gc3VidHlwZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQVJSQVkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0dWFsID09PSBUWVBFX0FSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhY3R1YWwgPT09IFRZUEVfQVJSQVkpIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBjaGVjayBzdWJ0eXBlcy5cbiAgICAgICAgICAgICAgICAvLyBJIHRoaW5rIHRoaXMgaGFzIHBvdGVudGlhbCB0byBiZSBpbXByb3ZlZC5cbiAgICAgICAgICAgICAgICB2YXIgc3VidHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQVJSQVlfTlVNQkVSKSB7XG4gICAgICAgICAgICAgICAgICBzdWJ0eXBlID0gVFlQRV9OVU1CRVI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHBlY3RlZCA9PT0gVFlQRV9BUlJBWV9TVFJJTkcpIHtcbiAgICAgICAgICAgICAgICAgIHN1YnR5cGUgPSBUWVBFX1NUUklORztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3R5cGVNYXRjaGVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldFR5cGVOYW1lKGFyZ1ZhbHVlW2ldKSwgc3VidHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ1ZhbHVlW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGFjdHVhbCA9PT0gZXhwZWN0ZWQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9nZXRUeXBlTmFtZTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpIHtcbiAgICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IFN0cmluZ11cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfU1RSSU5HO1xuICAgICAgICAgICAgY2FzZSBcIltvYmplY3QgTnVtYmVyXVwiOlxuICAgICAgICAgICAgICByZXR1cm4gVFlQRV9OVU1CRVI7XG4gICAgICAgICAgICBjYXNlIFwiW29iamVjdCBBcnJheV1cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfQVJSQVk7XG4gICAgICAgICAgICBjYXNlIFwiW29iamVjdCBCb29sZWFuXVwiOlxuICAgICAgICAgICAgICByZXR1cm4gVFlQRV9CT09MRUFOO1xuICAgICAgICAgICAgY2FzZSBcIltvYmplY3QgTnVsbF1cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfTlVMTDtcbiAgICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IE9iamVjdF1cIjpcbiAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhbiBleHByZWYuICBJZiBpdCBoYXMsIGl0J3MgYmVlblxuICAgICAgICAgICAgICAvLyB0YWdnZWQgd2l0aCBhIGptZXNwYXRoVHlwZSBhdHRyIG9mICdFeHByZWYnO1xuICAgICAgICAgICAgICBpZiAob2JqLmptZXNwYXRoVHlwZSA9PT0gVE9LX0VYUFJFRikge1xuICAgICAgICAgICAgICAgIHJldHVybiBUWVBFX0VYUFJFRjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVFlQRV9PQkpFQ1Q7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25TdGFydHNXaXRoOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkQXJnc1swXS5sYXN0SW5kZXhPZihyZXNvbHZlZEFyZ3NbMV0pID09PSAwO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25FbmRzV2l0aDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHZhciBzZWFyY2hTdHIgPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICAgIHZhciBzdWZmaXggPSByZXNvbHZlZEFyZ3NbMV07XG4gICAgICAgIHJldHVybiBzZWFyY2hTdHIuaW5kZXhPZihzdWZmaXgsIHNlYXJjaFN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSAhPT0gLTE7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblJldmVyc2U6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgdHlwZU5hbWUgPSB0aGlzLl9nZXRUeXBlTmFtZShyZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICBpZiAodHlwZU5hbWUgPT09IFRZUEVfU1RSSU5HKSB7XG4gICAgICAgICAgdmFyIG9yaWdpbmFsU3RyID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICAgIHZhciByZXZlcnNlZFN0ciA9IFwiXCI7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IG9yaWdpbmFsU3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgIHJldmVyc2VkU3RyICs9IG9yaWdpbmFsU3RyW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV2ZXJzZWRTdHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJldmVyc2VkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF0uc2xpY2UoMCk7XG4gICAgICAgICAgcmV2ZXJzZWRBcnJheS5yZXZlcnNlKCk7XG4gICAgICAgICAgcmV0dXJuIHJldmVyc2VkQXJyYXk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uQWJzOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyhyZXNvbHZlZEFyZ3NbMF0pO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25DZWlsOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChyZXNvbHZlZEFyZ3NbMF0pO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25Bdmc6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgdmFyIGlucHV0QXJyYXkgPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGlucHV0QXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bSAvIGlucHV0QXJyYXkubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25Db250YWluczogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlZEFyZ3NbMF0uaW5kZXhPZihyZXNvbHZlZEFyZ3NbMV0pID49IDA7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbkZsb29yOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uTGVuZ3RoOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICBpZiAoIWlzT2JqZWN0KHJlc29sdmVkQXJnc1swXSkpIHtcbiAgICAgICAgIHJldHVybiByZXNvbHZlZEFyZ3NbMF0ubGVuZ3RoO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAvLyBBcyBmYXIgYXMgSSBjYW4gdGVsbCwgdGhlcmUncyBubyB3YXkgdG8gZ2V0IHRoZSBsZW5ndGhcbiAgICAgICAgIC8vIG9mIGFuIG9iamVjdCB3aXRob3V0IE8obikgaXRlcmF0aW9uIHRocm91Z2ggdGhlIG9iamVjdC5cbiAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXNvbHZlZEFyZ3NbMF0pLmxlbmd0aDtcbiAgICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1hcDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICB2YXIgbWFwcGVkID0gW107XG4gICAgICB2YXIgaW50ZXJwcmV0ZXIgPSB0aGlzLl9pbnRlcnByZXRlcjtcbiAgICAgIHZhciBleHByZWZOb2RlID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgdmFyIGVsZW1lbnRzID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1hcHBlZC5wdXNoKGludGVycHJldGVyLnZpc2l0KGV4cHJlZk5vZGUsIGVsZW1lbnRzW2ldKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwcGVkO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25NZXJnZTogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICB2YXIgbWVyZ2VkID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc29sdmVkQXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudCA9IHJlc29sdmVkQXJnc1tpXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGN1cnJlbnQpIHtcbiAgICAgICAgICBtZXJnZWRba2V5XSA9IGN1cnJlbnRba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uTWF4OiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgIGlmIChyZXNvbHZlZEFyZ3NbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdHlwZU5hbWUgPSB0aGlzLl9nZXRUeXBlTmFtZShyZXNvbHZlZEFyZ3NbMF1bMF0pO1xuICAgICAgICBpZiAodHlwZU5hbWUgPT09IFRZUEVfTlVNQkVSKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIHJlc29sdmVkQXJnc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICAgIHZhciBtYXhFbGVtZW50ID0gZWxlbWVudHNbMF07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAobWF4RWxlbWVudC5sb2NhbGVDb21wYXJlKGVsZW1lbnRzW2ldKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgIG1heEVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWF4RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uTWluOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgIGlmIChyZXNvbHZlZEFyZ3NbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdHlwZU5hbWUgPSB0aGlzLl9nZXRUeXBlTmFtZShyZXNvbHZlZEFyZ3NbMF1bMF0pO1xuICAgICAgICBpZiAodHlwZU5hbWUgPT09IFRZUEVfTlVNQkVSKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIHJlc29sdmVkQXJnc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICAgIHZhciBtaW5FbGVtZW50ID0gZWxlbWVudHNbMF07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoZWxlbWVudHNbaV0ubG9jYWxlQ29tcGFyZShtaW5FbGVtZW50KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgIG1pbkVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWluRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblN1bTogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICB2YXIgc3VtID0gMDtcbiAgICAgIHZhciBsaXN0VG9TdW0gPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RUb1N1bS5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdW0gKz0gbGlzdFRvU3VtW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1bTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uVHlwZTogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdKSkge1xuICAgICAgICAgIGNhc2UgVFlQRV9OVU1CRVI6XG4gICAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgICAgICBjYXNlIFRZUEVfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgICAgY2FzZSBUWVBFX0FSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICAgICAgICBjYXNlIFRZUEVfT0JKRUNUOlxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0XCI7XG4gICAgICAgICAgY2FzZSBUWVBFX0JPT0xFQU46XG4gICAgICAgICAgICByZXR1cm4gXCJib29sZWFuXCI7XG4gICAgICAgICAgY2FzZSBUWVBFX0VYUFJFRjpcbiAgICAgICAgICAgIHJldHVybiBcImV4cHJlZlwiO1xuICAgICAgICAgIGNhc2UgVFlQRV9OVUxMOlxuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbktleXM6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uVmFsdWVzOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIG9iaiA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2gob2JqW2tleXNbaV1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25Kb2luOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIGpvaW5DaGFyID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICB2YXIgbGlzdEpvaW4gPSByZXNvbHZlZEFyZ3NbMV07XG4gICAgICAgIHJldHVybiBsaXN0Sm9pbi5qb2luKGpvaW5DaGFyKTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uVG9BcnJheTogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLl9nZXRUeXBlTmFtZShyZXNvbHZlZEFyZ3NbMF0pID09PSBUWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtyZXNvbHZlZEFyZ3NbMF1dO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblRvU3RyaW5nOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX2dldFR5cGVOYW1lKHJlc29sdmVkQXJnc1swXSkgPT09IFRZUEVfU1RSSU5HKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc29sdmVkQXJnc1swXSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uVG9OdW1iZXI6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgdHlwZU5hbWUgPSB0aGlzLl9nZXRUeXBlTmFtZShyZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICB2YXIgY29udmVydGVkVmFsdWU7XG4gICAgICAgIGlmICh0eXBlTmFtZSA9PT0gVFlQRV9OVU1CRVIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZEFyZ3NbMF07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZU5hbWUgPT09IFRZUEVfU1RSSU5HKSB7XG4gICAgICAgICAgICBjb252ZXJ0ZWRWYWx1ZSA9ICtyZXNvbHZlZEFyZ3NbMF07XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGNvbnZlcnRlZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0ZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uTm90TnVsbDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzb2x2ZWRBcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzW2ldKSAhPT0gVFlQRV9OVUxMKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQXJnc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uU29ydDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHZhciBzb3J0ZWRBcnJheSA9IHJlc29sdmVkQXJnc1swXS5zbGljZSgwKTtcbiAgICAgICAgc29ydGVkQXJyYXkuc29ydCgpO1xuICAgICAgICByZXR1cm4gc29ydGVkQXJyYXk7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblNvcnRCeTogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHZhciBzb3J0ZWRBcnJheSA9IHJlc29sdmVkQXJnc1swXS5zbGljZSgwKTtcbiAgICAgICAgaWYgKHNvcnRlZEFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRlZEFycmF5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnRlcnByZXRlciA9IHRoaXMuX2ludGVycHJldGVyO1xuICAgICAgICB2YXIgZXhwcmVmTm9kZSA9IHJlc29sdmVkQXJnc1sxXTtcbiAgICAgICAgdmFyIHJlcXVpcmVkVHlwZSA9IHRoaXMuX2dldFR5cGVOYW1lKFxuICAgICAgICAgICAgaW50ZXJwcmV0ZXIudmlzaXQoZXhwcmVmTm9kZSwgc29ydGVkQXJyYXlbMF0pKTtcbiAgICAgICAgaWYgKFtUWVBFX05VTUJFUiwgVFlQRV9TVFJJTkddLmluZGV4T2YocmVxdWlyZWRUeXBlKSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGVFcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIC8vIEluIG9yZGVyIHRvIGdldCBhIHN0YWJsZSBzb3J0IG91dCBvZiBhbiB1bnN0YWJsZVxuICAgICAgICAvLyBzb3J0IGFsZ29yaXRobSwgd2UgZGVjb3JhdGUvc29ydC91bmRlY29yYXRlIChEU1UpXG4gICAgICAgIC8vIGJ5IGNyZWF0aW5nIGEgbmV3IGxpc3Qgb2YgW2luZGV4LCBlbGVtZW50XSBwYWlycy5cbiAgICAgICAgLy8gSW4gdGhlIGNtcCBmdW5jdGlvbiwgaWYgdGhlIGV2YWx1YXRlZCBlbGVtZW50cyBhcmVcbiAgICAgICAgLy8gZXF1YWwsIHRoZW4gdGhlIGluZGV4IHdpbGwgYmUgdXNlZCBhcyB0aGUgdGllYnJlYWtlci5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlIGRlY29yYXRlZCBsaXN0IGhhcyBiZWVuIHNvcnRlZCwgaXQgd2lsbCBiZVxuICAgICAgICAvLyB1bmRlY29yYXRlZCB0byBleHRyYWN0IHRoZSBvcmlnaW5hbCBlbGVtZW50cy5cbiAgICAgICAgdmFyIGRlY29yYXRlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvcnRlZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZGVjb3JhdGVkLnB1c2goW2ksIHNvcnRlZEFycmF5W2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb3JhdGVkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHZhciBleHByQSA9IGludGVycHJldGVyLnZpc2l0KGV4cHJlZk5vZGUsIGFbMV0pO1xuICAgICAgICAgIHZhciBleHByQiA9IGludGVycHJldGVyLnZpc2l0KGV4cHJlZk5vZGUsIGJbMV0pO1xuICAgICAgICAgIGlmICh0aGF0Ll9nZXRUeXBlTmFtZShleHByQSkgIT09IHJlcXVpcmVkVHlwZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlR5cGVFcnJvcjogZXhwZWN0ZWQgXCIgKyByZXF1aXJlZFR5cGUgKyBcIiwgcmVjZWl2ZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgdGhhdC5fZ2V0VHlwZU5hbWUoZXhwckEpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoYXQuX2dldFR5cGVOYW1lKGV4cHJCKSAhPT0gcmVxdWlyZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVHlwZUVycm9yOiBleHBlY3RlZCBcIiArIHJlcXVpcmVkVHlwZSArIFwiLCByZWNlaXZlZCBcIiArXG4gICAgICAgICAgICAgICAgICB0aGF0Ll9nZXRUeXBlTmFtZShleHByQikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXhwckEgPiBleHByQikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChleHByQSA8IGV4cHJCKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXkncmUgZXF1YWwgY29tcGFyZSB0aGUgaXRlbXMgYnkgdGhlaXJcbiAgICAgICAgICAgIC8vIG9yZGVyIHRvIG1haW50YWluIHJlbGF0aXZlIG9yZGVyIG9mIGVxdWFsIGtleXNcbiAgICAgICAgICAgIC8vIChpLmUuIHRvIGdldCBhIHN0YWJsZSBzb3J0KS5cbiAgICAgICAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBVbmRlY29yYXRlOiBleHRyYWN0IG91dCB0aGUgb3JpZ2luYWwgbGlzdCBlbGVtZW50cy5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkZWNvcmF0ZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzb3J0ZWRBcnJheVtqXSA9IGRlY29yYXRlZFtqXVsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc29ydGVkQXJyYXk7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1heEJ5OiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgIHZhciBleHByZWZOb2RlID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgdmFyIHJlc29sdmVkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICB2YXIga2V5RnVuY3Rpb24gPSB0aGlzLmNyZWF0ZUtleUZ1bmN0aW9uKGV4cHJlZk5vZGUsIFtUWVBFX05VTUJFUiwgVFlQRV9TVFJJTkddKTtcbiAgICAgIHZhciBtYXhOdW1iZXIgPSAtSW5maW5pdHk7XG4gICAgICB2YXIgbWF4UmVjb3JkO1xuICAgICAgdmFyIGN1cnJlbnQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc29sdmVkQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VycmVudCA9IGtleUZ1bmN0aW9uKHJlc29sdmVkQXJyYXlbaV0pO1xuICAgICAgICBpZiAoY3VycmVudCA+IG1heE51bWJlcikge1xuICAgICAgICAgIG1heE51bWJlciA9IGN1cnJlbnQ7XG4gICAgICAgICAgbWF4UmVjb3JkID0gcmVzb2x2ZWRBcnJheVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1heFJlY29yZDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uTWluQnk6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIGV4cHJlZk5vZGUgPSByZXNvbHZlZEFyZ3NbMV07XG4gICAgICB2YXIgcmVzb2x2ZWRBcnJheSA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgIHZhciBrZXlGdW5jdGlvbiA9IHRoaXMuY3JlYXRlS2V5RnVuY3Rpb24oZXhwcmVmTm9kZSwgW1RZUEVfTlVNQkVSLCBUWVBFX1NUUklOR10pO1xuICAgICAgdmFyIG1pbk51bWJlciA9IEluZmluaXR5O1xuICAgICAgdmFyIG1pblJlY29yZDtcbiAgICAgIHZhciBjdXJyZW50O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvbHZlZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnQgPSBrZXlGdW5jdGlvbihyZXNvbHZlZEFycmF5W2ldKTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPCBtaW5OdW1iZXIpIHtcbiAgICAgICAgICBtaW5OdW1iZXIgPSBjdXJyZW50O1xuICAgICAgICAgIG1pblJlY29yZCA9IHJlc29sdmVkQXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtaW5SZWNvcmQ7XG4gICAgfSxcblxuICAgIGNyZWF0ZUtleUZ1bmN0aW9uOiBmdW5jdGlvbihleHByZWZOb2RlLCBhbGxvd2VkVHlwZXMpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBpbnRlcnByZXRlciA9IHRoaXMuX2ludGVycHJldGVyO1xuICAgICAgdmFyIGtleUZ1bmMgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gaW50ZXJwcmV0ZXIudmlzaXQoZXhwcmVmTm9kZSwgeCk7XG4gICAgICAgIGlmIChhbGxvd2VkVHlwZXMuaW5kZXhPZih0aGF0Ll9nZXRUeXBlTmFtZShjdXJyZW50KSkgPCAwKSB7XG4gICAgICAgICAgdmFyIG1zZyA9IFwiVHlwZUVycm9yOiBleHBlY3RlZCBvbmUgb2YgXCIgKyBhbGxvd2VkVHlwZXMgK1xuICAgICAgICAgICAgICAgICAgICBcIiwgcmVjZWl2ZWQgXCIgKyB0aGF0Ll9nZXRUeXBlTmFtZShjdXJyZW50KTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ga2V5RnVuYztcbiAgICB9XG5cbiAgfTtcblxuICBmdW5jdGlvbiBjb21waWxlKHN0cmVhbSkge1xuICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKCk7XG4gICAgdmFyIGFzdCA9IHBhcnNlci5wYXJzZShzdHJlYW0pO1xuICAgIHJldHVybiBhc3Q7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbml6ZShzdHJlYW0pIHtcbiAgICAgIHZhciBsZXhlciA9IG5ldyBMZXhlcigpO1xuICAgICAgcmV0dXJuIGxleGVyLnRva2VuaXplKHN0cmVhbSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWFyY2goZGF0YSwgZXhwcmVzc2lvbikge1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIoKTtcbiAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgaW1wcm92ZWQuICBCb3RoIHRoZSBpbnRlcnByZXRlciBhbmQgcnVudGltZSBkZXBlbmQgb25cbiAgICAgIC8vIGVhY2ggb3RoZXIuICBUaGUgcnVudGltZSBuZWVkcyB0aGUgaW50ZXJwcmV0ZXIgdG8gc3VwcG9ydCBleHByZWZzLlxuICAgICAgLy8gVGhlcmUncyBsaWtlbHkgYSBjbGVhbiB3YXkgdG8gYXZvaWQgdGhlIGN5Y2xpYyBkZXBlbmRlbmN5LlxuICAgICAgdmFyIHJ1bnRpbWUgPSBuZXcgUnVudGltZSgpO1xuICAgICAgdmFyIGludGVycHJldGVyID0gbmV3IFRyZWVJbnRlcnByZXRlcihydW50aW1lKTtcbiAgICAgIHJ1bnRpbWUuX2ludGVycHJldGVyID0gaW50ZXJwcmV0ZXI7XG4gICAgICB2YXIgbm9kZSA9IHBhcnNlci5wYXJzZShleHByZXNzaW9uKTtcbiAgICAgIHJldHVybiBpbnRlcnByZXRlci5zZWFyY2gobm9kZSwgZGF0YSk7XG4gIH1cblxuICBleHBvcnRzLnRva2VuaXplID0gdG9rZW5pemU7XG4gIGV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGU7XG4gIGV4cG9ydHMuc2VhcmNoID0gc2VhcmNoO1xuICBleHBvcnRzLnN0cmljdERlZXBFcXVhbCA9IHN0cmljdERlZXBFcXVhbDtcbn0pKHR5cGVvZiBleHBvcnRzID09PSBcInVuZGVmaW5lZFwiID8gdGhpcy5qbWVzcGF0aCA9IHt9IDogZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/.pnpm/jmespath@0.16.0/node_modules/jmespath/jmespath.js\n')},"../../node_modules/.pnpm/js-md5@0.7.3/node_modules/js-md5/src/md5.js":(module,exports,__webpack_require__)=>{eval("/* provided dependency */ var process = __webpack_require__(\"../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\");\nvar __WEBPACK_AMD_DEFINE_RESULT__;/**\n * [js-md5]{@link https://github.com/emn178/js-md5}\n *\n * @namespace md5\n * @version 0.7.3\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2017\n * @license MIT\n */\n(function () {\n  'use strict';\n\n  var ERROR = 'input is invalid type';\n  var WINDOW = typeof window === 'object';\n  var root = WINDOW ? window : {};\n  if (root.JS_MD5_NO_WINDOW) {\n    WINDOW = false;\n  }\n  var WEB_WORKER = !WINDOW && typeof self === 'object';\n  var NODE_JS = !root.JS_MD5_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n  if (NODE_JS) {\n    root = __webpack_require__.g;\n  } else if (WEB_WORKER) {\n    root = self;\n  }\n  var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && \"object\" === 'object' && module.exports;\n  var AMD =  true && __webpack_require__.amdO;\n  var ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n  var HEX_CHARS = '0123456789abcdef'.split('');\n  var EXTRA = [128, 32768, 8388608, -2147483648];\n  var SHIFT = [0, 8, 16, 24];\n  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'buffer', 'arrayBuffer', 'base64'];\n  var BASE64_ENCODE_CHAR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n  var blocks = [], buffer8;\n  if (ARRAY_BUFFER) {\n    var buffer = new ArrayBuffer(68);\n    buffer8 = new Uint8Array(buffer);\n    blocks = new Uint32Array(buffer);\n  }\n\n  if (root.JS_MD5_NO_NODE_JS || !Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  if (ARRAY_BUFFER && (root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n    ArrayBuffer.isView = function (obj) {\n      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n    };\n  }\n\n  /**\n   * @method hex\n   * @memberof md5\n   * @description Output hash as hex string\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {String} Hex string\n   * @example\n   * md5.hex('The quick brown fox jumps over the lazy dog');\n   * // equal to\n   * md5('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method digest\n   * @memberof md5\n   * @description Output hash as bytes array\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Array} Bytes array\n   * @example\n   * md5.digest('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method array\n   * @memberof md5\n   * @description Output hash as bytes array\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Array} Bytes array\n   * @example\n   * md5.array('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method arrayBuffer\n   * @memberof md5\n   * @description Output hash as ArrayBuffer\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @example\n   * md5.arrayBuffer('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method buffer\n   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.\n   * @memberof md5\n   * @description Output hash as ArrayBuffer\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @example\n   * md5.buffer('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method base64\n   * @memberof md5\n   * @description Output hash as base64 string\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {String} base64 string\n   * @example\n   * md5.base64('The quick brown fox jumps over the lazy dog');\n   */\n  var createOutputMethod = function (outputType) {\n    return function (message) {\n      return new Md5(true).update(message)[outputType]();\n    };\n  };\n\n  /**\n   * @method create\n   * @memberof md5\n   * @description Create Md5 object\n   * @returns {Md5} Md5 object.\n   * @example\n   * var hash = md5.create();\n   */\n  /**\n   * @method update\n   * @memberof md5\n   * @description Create and update Md5 object\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Md5} Md5 object.\n   * @example\n   * var hash = md5.update('The quick brown fox jumps over the lazy dog');\n   * // equal to\n   * var hash = md5.create();\n   * hash.update('The quick brown fox jumps over the lazy dog');\n   */\n  var createMethod = function () {\n    var method = createOutputMethod('hex');\n    if (NODE_JS) {\n      method = nodeWrap(method);\n    }\n    method.create = function () {\n      return new Md5();\n    };\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createOutputMethod(type);\n    }\n    return method;\n  };\n\n  var nodeWrap = function (method) {\n    var crypto = eval(\"require('crypto')\");\n    var Buffer = eval(\"require('buffer').Buffer\");\n    var nodeMethod = function (message) {\n      if (typeof message === 'string') {\n        return crypto.createHash('md5').update(message, 'utf8').digest('hex');\n      } else {\n        if (message === null || message === undefined) {\n          throw ERROR;\n        } else if (message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        }\n      }\n      if (Array.isArray(message) || ArrayBuffer.isView(message) ||\n        message.constructor === Buffer) {\n        return crypto.createHash('md5').update(new Buffer(message)).digest('hex');\n      } else {\n        return method(message);\n      }\n    };\n    return nodeMethod;\n  };\n\n  /**\n   * Md5 class\n   * @class Md5\n   * @description This is internal class.\n   * @see {@link md5.create}\n   */\n  function Md5(sharedMemory) {\n    if (sharedMemory) {\n      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n      blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n      blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      this.blocks = blocks;\n      this.buffer8 = buffer8;\n    } else {\n      if (ARRAY_BUFFER) {\n        var buffer = new ArrayBuffer(68);\n        this.buffer8 = new Uint8Array(buffer);\n        this.blocks = new Uint32Array(buffer);\n      } else {\n        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n      }\n    }\n    this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n  }\n\n  /**\n   * @method update\n   * @memberof Md5\n   * @instance\n   * @description Update hash\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Md5} Md5 object.\n   * @see {@link md5.update}\n   */\n  Md5.prototype.update = function (message) {\n    if (this.finalized) {\n      return;\n    }\n\n    var notString, type = typeof message;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (message === null) {\n          throw ERROR;\n        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        } else if (!Array.isArray(message)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n            throw ERROR;\n          }\n        }\n      } else {\n        throw ERROR;\n      }\n      notString = true;\n    }\n    var code, index = 0, i, length = message.length, blocks = this.blocks;\n    var buffer8 = this.buffer8;\n\n    while (index < length) {\n      if (this.hashed) {\n        this.hashed = false;\n        blocks[0] = blocks[16];\n        blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n        blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n        blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      }\n\n      if (notString) {\n        if (ARRAY_BUFFER) {\n          for (i = this.start; index < length && i < 64; ++index) {\n            buffer8[i++] = message[index];\n          }\n        } else {\n          for (i = this.start; index < length && i < 64; ++index) {\n            blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n          }\n        }\n      } else {\n        if (ARRAY_BUFFER) {\n          for (i = this.start; index < length && i < 64; ++index) {\n            code = message.charCodeAt(index);\n            if (code < 0x80) {\n              buffer8[i++] = code;\n            } else if (code < 0x800) {\n              buffer8[i++] = 0xc0 | (code >> 6);\n              buffer8[i++] = 0x80 | (code & 0x3f);\n            } else if (code < 0xd800 || code >= 0xe000) {\n              buffer8[i++] = 0xe0 | (code >> 12);\n              buffer8[i++] = 0x80 | ((code >> 6) & 0x3f);\n              buffer8[i++] = 0x80 | (code & 0x3f);\n            } else {\n              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n              buffer8[i++] = 0xf0 | (code >> 18);\n              buffer8[i++] = 0x80 | ((code >> 12) & 0x3f);\n              buffer8[i++] = 0x80 | ((code >> 6) & 0x3f);\n              buffer8[i++] = 0x80 | (code & 0x3f);\n            }\n          }\n        } else {\n          for (i = this.start; index < length && i < 64; ++index) {\n            code = message.charCodeAt(index);\n            if (code < 0x80) {\n              blocks[i >> 2] |= code << SHIFT[i++ & 3];\n            } else if (code < 0x800) {\n              blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n            } else if (code < 0xd800 || code >= 0xe000) {\n              blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n            } else {\n              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n              blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n            }\n          }\n        }\n      }\n      this.lastByteIndex = i;\n      this.bytes += i - this.start;\n      if (i >= 64) {\n        this.start = i - 64;\n        this.hash();\n        this.hashed = true;\n      } else {\n        this.start = i;\n      }\n    }\n    if (this.bytes > 4294967295) {\n      this.hBytes += this.bytes / 4294967296 << 0;\n      this.bytes = this.bytes % 4294967296;\n    }\n    return this;\n  };\n\n  Md5.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex;\n    blocks[i >> 2] |= EXTRA[i & 3];\n    if (i >= 56) {\n      if (!this.hashed) {\n        this.hash();\n      }\n      blocks[0] = blocks[16];\n      blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n      blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n      blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n    }\n    blocks[14] = this.bytes << 3;\n    blocks[15] = this.hBytes << 3 | this.bytes >>> 29;\n    this.hash();\n  };\n\n  Md5.prototype.hash = function () {\n    var a, b, c, d, bc, da, blocks = this.blocks;\n\n    if (this.first) {\n      a = blocks[0] - 680876937;\n      a = (a << 7 | a >>> 25) - 271733879 << 0;\n      d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;\n      d = (d << 12 | d >>> 20) + a << 0;\n      c = (-271733879 ^ (d & (a ^ -271733879))) + blocks[2] - 1126478375;\n      c = (c << 17 | c >>> 15) + d << 0;\n      b = (a ^ (c & (d ^ a))) + blocks[3] - 1316259209;\n      b = (b << 22 | b >>> 10) + c << 0;\n    } else {\n      a = this.h0;\n      b = this.h1;\n      c = this.h2;\n      d = this.h3;\n      a += (d ^ (b & (c ^ d))) + blocks[0] - 680876936;\n      a = (a << 7 | a >>> 25) + b << 0;\n      d += (c ^ (a & (b ^ c))) + blocks[1] - 389564586;\n      d = (d << 12 | d >>> 20) + a << 0;\n      c += (b ^ (d & (a ^ b))) + blocks[2] + 606105819;\n      c = (c << 17 | c >>> 15) + d << 0;\n      b += (a ^ (c & (d ^ a))) + blocks[3] - 1044525330;\n      b = (b << 22 | b >>> 10) + c << 0;\n    }\n\n    a += (d ^ (b & (c ^ d))) + blocks[4] - 176418897;\n    a = (a << 7 | a >>> 25) + b << 0;\n    d += (c ^ (a & (b ^ c))) + blocks[5] + 1200080426;\n    d = (d << 12 | d >>> 20) + a << 0;\n    c += (b ^ (d & (a ^ b))) + blocks[6] - 1473231341;\n    c = (c << 17 | c >>> 15) + d << 0;\n    b += (a ^ (c & (d ^ a))) + blocks[7] - 45705983;\n    b = (b << 22 | b >>> 10) + c << 0;\n    a += (d ^ (b & (c ^ d))) + blocks[8] + 1770035416;\n    a = (a << 7 | a >>> 25) + b << 0;\n    d += (c ^ (a & (b ^ c))) + blocks[9] - 1958414417;\n    d = (d << 12 | d >>> 20) + a << 0;\n    c += (b ^ (d & (a ^ b))) + blocks[10] - 42063;\n    c = (c << 17 | c >>> 15) + d << 0;\n    b += (a ^ (c & (d ^ a))) + blocks[11] - 1990404162;\n    b = (b << 22 | b >>> 10) + c << 0;\n    a += (d ^ (b & (c ^ d))) + blocks[12] + 1804603682;\n    a = (a << 7 | a >>> 25) + b << 0;\n    d += (c ^ (a & (b ^ c))) + blocks[13] - 40341101;\n    d = (d << 12 | d >>> 20) + a << 0;\n    c += (b ^ (d & (a ^ b))) + blocks[14] - 1502002290;\n    c = (c << 17 | c >>> 15) + d << 0;\n    b += (a ^ (c & (d ^ a))) + blocks[15] + 1236535329;\n    b = (b << 22 | b >>> 10) + c << 0;\n    a += (c ^ (d & (b ^ c))) + blocks[1] - 165796510;\n    a = (a << 5 | a >>> 27) + b << 0;\n    d += (b ^ (c & (a ^ b))) + blocks[6] - 1069501632;\n    d = (d << 9 | d >>> 23) + a << 0;\n    c += (a ^ (b & (d ^ a))) + blocks[11] + 643717713;\n    c = (c << 14 | c >>> 18) + d << 0;\n    b += (d ^ (a & (c ^ d))) + blocks[0] - 373897302;\n    b = (b << 20 | b >>> 12) + c << 0;\n    a += (c ^ (d & (b ^ c))) + blocks[5] - 701558691;\n    a = (a << 5 | a >>> 27) + b << 0;\n    d += (b ^ (c & (a ^ b))) + blocks[10] + 38016083;\n    d = (d << 9 | d >>> 23) + a << 0;\n    c += (a ^ (b & (d ^ a))) + blocks[15] - 660478335;\n    c = (c << 14 | c >>> 18) + d << 0;\n    b += (d ^ (a & (c ^ d))) + blocks[4] - 405537848;\n    b = (b << 20 | b >>> 12) + c << 0;\n    a += (c ^ (d & (b ^ c))) + blocks[9] + 568446438;\n    a = (a << 5 | a >>> 27) + b << 0;\n    d += (b ^ (c & (a ^ b))) + blocks[14] - 1019803690;\n    d = (d << 9 | d >>> 23) + a << 0;\n    c += (a ^ (b & (d ^ a))) + blocks[3] - 187363961;\n    c = (c << 14 | c >>> 18) + d << 0;\n    b += (d ^ (a & (c ^ d))) + blocks[8] + 1163531501;\n    b = (b << 20 | b >>> 12) + c << 0;\n    a += (c ^ (d & (b ^ c))) + blocks[13] - 1444681467;\n    a = (a << 5 | a >>> 27) + b << 0;\n    d += (b ^ (c & (a ^ b))) + blocks[2] - 51403784;\n    d = (d << 9 | d >>> 23) + a << 0;\n    c += (a ^ (b & (d ^ a))) + blocks[7] + 1735328473;\n    c = (c << 14 | c >>> 18) + d << 0;\n    b += (d ^ (a & (c ^ d))) + blocks[12] - 1926607734;\n    b = (b << 20 | b >>> 12) + c << 0;\n    bc = b ^ c;\n    a += (bc ^ d) + blocks[5] - 378558;\n    a = (a << 4 | a >>> 28) + b << 0;\n    d += (bc ^ a) + blocks[8] - 2022574463;\n    d = (d << 11 | d >>> 21) + a << 0;\n    da = d ^ a;\n    c += (da ^ b) + blocks[11] + 1839030562;\n    c = (c << 16 | c >>> 16) + d << 0;\n    b += (da ^ c) + blocks[14] - 35309556;\n    b = (b << 23 | b >>> 9) + c << 0;\n    bc = b ^ c;\n    a += (bc ^ d) + blocks[1] - 1530992060;\n    a = (a << 4 | a >>> 28) + b << 0;\n    d += (bc ^ a) + blocks[4] + 1272893353;\n    d = (d << 11 | d >>> 21) + a << 0;\n    da = d ^ a;\n    c += (da ^ b) + blocks[7] - 155497632;\n    c = (c << 16 | c >>> 16) + d << 0;\n    b += (da ^ c) + blocks[10] - 1094730640;\n    b = (b << 23 | b >>> 9) + c << 0;\n    bc = b ^ c;\n    a += (bc ^ d) + blocks[13] + 681279174;\n    a = (a << 4 | a >>> 28) + b << 0;\n    d += (bc ^ a) + blocks[0] - 358537222;\n    d = (d << 11 | d >>> 21) + a << 0;\n    da = d ^ a;\n    c += (da ^ b) + blocks[3] - 722521979;\n    c = (c << 16 | c >>> 16) + d << 0;\n    b += (da ^ c) + blocks[6] + 76029189;\n    b = (b << 23 | b >>> 9) + c << 0;\n    bc = b ^ c;\n    a += (bc ^ d) + blocks[9] - 640364487;\n    a = (a << 4 | a >>> 28) + b << 0;\n    d += (bc ^ a) + blocks[12] - 421815835;\n    d = (d << 11 | d >>> 21) + a << 0;\n    da = d ^ a;\n    c += (da ^ b) + blocks[15] + 530742520;\n    c = (c << 16 | c >>> 16) + d << 0;\n    b += (da ^ c) + blocks[2] - 995338651;\n    b = (b << 23 | b >>> 9) + c << 0;\n    a += (c ^ (b | ~d)) + blocks[0] - 198630844;\n    a = (a << 6 | a >>> 26) + b << 0;\n    d += (b ^ (a | ~c)) + blocks[7] + 1126891415;\n    d = (d << 10 | d >>> 22) + a << 0;\n    c += (a ^ (d | ~b)) + blocks[14] - 1416354905;\n    c = (c << 15 | c >>> 17) + d << 0;\n    b += (d ^ (c | ~a)) + blocks[5] - 57434055;\n    b = (b << 21 | b >>> 11) + c << 0;\n    a += (c ^ (b | ~d)) + blocks[12] + 1700485571;\n    a = (a << 6 | a >>> 26) + b << 0;\n    d += (b ^ (a | ~c)) + blocks[3] - 1894986606;\n    d = (d << 10 | d >>> 22) + a << 0;\n    c += (a ^ (d | ~b)) + blocks[10] - 1051523;\n    c = (c << 15 | c >>> 17) + d << 0;\n    b += (d ^ (c | ~a)) + blocks[1] - 2054922799;\n    b = (b << 21 | b >>> 11) + c << 0;\n    a += (c ^ (b | ~d)) + blocks[8] + 1873313359;\n    a = (a << 6 | a >>> 26) + b << 0;\n    d += (b ^ (a | ~c)) + blocks[15] - 30611744;\n    d = (d << 10 | d >>> 22) + a << 0;\n    c += (a ^ (d | ~b)) + blocks[6] - 1560198380;\n    c = (c << 15 | c >>> 17) + d << 0;\n    b += (d ^ (c | ~a)) + blocks[13] + 1309151649;\n    b = (b << 21 | b >>> 11) + c << 0;\n    a += (c ^ (b | ~d)) + blocks[4] - 145523070;\n    a = (a << 6 | a >>> 26) + b << 0;\n    d += (b ^ (a | ~c)) + blocks[11] - 1120210379;\n    d = (d << 10 | d >>> 22) + a << 0;\n    c += (a ^ (d | ~b)) + blocks[2] + 718787259;\n    c = (c << 15 | c >>> 17) + d << 0;\n    b += (d ^ (c | ~a)) + blocks[9] - 343485551;\n    b = (b << 21 | b >>> 11) + c << 0;\n\n    if (this.first) {\n      this.h0 = a + 1732584193 << 0;\n      this.h1 = b - 271733879 << 0;\n      this.h2 = c - 1732584194 << 0;\n      this.h3 = d + 271733878 << 0;\n      this.first = false;\n    } else {\n      this.h0 = this.h0 + a << 0;\n      this.h1 = this.h1 + b << 0;\n      this.h2 = this.h2 + c << 0;\n      this.h3 = this.h3 + d << 0;\n    }\n  };\n\n  /**\n   * @method hex\n   * @memberof Md5\n   * @instance\n   * @description Output hash as hex string\n   * @returns {String} Hex string\n   * @see {@link md5.hex}\n   * @example\n   * hash.hex();\n   */\n  Md5.prototype.hex = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;\n\n    return HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +\n      HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +\n      HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +\n      HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +\n      HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +\n      HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +\n      HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +\n      HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +\n      HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +\n      HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +\n      HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +\n      HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +\n      HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +\n      HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +\n      HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +\n      HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F];\n  };\n\n  /**\n   * @method toString\n   * @memberof Md5\n   * @instance\n   * @description Output hash as hex string\n   * @returns {String} Hex string\n   * @see {@link md5.hex}\n   * @example\n   * hash.toString();\n   */\n  Md5.prototype.toString = Md5.prototype.hex;\n\n  /**\n   * @method digest\n   * @memberof Md5\n   * @instance\n   * @description Output hash as bytes array\n   * @returns {Array} Bytes array\n   * @see {@link md5.digest}\n   * @example\n   * hash.digest();\n   */\n  Md5.prototype.digest = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;\n    return [\n      h0 & 0xFF, (h0 >> 8) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 24) & 0xFF,\n      h1 & 0xFF, (h1 >> 8) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 24) & 0xFF,\n      h2 & 0xFF, (h2 >> 8) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 24) & 0xFF,\n      h3 & 0xFF, (h3 >> 8) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 24) & 0xFF\n    ];\n  };\n\n  /**\n   * @method array\n   * @memberof Md5\n   * @instance\n   * @description Output hash as bytes array\n   * @returns {Array} Bytes array\n   * @see {@link md5.array}\n   * @example\n   * hash.array();\n   */\n  Md5.prototype.array = Md5.prototype.digest;\n\n  /**\n   * @method arrayBuffer\n   * @memberof Md5\n   * @instance\n   * @description Output hash as ArrayBuffer\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @see {@link md5.arrayBuffer}\n   * @example\n   * hash.arrayBuffer();\n   */\n  Md5.prototype.arrayBuffer = function () {\n    this.finalize();\n\n    var buffer = new ArrayBuffer(16);\n    var blocks = new Uint32Array(buffer);\n    blocks[0] = this.h0;\n    blocks[1] = this.h1;\n    blocks[2] = this.h2;\n    blocks[3] = this.h3;\n    return buffer;\n  };\n\n  /**\n   * @method buffer\n   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.\n   * @memberof Md5\n   * @instance\n   * @description Output hash as ArrayBuffer\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @see {@link md5.buffer}\n   * @example\n   * hash.buffer();\n   */\n  Md5.prototype.buffer = Md5.prototype.arrayBuffer;\n\n  /**\n   * @method base64\n   * @memberof Md5\n   * @instance\n   * @description Output hash as base64 string\n   * @returns {String} base64 string\n   * @see {@link md5.base64}\n   * @example\n   * hash.base64();\n   */\n  Md5.prototype.base64 = function () {\n    var v1, v2, v3, base64Str = '', bytes = this.array();\n    for (var i = 0; i < 15;) {\n      v1 = bytes[i++];\n      v2 = bytes[i++];\n      v3 = bytes[i++];\n      base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] +\n        BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] +\n        BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] +\n        BASE64_ENCODE_CHAR[v3 & 63];\n    }\n    v1 = bytes[i];\n    base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] +\n      BASE64_ENCODE_CHAR[(v1 << 4) & 63] +\n      '==';\n    return base64Str;\n  };\n\n  var exports = createMethod();\n\n  if (COMMON_JS) {\n    module.exports = exports;\n  } else {\n    /**\n     * @method md5\b\n     * @description Md5 hash function, export to global in browsers.\n     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n     * @returns {String} md5 hashes\n     * @example\n     * md5(''); // d41d8cd98f00b204e9800998ecf8427e\n     * md5('The quick brown fox jumps over the lazy dog'); // 9e107d9d372bb6826bd81d3542a419d6\n     * md5('The quick brown fox jumps over the lazy dog.'); // e4d909c290d0fb1ca068ffaddf22cbd0\n     *\n     * // It also supports UTF-8 encoding\n     * md5('中文'); // a7bac2239fcdcb3a067903d8077c4a07\n     *\n     * // It also supports byte `Array`, `Uint8Array`, `ArrayBuffer`\n     * md5([]); // d41d8cd98f00b204e9800998ecf8427e\n     * md5(new Uint8Array([])); // d41d8cd98f00b204e9800998ecf8427e\n     */\n    root.md5 = exports;\n    if (AMD) {\n      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n        return exports;\n      }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n  }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2pzLW1kNUAwLjcuMy9ub2RlX21vZHVsZXMvanMtbWQ1L3NyYy9tZDUuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPLGlCQUFpQixPQUFPLGFBQWEsT0FBTztBQUNyRztBQUNBLFdBQVcscUJBQU07QUFDakIsSUFBSTtBQUNKO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBYTtBQUM1RCxZQUFZLEtBQTRCLElBQUksd0JBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFDQUFxQztBQUNsRCxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFDQUFxQztBQUNsRCxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFDQUFxQztBQUNsRCxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xELGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQsZUFBZSxLQUFLO0FBQ3BCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0EsVUFBVTtBQUNWLCtCQUErQiwwQkFBMEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQztBQUNwRCxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLGdCQUFnQjtBQUNoQiwyREFBMkQ7QUFDM0QsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtQ0FBTztBQUNiO0FBQ0EsT0FBTztBQUFBLGtHQUFDO0FBQ1I7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWl0by1mb3Jtcy9idWxtYS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vanMtbWQ1QDAuNy4zL25vZGVfbW9kdWxlcy9qcy1tZDUvc3JjL21kNS5qcz8yZDVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogW2pzLW1kNV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1tZDV9XG4gKlxuICogQG5hbWVzcGFjZSBtZDVcbiAqIEB2ZXJzaW9uIDAuNy4zXG4gKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXVxuICogQGNvcHlyaWdodCBDaGVuLCBZaS1DeXVhbiAyMDE0LTIwMTdcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4oZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIEVSUk9SID0gJ2lucHV0IGlzIGludmFsaWQgdHlwZSc7XG4gIHZhciBXSU5ET1cgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JztcbiAgdmFyIHJvb3QgPSBXSU5ET1cgPyB3aW5kb3cgOiB7fTtcbiAgaWYgKHJvb3QuSlNfTUQ1X05PX1dJTkRPVykge1xuICAgIFdJTkRPVyA9IGZhbHNlO1xuICB9XG4gIHZhciBXRUJfV09SS0VSID0gIVdJTkRPVyAmJiB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCc7XG4gIHZhciBOT0RFX0pTID0gIXJvb3QuSlNfTUQ1X05PX05PREVfSlMgJiYgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO1xuICBpZiAoTk9ERV9KUykge1xuICAgIHJvb3QgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAoV0VCX1dPUktFUikge1xuICAgIHJvb3QgPSBzZWxmO1xuICB9XG4gIHZhciBDT01NT05fSlMgPSAhcm9vdC5KU19NRDVfTk9fQ09NTU9OX0pTICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzO1xuICB2YXIgQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kO1xuICB2YXIgQVJSQVlfQlVGRkVSID0gIXJvb3QuSlNfTUQ1X05PX0FSUkFZX0JVRkZFUiAmJiB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgSEVYX0NIQVJTID0gJzAxMjM0NTY3ODlhYmNkZWYnLnNwbGl0KCcnKTtcbiAgdmFyIEVYVFJBID0gWzEyOCwgMzI3NjgsIDgzODg2MDgsIC0yMTQ3NDgzNjQ4XTtcbiAgdmFyIFNISUZUID0gWzAsIDgsIDE2LCAyNF07XG4gIHZhciBPVVRQVVRfVFlQRVMgPSBbJ2hleCcsICdhcnJheScsICdkaWdlc3QnLCAnYnVmZmVyJywgJ2FycmF5QnVmZmVyJywgJ2Jhc2U2NCddO1xuICB2YXIgQkFTRTY0X0VOQ09ERV9DSEFSID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcblxuICB2YXIgYmxvY2tzID0gW10sIGJ1ZmZlcjg7XG4gIGlmIChBUlJBWV9CVUZGRVIpIHtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDY4KTtcbiAgICBidWZmZXI4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBibG9ja3MgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgfVxuXG4gIGlmIChyb290LkpTX01ENV9OT19OT0RFX0pTIHx8ICFBcnJheS5pc0FycmF5KSB7XG4gICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuICB9XG5cbiAgaWYgKEFSUkFZX0JVRkZFUiAmJiAocm9vdC5KU19NRDVfTk9fQVJSQVlfQlVGRkVSX0lTX1ZJRVcgfHwgIUFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqLmJ1ZmZlciAmJiBvYmouYnVmZmVyLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcjtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGV4XG4gICAqIEBtZW1iZXJvZiBtZDVcbiAgICogQGRlc2NyaXB0aW9uIE91dHB1dCBoYXNoIGFzIGhleCBzdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl8VWludDhBcnJheXxBcnJheUJ1ZmZlcn0gbWVzc2FnZSBtZXNzYWdlIHRvIGhhc2hcbiAgICogQHJldHVybnMge1N0cmluZ30gSGV4IHN0cmluZ1xuICAgKiBAZXhhbXBsZVxuICAgKiBtZDUuaGV4KCdUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nJyk7XG4gICAqIC8vIGVxdWFsIHRvXG4gICAqIG1kNSgnVGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZycpO1xuICAgKi9cbiAgLyoqXG4gICAqIEBtZXRob2QgZGlnZXN0XG4gICAqIEBtZW1iZXJvZiBtZDVcbiAgICogQGRlc2NyaXB0aW9uIE91dHB1dCBoYXNoIGFzIGJ5dGVzIGFycmF5XG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ9IG1lc3NhZ2UgbWVzc2FnZSB0byBoYXNoXG4gICAqIEByZXR1cm5zIHtBcnJheX0gQnl0ZXMgYXJyYXlcbiAgICogQGV4YW1wbGVcbiAgICogbWQ1LmRpZ2VzdCgnVGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZycpO1xuICAgKi9cbiAgLyoqXG4gICAqIEBtZXRob2QgYXJyYXlcbiAgICogQG1lbWJlcm9mIG1kNVxuICAgKiBAZGVzY3JpcHRpb24gT3V0cHV0IGhhc2ggYXMgYnl0ZXMgYXJyYXlcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl8VWludDhBcnJheXxBcnJheUJ1ZmZlcn0gbWVzc2FnZSBtZXNzYWdlIHRvIGhhc2hcbiAgICogQHJldHVybnMge0FycmF5fSBCeXRlcyBhcnJheVxuICAgKiBAZXhhbXBsZVxuICAgKiBtZDUuYXJyYXkoJ1RoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cnKTtcbiAgICovXG4gIC8qKlxuICAgKiBAbWV0aG9kIGFycmF5QnVmZmVyXG4gICAqIEBtZW1iZXJvZiBtZDVcbiAgICogQGRlc2NyaXB0aW9uIE91dHB1dCBoYXNoIGFzIEFycmF5QnVmZmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ9IG1lc3NhZ2UgbWVzc2FnZSB0byBoYXNoXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gQXJyYXlCdWZmZXJcbiAgICogQGV4YW1wbGVcbiAgICogbWQ1LmFycmF5QnVmZmVyKCdUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nJyk7XG4gICAqL1xuICAvKipcbiAgICogQG1ldGhvZCBidWZmZXJcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyBtYXliZSBjb25mdXNlIHdpdGggQnVmZmVyIGluIG5vZGUuanMuIFBsZWFzZSB1c2UgYXJyYXlCdWZmZXIgaW5zdGVhZC5cbiAgICogQG1lbWJlcm9mIG1kNVxuICAgKiBAZGVzY3JpcHRpb24gT3V0cHV0IGhhc2ggYXMgQXJyYXlCdWZmZXJcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl8VWludDhBcnJheXxBcnJheUJ1ZmZlcn0gbWVzc2FnZSBtZXNzYWdlIHRvIGhhc2hcbiAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBBcnJheUJ1ZmZlclxuICAgKiBAZXhhbXBsZVxuICAgKiBtZDUuYnVmZmVyKCdUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nJyk7XG4gICAqL1xuICAvKipcbiAgICogQG1ldGhvZCBiYXNlNjRcbiAgICogQG1lbWJlcm9mIG1kNVxuICAgKiBAZGVzY3JpcHRpb24gT3V0cHV0IGhhc2ggYXMgYmFzZTY0IHN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheXxVaW50OEFycmF5fEFycmF5QnVmZmVyfSBtZXNzYWdlIG1lc3NhZ2UgdG8gaGFzaFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBiYXNlNjQgc3RyaW5nXG4gICAqIEBleGFtcGxlXG4gICAqIG1kNS5iYXNlNjQoJ1RoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cnKTtcbiAgICovXG4gIHZhciBjcmVhdGVPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAob3V0cHV0VHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG5ldyBNZDUodHJ1ZSkudXBkYXRlKG1lc3NhZ2UpW291dHB1dFR5cGVdKCk7XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBjcmVhdGVcbiAgICogQG1lbWJlcm9mIG1kNVxuICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIE1kNSBvYmplY3RcbiAgICogQHJldHVybnMge01kNX0gTWQ1IG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGhhc2ggPSBtZDUuY3JlYXRlKCk7XG4gICAqL1xuICAvKipcbiAgICogQG1ldGhvZCB1cGRhdGVcbiAgICogQG1lbWJlcm9mIG1kNVxuICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGFuZCB1cGRhdGUgTWQ1IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheXxVaW50OEFycmF5fEFycmF5QnVmZmVyfSBtZXNzYWdlIG1lc3NhZ2UgdG8gaGFzaFxuICAgKiBAcmV0dXJucyB7TWQ1fSBNZDUgb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgaGFzaCA9IG1kNS51cGRhdGUoJ1RoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cnKTtcbiAgICogLy8gZXF1YWwgdG9cbiAgICogdmFyIGhhc2ggPSBtZDUuY3JlYXRlKCk7XG4gICAqIGhhc2gudXBkYXRlKCdUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nJyk7XG4gICAqL1xuICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtZXRob2QgPSBjcmVhdGVPdXRwdXRNZXRob2QoJ2hleCcpO1xuICAgIGlmIChOT0RFX0pTKSB7XG4gICAgICBtZXRob2QgPSBub2RlV3JhcChtZXRob2QpO1xuICAgIH1cbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBNZDUoKTtcbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoKS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHR5cGUgPSBPVVRQVVRfVFlQRVNbaV07XG4gICAgICBtZXRob2RbdHlwZV0gPSBjcmVhdGVPdXRwdXRNZXRob2QodHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBtZXRob2Q7XG4gIH07XG5cbiAgdmFyIG5vZGVXcmFwID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIHZhciBjcnlwdG8gPSBldmFsKFwicmVxdWlyZSgnY3J5cHRvJylcIik7XG4gICAgdmFyIEJ1ZmZlciA9IGV2YWwoXCJyZXF1aXJlKCdidWZmZXInKS5CdWZmZXJcIik7XG4gICAgdmFyIG5vZGVNZXRob2QgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ21kNScpLnVwZGF0ZShtZXNzYWdlLCAndXRmOCcpLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCB8fCBtZXNzYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBFUlJPUjtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KG1lc3NhZ2UpIHx8XG4gICAgICAgIG1lc3NhZ2UuY29uc3RydWN0b3IgPT09IEJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ21kNScpLnVwZGF0ZShuZXcgQnVmZmVyKG1lc3NhZ2UpKS5kaWdlc3QoJ2hleCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBub2RlTWV0aG9kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNZDUgY2xhc3NcbiAgICogQGNsYXNzIE1kNVxuICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBpbnRlcm5hbCBjbGFzcy5cbiAgICogQHNlZSB7QGxpbmsgbWQ1LmNyZWF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIE1kNShzaGFyZWRNZW1vcnkpIHtcbiAgICBpZiAoc2hhcmVkTWVtb3J5KSB7XG4gICAgICBibG9ja3NbMF0gPSBibG9ja3NbMTZdID0gYmxvY2tzWzFdID0gYmxvY2tzWzJdID0gYmxvY2tzWzNdID1cbiAgICAgIGJsb2Nrc1s0XSA9IGJsb2Nrc1s1XSA9IGJsb2Nrc1s2XSA9IGJsb2Nrc1s3XSA9XG4gICAgICBibG9ja3NbOF0gPSBibG9ja3NbOV0gPSBibG9ja3NbMTBdID0gYmxvY2tzWzExXSA9XG4gICAgICBibG9ja3NbMTJdID0gYmxvY2tzWzEzXSA9IGJsb2Nrc1sxNF0gPSBibG9ja3NbMTVdID0gMDtcbiAgICAgIHRoaXMuYmxvY2tzID0gYmxvY2tzO1xuICAgICAgdGhpcy5idWZmZXI4ID0gYnVmZmVyODtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFSUkFZX0JVRkZFUikge1xuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDY4KTtcbiAgICAgICAgdGhpcy5idWZmZXI4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmxvY2tzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmgwID0gdGhpcy5oMSA9IHRoaXMuaDIgPSB0aGlzLmgzID0gdGhpcy5zdGFydCA9IHRoaXMuYnl0ZXMgPSB0aGlzLmhCeXRlcyA9IDA7XG4gICAgdGhpcy5maW5hbGl6ZWQgPSB0aGlzLmhhc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuZmlyc3QgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdXBkYXRlXG4gICAqIEBtZW1iZXJvZiBNZDVcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBVcGRhdGUgaGFzaFxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheXxVaW50OEFycmF5fEFycmF5QnVmZmVyfSBtZXNzYWdlIG1lc3NhZ2UgdG8gaGFzaFxuICAgKiBAcmV0dXJucyB7TWQ1fSBNZDUgb2JqZWN0LlxuICAgKiBAc2VlIHtAbGluayBtZDUudXBkYXRlfVxuICAgKi9cbiAgTWQ1LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub3RTdHJpbmcsIHR5cGUgPSB0eXBlb2YgbWVzc2FnZTtcbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IEVSUk9SO1xuICAgICAgICB9IGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlKSkge1xuICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHRocm93IEVSUk9SO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRVJST1I7XG4gICAgICB9XG4gICAgICBub3RTdHJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgY29kZSwgaW5kZXggPSAwLCBpLCBsZW5ndGggPSBtZXNzYWdlLmxlbmd0aCwgYmxvY2tzID0gdGhpcy5ibG9ja3M7XG4gICAgdmFyIGJ1ZmZlcjggPSB0aGlzLmJ1ZmZlcjg7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLmhhc2hlZCkge1xuICAgICAgICB0aGlzLmhhc2hlZCA9IGZhbHNlO1xuICAgICAgICBibG9ja3NbMF0gPSBibG9ja3NbMTZdO1xuICAgICAgICBibG9ja3NbMTZdID0gYmxvY2tzWzFdID0gYmxvY2tzWzJdID0gYmxvY2tzWzNdID1cbiAgICAgICAgYmxvY2tzWzRdID0gYmxvY2tzWzVdID0gYmxvY2tzWzZdID0gYmxvY2tzWzddID1cbiAgICAgICAgYmxvY2tzWzhdID0gYmxvY2tzWzldID0gYmxvY2tzWzEwXSA9IGJsb2Nrc1sxMV0gPVxuICAgICAgICBibG9ja3NbMTJdID0gYmxvY2tzWzEzXSA9IGJsb2Nrc1sxNF0gPSBibG9ja3NbMTVdID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vdFN0cmluZykge1xuICAgICAgICBpZiAoQVJSQVlfQlVGRkVSKSB7XG4gICAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IDY0OyArK2luZGV4KSB7XG4gICAgICAgICAgICBidWZmZXI4W2krK10gPSBtZXNzYWdlW2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IDY0OyArK2luZGV4KSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBtZXNzYWdlW2luZGV4XSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChBUlJBWV9CVUZGRVIpIHtcbiAgICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgNjQ7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcjhbaSsrXSA9IGNvZGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xuICAgICAgICAgICAgICBidWZmZXI4W2krK10gPSAweGMwIHwgKGNvZGUgPj4gNik7XG4gICAgICAgICAgICAgIGJ1ZmZlcjhbaSsrXSA9IDB4ODAgfCAoY29kZSAmIDB4M2YpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcjhbaSsrXSA9IDB4ZTAgfCAoY29kZSA+PiAxMik7XG4gICAgICAgICAgICAgIGJ1ZmZlcjhbaSsrXSA9IDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKTtcbiAgICAgICAgICAgICAgYnVmZmVyOFtpKytdID0gMHg4MCB8IChjb2RlICYgMHgzZik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKG1lc3NhZ2UuY2hhckNvZGVBdCgrK2luZGV4KSAmIDB4M2ZmKSk7XG4gICAgICAgICAgICAgIGJ1ZmZlcjhbaSsrXSA9IDB4ZjAgfCAoY29kZSA+PiAxOCk7XG4gICAgICAgICAgICAgIGJ1ZmZlcjhbaSsrXSA9IDB4ODAgfCAoKGNvZGUgPj4gMTIpICYgMHgzZik7XG4gICAgICAgICAgICAgIGJ1ZmZlcjhbaSsrXSA9IDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKTtcbiAgICAgICAgICAgICAgYnVmZmVyOFtpKytdID0gMHg4MCB8IChjb2RlICYgMHgzZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCA2NDsgKytpbmRleCkge1xuICAgICAgICAgICAgY29kZSA9IG1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcbiAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gY29kZSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGMwIHwgKGNvZGUgPj4gNikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGUwIHwgKGNvZGUgPj4gMTIpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKG1lc3NhZ2UuY2hhckNvZGVBdCgrK2luZGV4KSAmIDB4M2ZmKSk7XG4gICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGYwIHwgKGNvZGUgPj4gMTgpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gMTIpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdEJ5dGVJbmRleCA9IGk7XG4gICAgICB0aGlzLmJ5dGVzICs9IGkgLSB0aGlzLnN0YXJ0O1xuICAgICAgaWYgKGkgPj0gNjQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IGkgLSA2NDtcbiAgICAgICAgdGhpcy5oYXNoKCk7XG4gICAgICAgIHRoaXMuaGFzaGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5ieXRlcyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgIHRoaXMuaEJ5dGVzICs9IHRoaXMuYnl0ZXMgLyA0Mjk0OTY3Mjk2IDw8IDA7XG4gICAgICB0aGlzLmJ5dGVzID0gdGhpcy5ieXRlcyAlIDQyOTQ5NjcyOTY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIE1kNS5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGkgPSB0aGlzLmxhc3RCeXRlSW5kZXg7XG4gICAgYmxvY2tzW2kgPj4gMl0gfD0gRVhUUkFbaSAmIDNdO1xuICAgIGlmIChpID49IDU2KSB7XG4gICAgICBpZiAoIXRoaXMuaGFzaGVkKSB7XG4gICAgICAgIHRoaXMuaGFzaCgpO1xuICAgICAgfVxuICAgICAgYmxvY2tzWzBdID0gYmxvY2tzWzE2XTtcbiAgICAgIGJsb2Nrc1sxNl0gPSBibG9ja3NbMV0gPSBibG9ja3NbMl0gPSBibG9ja3NbM10gPVxuICAgICAgYmxvY2tzWzRdID0gYmxvY2tzWzVdID0gYmxvY2tzWzZdID0gYmxvY2tzWzddID1cbiAgICAgIGJsb2Nrc1s4XSA9IGJsb2Nrc1s5XSA9IGJsb2Nrc1sxMF0gPSBibG9ja3NbMTFdID1cbiAgICAgIGJsb2Nrc1sxMl0gPSBibG9ja3NbMTNdID0gYmxvY2tzWzE0XSA9IGJsb2Nrc1sxNV0gPSAwO1xuICAgIH1cbiAgICBibG9ja3NbMTRdID0gdGhpcy5ieXRlcyA8PCAzO1xuICAgIGJsb2Nrc1sxNV0gPSB0aGlzLmhCeXRlcyA8PCAzIHwgdGhpcy5ieXRlcyA+Pj4gMjk7XG4gICAgdGhpcy5oYXNoKCk7XG4gIH07XG5cbiAgTWQ1LnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhLCBiLCBjLCBkLCBiYywgZGEsIGJsb2NrcyA9IHRoaXMuYmxvY2tzO1xuXG4gICAgaWYgKHRoaXMuZmlyc3QpIHtcbiAgICAgIGEgPSBibG9ja3NbMF0gLSA2ODA4NzY5Mzc7XG4gICAgICBhID0gKGEgPDwgNyB8IGEgPj4+IDI1KSAtIDI3MTczMzg3OSA8PCAwO1xuICAgICAgZCA9ICgtMTczMjU4NDE5NCBeIGEgJiAyMDA0MzE4MDcxKSArIGJsb2Nrc1sxXSAtIDExNzgzMDcwODtcbiAgICAgIGQgPSAoZCA8PCAxMiB8IGQgPj4+IDIwKSArIGEgPDwgMDtcbiAgICAgIGMgPSAoLTI3MTczMzg3OSBeIChkICYgKGEgXiAtMjcxNzMzODc5KSkpICsgYmxvY2tzWzJdIC0gMTEyNjQ3ODM3NTtcbiAgICAgIGMgPSAoYyA8PCAxNyB8IGMgPj4+IDE1KSArIGQgPDwgMDtcbiAgICAgIGIgPSAoYSBeIChjICYgKGQgXiBhKSkpICsgYmxvY2tzWzNdIC0gMTMxNjI1OTIwOTtcbiAgICAgIGIgPSAoYiA8PCAyMiB8IGIgPj4+IDEwKSArIGMgPDwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IHRoaXMuaDA7XG4gICAgICBiID0gdGhpcy5oMTtcbiAgICAgIGMgPSB0aGlzLmgyO1xuICAgICAgZCA9IHRoaXMuaDM7XG4gICAgICBhICs9IChkIF4gKGIgJiAoYyBeIGQpKSkgKyBibG9ja3NbMF0gLSA2ODA4NzY5MzY7XG4gICAgICBhID0gKGEgPDwgNyB8IGEgPj4+IDI1KSArIGIgPDwgMDtcbiAgICAgIGQgKz0gKGMgXiAoYSAmIChiIF4gYykpKSArIGJsb2Nrc1sxXSAtIDM4OTU2NDU4NjtcbiAgICAgIGQgPSAoZCA8PCAxMiB8IGQgPj4+IDIwKSArIGEgPDwgMDtcbiAgICAgIGMgKz0gKGIgXiAoZCAmIChhIF4gYikpKSArIGJsb2Nrc1syXSArIDYwNjEwNTgxOTtcbiAgICAgIGMgPSAoYyA8PCAxNyB8IGMgPj4+IDE1KSArIGQgPDwgMDtcbiAgICAgIGIgKz0gKGEgXiAoYyAmIChkIF4gYSkpKSArIGJsb2Nrc1szXSAtIDEwNDQ1MjUzMzA7XG4gICAgICBiID0gKGIgPDwgMjIgfCBiID4+PiAxMCkgKyBjIDw8IDA7XG4gICAgfVxuXG4gICAgYSArPSAoZCBeIChiICYgKGMgXiBkKSkpICsgYmxvY2tzWzRdIC0gMTc2NDE4ODk3O1xuICAgIGEgPSAoYSA8PCA3IHwgYSA+Pj4gMjUpICsgYiA8PCAwO1xuICAgIGQgKz0gKGMgXiAoYSAmIChiIF4gYykpKSArIGJsb2Nrc1s1XSArIDEyMDAwODA0MjY7XG4gICAgZCA9IChkIDw8IDEyIHwgZCA+Pj4gMjApICsgYSA8PCAwO1xuICAgIGMgKz0gKGIgXiAoZCAmIChhIF4gYikpKSArIGJsb2Nrc1s2XSAtIDE0NzMyMzEzNDE7XG4gICAgYyA9IChjIDw8IDE3IHwgYyA+Pj4gMTUpICsgZCA8PCAwO1xuICAgIGIgKz0gKGEgXiAoYyAmIChkIF4gYSkpKSArIGJsb2Nrc1s3XSAtIDQ1NzA1OTgzO1xuICAgIGIgPSAoYiA8PCAyMiB8IGIgPj4+IDEwKSArIGMgPDwgMDtcbiAgICBhICs9IChkIF4gKGIgJiAoYyBeIGQpKSkgKyBibG9ja3NbOF0gKyAxNzcwMDM1NDE2O1xuICAgIGEgPSAoYSA8PCA3IHwgYSA+Pj4gMjUpICsgYiA8PCAwO1xuICAgIGQgKz0gKGMgXiAoYSAmIChiIF4gYykpKSArIGJsb2Nrc1s5XSAtIDE5NTg0MTQ0MTc7XG4gICAgZCA9IChkIDw8IDEyIHwgZCA+Pj4gMjApICsgYSA8PCAwO1xuICAgIGMgKz0gKGIgXiAoZCAmIChhIF4gYikpKSArIGJsb2Nrc1sxMF0gLSA0MjA2MztcbiAgICBjID0gKGMgPDwgMTcgfCBjID4+PiAxNSkgKyBkIDw8IDA7XG4gICAgYiArPSAoYSBeIChjICYgKGQgXiBhKSkpICsgYmxvY2tzWzExXSAtIDE5OTA0MDQxNjI7XG4gICAgYiA9IChiIDw8IDIyIHwgYiA+Pj4gMTApICsgYyA8PCAwO1xuICAgIGEgKz0gKGQgXiAoYiAmIChjIF4gZCkpKSArIGJsb2Nrc1sxMl0gKyAxODA0NjAzNjgyO1xuICAgIGEgPSAoYSA8PCA3IHwgYSA+Pj4gMjUpICsgYiA8PCAwO1xuICAgIGQgKz0gKGMgXiAoYSAmIChiIF4gYykpKSArIGJsb2Nrc1sxM10gLSA0MDM0MTEwMTtcbiAgICBkID0gKGQgPDwgMTIgfCBkID4+PiAyMCkgKyBhIDw8IDA7XG4gICAgYyArPSAoYiBeIChkICYgKGEgXiBiKSkpICsgYmxvY2tzWzE0XSAtIDE1MDIwMDIyOTA7XG4gICAgYyA9IChjIDw8IDE3IHwgYyA+Pj4gMTUpICsgZCA8PCAwO1xuICAgIGIgKz0gKGEgXiAoYyAmIChkIF4gYSkpKSArIGJsb2Nrc1sxNV0gKyAxMjM2NTM1MzI5O1xuICAgIGIgPSAoYiA8PCAyMiB8IGIgPj4+IDEwKSArIGMgPDwgMDtcbiAgICBhICs9IChjIF4gKGQgJiAoYiBeIGMpKSkgKyBibG9ja3NbMV0gLSAxNjU3OTY1MTA7XG4gICAgYSA9IChhIDw8IDUgfCBhID4+PiAyNykgKyBiIDw8IDA7XG4gICAgZCArPSAoYiBeIChjICYgKGEgXiBiKSkpICsgYmxvY2tzWzZdIC0gMTA2OTUwMTYzMjtcbiAgICBkID0gKGQgPDwgOSB8IGQgPj4+IDIzKSArIGEgPDwgMDtcbiAgICBjICs9IChhIF4gKGIgJiAoZCBeIGEpKSkgKyBibG9ja3NbMTFdICsgNjQzNzE3NzEzO1xuICAgIGMgPSAoYyA8PCAxNCB8IGMgPj4+IDE4KSArIGQgPDwgMDtcbiAgICBiICs9IChkIF4gKGEgJiAoYyBeIGQpKSkgKyBibG9ja3NbMF0gLSAzNzM4OTczMDI7XG4gICAgYiA9IChiIDw8IDIwIHwgYiA+Pj4gMTIpICsgYyA8PCAwO1xuICAgIGEgKz0gKGMgXiAoZCAmIChiIF4gYykpKSArIGJsb2Nrc1s1XSAtIDcwMTU1ODY5MTtcbiAgICBhID0gKGEgPDwgNSB8IGEgPj4+IDI3KSArIGIgPDwgMDtcbiAgICBkICs9IChiIF4gKGMgJiAoYSBeIGIpKSkgKyBibG9ja3NbMTBdICsgMzgwMTYwODM7XG4gICAgZCA9IChkIDw8IDkgfCBkID4+PiAyMykgKyBhIDw8IDA7XG4gICAgYyArPSAoYSBeIChiICYgKGQgXiBhKSkpICsgYmxvY2tzWzE1XSAtIDY2MDQ3ODMzNTtcbiAgICBjID0gKGMgPDwgMTQgfCBjID4+PiAxOCkgKyBkIDw8IDA7XG4gICAgYiArPSAoZCBeIChhICYgKGMgXiBkKSkpICsgYmxvY2tzWzRdIC0gNDA1NTM3ODQ4O1xuICAgIGIgPSAoYiA8PCAyMCB8IGIgPj4+IDEyKSArIGMgPDwgMDtcbiAgICBhICs9IChjIF4gKGQgJiAoYiBeIGMpKSkgKyBibG9ja3NbOV0gKyA1Njg0NDY0Mzg7XG4gICAgYSA9IChhIDw8IDUgfCBhID4+PiAyNykgKyBiIDw8IDA7XG4gICAgZCArPSAoYiBeIChjICYgKGEgXiBiKSkpICsgYmxvY2tzWzE0XSAtIDEwMTk4MDM2OTA7XG4gICAgZCA9IChkIDw8IDkgfCBkID4+PiAyMykgKyBhIDw8IDA7XG4gICAgYyArPSAoYSBeIChiICYgKGQgXiBhKSkpICsgYmxvY2tzWzNdIC0gMTg3MzYzOTYxO1xuICAgIGMgPSAoYyA8PCAxNCB8IGMgPj4+IDE4KSArIGQgPDwgMDtcbiAgICBiICs9IChkIF4gKGEgJiAoYyBeIGQpKSkgKyBibG9ja3NbOF0gKyAxMTYzNTMxNTAxO1xuICAgIGIgPSAoYiA8PCAyMCB8IGIgPj4+IDEyKSArIGMgPDwgMDtcbiAgICBhICs9IChjIF4gKGQgJiAoYiBeIGMpKSkgKyBibG9ja3NbMTNdIC0gMTQ0NDY4MTQ2NztcbiAgICBhID0gKGEgPDwgNSB8IGEgPj4+IDI3KSArIGIgPDwgMDtcbiAgICBkICs9IChiIF4gKGMgJiAoYSBeIGIpKSkgKyBibG9ja3NbMl0gLSA1MTQwMzc4NDtcbiAgICBkID0gKGQgPDwgOSB8IGQgPj4+IDIzKSArIGEgPDwgMDtcbiAgICBjICs9IChhIF4gKGIgJiAoZCBeIGEpKSkgKyBibG9ja3NbN10gKyAxNzM1MzI4NDczO1xuICAgIGMgPSAoYyA8PCAxNCB8IGMgPj4+IDE4KSArIGQgPDwgMDtcbiAgICBiICs9IChkIF4gKGEgJiAoYyBeIGQpKSkgKyBibG9ja3NbMTJdIC0gMTkyNjYwNzczNDtcbiAgICBiID0gKGIgPDwgMjAgfCBiID4+PiAxMikgKyBjIDw8IDA7XG4gICAgYmMgPSBiIF4gYztcbiAgICBhICs9IChiYyBeIGQpICsgYmxvY2tzWzVdIC0gMzc4NTU4O1xuICAgIGEgPSAoYSA8PCA0IHwgYSA+Pj4gMjgpICsgYiA8PCAwO1xuICAgIGQgKz0gKGJjIF4gYSkgKyBibG9ja3NbOF0gLSAyMDIyNTc0NDYzO1xuICAgIGQgPSAoZCA8PCAxMSB8IGQgPj4+IDIxKSArIGEgPDwgMDtcbiAgICBkYSA9IGQgXiBhO1xuICAgIGMgKz0gKGRhIF4gYikgKyBibG9ja3NbMTFdICsgMTgzOTAzMDU2MjtcbiAgICBjID0gKGMgPDwgMTYgfCBjID4+PiAxNikgKyBkIDw8IDA7XG4gICAgYiArPSAoZGEgXiBjKSArIGJsb2Nrc1sxNF0gLSAzNTMwOTU1NjtcbiAgICBiID0gKGIgPDwgMjMgfCBiID4+PiA5KSArIGMgPDwgMDtcbiAgICBiYyA9IGIgXiBjO1xuICAgIGEgKz0gKGJjIF4gZCkgKyBibG9ja3NbMV0gLSAxNTMwOTkyMDYwO1xuICAgIGEgPSAoYSA8PCA0IHwgYSA+Pj4gMjgpICsgYiA8PCAwO1xuICAgIGQgKz0gKGJjIF4gYSkgKyBibG9ja3NbNF0gKyAxMjcyODkzMzUzO1xuICAgIGQgPSAoZCA8PCAxMSB8IGQgPj4+IDIxKSArIGEgPDwgMDtcbiAgICBkYSA9IGQgXiBhO1xuICAgIGMgKz0gKGRhIF4gYikgKyBibG9ja3NbN10gLSAxNTU0OTc2MzI7XG4gICAgYyA9IChjIDw8IDE2IHwgYyA+Pj4gMTYpICsgZCA8PCAwO1xuICAgIGIgKz0gKGRhIF4gYykgKyBibG9ja3NbMTBdIC0gMTA5NDczMDY0MDtcbiAgICBiID0gKGIgPDwgMjMgfCBiID4+PiA5KSArIGMgPDwgMDtcbiAgICBiYyA9IGIgXiBjO1xuICAgIGEgKz0gKGJjIF4gZCkgKyBibG9ja3NbMTNdICsgNjgxMjc5MTc0O1xuICAgIGEgPSAoYSA8PCA0IHwgYSA+Pj4gMjgpICsgYiA8PCAwO1xuICAgIGQgKz0gKGJjIF4gYSkgKyBibG9ja3NbMF0gLSAzNTg1MzcyMjI7XG4gICAgZCA9IChkIDw8IDExIHwgZCA+Pj4gMjEpICsgYSA8PCAwO1xuICAgIGRhID0gZCBeIGE7XG4gICAgYyArPSAoZGEgXiBiKSArIGJsb2Nrc1szXSAtIDcyMjUyMTk3OTtcbiAgICBjID0gKGMgPDwgMTYgfCBjID4+PiAxNikgKyBkIDw8IDA7XG4gICAgYiArPSAoZGEgXiBjKSArIGJsb2Nrc1s2XSArIDc2MDI5MTg5O1xuICAgIGIgPSAoYiA8PCAyMyB8IGIgPj4+IDkpICsgYyA8PCAwO1xuICAgIGJjID0gYiBeIGM7XG4gICAgYSArPSAoYmMgXiBkKSArIGJsb2Nrc1s5XSAtIDY0MDM2NDQ4NztcbiAgICBhID0gKGEgPDwgNCB8IGEgPj4+IDI4KSArIGIgPDwgMDtcbiAgICBkICs9IChiYyBeIGEpICsgYmxvY2tzWzEyXSAtIDQyMTgxNTgzNTtcbiAgICBkID0gKGQgPDwgMTEgfCBkID4+PiAyMSkgKyBhIDw8IDA7XG4gICAgZGEgPSBkIF4gYTtcbiAgICBjICs9IChkYSBeIGIpICsgYmxvY2tzWzE1XSArIDUzMDc0MjUyMDtcbiAgICBjID0gKGMgPDwgMTYgfCBjID4+PiAxNikgKyBkIDw8IDA7XG4gICAgYiArPSAoZGEgXiBjKSArIGJsb2Nrc1syXSAtIDk5NTMzODY1MTtcbiAgICBiID0gKGIgPDwgMjMgfCBiID4+PiA5KSArIGMgPDwgMDtcbiAgICBhICs9IChjIF4gKGIgfCB+ZCkpICsgYmxvY2tzWzBdIC0gMTk4NjMwODQ0O1xuICAgIGEgPSAoYSA8PCA2IHwgYSA+Pj4gMjYpICsgYiA8PCAwO1xuICAgIGQgKz0gKGIgXiAoYSB8IH5jKSkgKyBibG9ja3NbN10gKyAxMTI2ODkxNDE1O1xuICAgIGQgPSAoZCA8PCAxMCB8IGQgPj4+IDIyKSArIGEgPDwgMDtcbiAgICBjICs9IChhIF4gKGQgfCB+YikpICsgYmxvY2tzWzE0XSAtIDE0MTYzNTQ5MDU7XG4gICAgYyA9IChjIDw8IDE1IHwgYyA+Pj4gMTcpICsgZCA8PCAwO1xuICAgIGIgKz0gKGQgXiAoYyB8IH5hKSkgKyBibG9ja3NbNV0gLSA1NzQzNDA1NTtcbiAgICBiID0gKGIgPDwgMjEgfCBiID4+PiAxMSkgKyBjIDw8IDA7XG4gICAgYSArPSAoYyBeIChiIHwgfmQpKSArIGJsb2Nrc1sxMl0gKyAxNzAwNDg1NTcxO1xuICAgIGEgPSAoYSA8PCA2IHwgYSA+Pj4gMjYpICsgYiA8PCAwO1xuICAgIGQgKz0gKGIgXiAoYSB8IH5jKSkgKyBibG9ja3NbM10gLSAxODk0OTg2NjA2O1xuICAgIGQgPSAoZCA8PCAxMCB8IGQgPj4+IDIyKSArIGEgPDwgMDtcbiAgICBjICs9IChhIF4gKGQgfCB+YikpICsgYmxvY2tzWzEwXSAtIDEwNTE1MjM7XG4gICAgYyA9IChjIDw8IDE1IHwgYyA+Pj4gMTcpICsgZCA8PCAwO1xuICAgIGIgKz0gKGQgXiAoYyB8IH5hKSkgKyBibG9ja3NbMV0gLSAyMDU0OTIyNzk5O1xuICAgIGIgPSAoYiA8PCAyMSB8IGIgPj4+IDExKSArIGMgPDwgMDtcbiAgICBhICs9IChjIF4gKGIgfCB+ZCkpICsgYmxvY2tzWzhdICsgMTg3MzMxMzM1OTtcbiAgICBhID0gKGEgPDwgNiB8IGEgPj4+IDI2KSArIGIgPDwgMDtcbiAgICBkICs9IChiIF4gKGEgfCB+YykpICsgYmxvY2tzWzE1XSAtIDMwNjExNzQ0O1xuICAgIGQgPSAoZCA8PCAxMCB8IGQgPj4+IDIyKSArIGEgPDwgMDtcbiAgICBjICs9IChhIF4gKGQgfCB+YikpICsgYmxvY2tzWzZdIC0gMTU2MDE5ODM4MDtcbiAgICBjID0gKGMgPDwgMTUgfCBjID4+PiAxNykgKyBkIDw8IDA7XG4gICAgYiArPSAoZCBeIChjIHwgfmEpKSArIGJsb2Nrc1sxM10gKyAxMzA5MTUxNjQ5O1xuICAgIGIgPSAoYiA8PCAyMSB8IGIgPj4+IDExKSArIGMgPDwgMDtcbiAgICBhICs9IChjIF4gKGIgfCB+ZCkpICsgYmxvY2tzWzRdIC0gMTQ1NTIzMDcwO1xuICAgIGEgPSAoYSA8PCA2IHwgYSA+Pj4gMjYpICsgYiA8PCAwO1xuICAgIGQgKz0gKGIgXiAoYSB8IH5jKSkgKyBibG9ja3NbMTFdIC0gMTEyMDIxMDM3OTtcbiAgICBkID0gKGQgPDwgMTAgfCBkID4+PiAyMikgKyBhIDw8IDA7XG4gICAgYyArPSAoYSBeIChkIHwgfmIpKSArIGJsb2Nrc1syXSArIDcxODc4NzI1OTtcbiAgICBjID0gKGMgPDwgMTUgfCBjID4+PiAxNykgKyBkIDw8IDA7XG4gICAgYiArPSAoZCBeIChjIHwgfmEpKSArIGJsb2Nrc1s5XSAtIDM0MzQ4NTU1MTtcbiAgICBiID0gKGIgPDwgMjEgfCBiID4+PiAxMSkgKyBjIDw8IDA7XG5cbiAgICBpZiAodGhpcy5maXJzdCkge1xuICAgICAgdGhpcy5oMCA9IGEgKyAxNzMyNTg0MTkzIDw8IDA7XG4gICAgICB0aGlzLmgxID0gYiAtIDI3MTczMzg3OSA8PCAwO1xuICAgICAgdGhpcy5oMiA9IGMgLSAxNzMyNTg0MTk0IDw8IDA7XG4gICAgICB0aGlzLmgzID0gZCArIDI3MTczMzg3OCA8PCAwO1xuICAgICAgdGhpcy5maXJzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmgwID0gdGhpcy5oMCArIGEgPDwgMDtcbiAgICAgIHRoaXMuaDEgPSB0aGlzLmgxICsgYiA8PCAwO1xuICAgICAgdGhpcy5oMiA9IHRoaXMuaDIgKyBjIDw8IDA7XG4gICAgICB0aGlzLmgzID0gdGhpcy5oMyArIGQgPDwgMDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGV4XG4gICAqIEBtZW1iZXJvZiBNZDVcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBPdXRwdXQgaGFzaCBhcyBoZXggc3RyaW5nXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEhleCBzdHJpbmdcbiAgICogQHNlZSB7QGxpbmsgbWQ1LmhleH1cbiAgICogQGV4YW1wbGVcbiAgICogaGFzaC5oZXgoKTtcbiAgICovXG4gIE1kNS5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBoMCA9IHRoaXMuaDAsIGgxID0gdGhpcy5oMSwgaDIgPSB0aGlzLmgyLCBoMyA9IHRoaXMuaDM7XG5cbiAgICByZXR1cm4gSEVYX0NIQVJTWyhoMCA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2gwICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMCA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDAgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgwID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMCA+PiAxNikgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgwID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMCA+PiAyNCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgxID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDEgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgxID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMSA+PiA4KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDEgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgxID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDEgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgxID4+IDI0KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDIgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toMiAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDIgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgyID4+IDgpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMiA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDIgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMiA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDIgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMyA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2gzICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMyA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDMgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgzID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMyA+PiAxNikgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgzID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMyA+PiAyNCkgJiAweDBGXTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgKiBAbWVtYmVyb2YgTWQ1XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gT3V0cHV0IGhhc2ggYXMgaGV4IHN0cmluZ1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBIZXggc3RyaW5nXG4gICAqIEBzZWUge0BsaW5rIG1kNS5oZXh9XG4gICAqIEBleGFtcGxlXG4gICAqIGhhc2gudG9TdHJpbmcoKTtcbiAgICovXG4gIE1kNS5wcm90b3R5cGUudG9TdHJpbmcgPSBNZDUucHJvdG90eXBlLmhleDtcblxuICAvKipcbiAgICogQG1ldGhvZCBkaWdlc3RcbiAgICogQG1lbWJlcm9mIE1kNVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIE91dHB1dCBoYXNoIGFzIGJ5dGVzIGFycmF5XG4gICAqIEByZXR1cm5zIHtBcnJheX0gQnl0ZXMgYXJyYXlcbiAgICogQHNlZSB7QGxpbmsgbWQ1LmRpZ2VzdH1cbiAgICogQGV4YW1wbGVcbiAgICogaGFzaC5kaWdlc3QoKTtcbiAgICovXG4gIE1kNS5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBoMCA9IHRoaXMuaDAsIGgxID0gdGhpcy5oMSwgaDIgPSB0aGlzLmgyLCBoMyA9IHRoaXMuaDM7XG4gICAgcmV0dXJuIFtcbiAgICAgIGgwICYgMHhGRiwgKGgwID4+IDgpICYgMHhGRiwgKGgwID4+IDE2KSAmIDB4RkYsIChoMCA+PiAyNCkgJiAweEZGLFxuICAgICAgaDEgJiAweEZGLCAoaDEgPj4gOCkgJiAweEZGLCAoaDEgPj4gMTYpICYgMHhGRiwgKGgxID4+IDI0KSAmIDB4RkYsXG4gICAgICBoMiAmIDB4RkYsIChoMiA+PiA4KSAmIDB4RkYsIChoMiA+PiAxNikgJiAweEZGLCAoaDIgPj4gMjQpICYgMHhGRixcbiAgICAgIGgzICYgMHhGRiwgKGgzID4+IDgpICYgMHhGRiwgKGgzID4+IDE2KSAmIDB4RkYsIChoMyA+PiAyNCkgJiAweEZGXG4gICAgXTtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBhcnJheVxuICAgKiBAbWVtYmVyb2YgTWQ1XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gT3V0cHV0IGhhc2ggYXMgYnl0ZXMgYXJyYXlcbiAgICogQHJldHVybnMge0FycmF5fSBCeXRlcyBhcnJheVxuICAgKiBAc2VlIHtAbGluayBtZDUuYXJyYXl9XG4gICAqIEBleGFtcGxlXG4gICAqIGhhc2guYXJyYXkoKTtcbiAgICovXG4gIE1kNS5wcm90b3R5cGUuYXJyYXkgPSBNZDUucHJvdG90eXBlLmRpZ2VzdDtcblxuICAvKipcbiAgICogQG1ldGhvZCBhcnJheUJ1ZmZlclxuICAgKiBAbWVtYmVyb2YgTWQ1XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gT3V0cHV0IGhhc2ggYXMgQXJyYXlCdWZmZXJcbiAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBBcnJheUJ1ZmZlclxuICAgKiBAc2VlIHtAbGluayBtZDUuYXJyYXlCdWZmZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIGhhc2guYXJyYXlCdWZmZXIoKTtcbiAgICovXG4gIE1kNS5wcm90b3R5cGUuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigxNik7XG4gICAgdmFyIGJsb2NrcyA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xuICAgIGJsb2Nrc1swXSA9IHRoaXMuaDA7XG4gICAgYmxvY2tzWzFdID0gdGhpcy5oMTtcbiAgICBibG9ja3NbMl0gPSB0aGlzLmgyO1xuICAgIGJsb2Nrc1szXSA9IHRoaXMuaDM7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICAvKipcbiAgICogQG1ldGhvZCBidWZmZXJcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyBtYXliZSBjb25mdXNlIHdpdGggQnVmZmVyIGluIG5vZGUuanMuIFBsZWFzZSB1c2UgYXJyYXlCdWZmZXIgaW5zdGVhZC5cbiAgICogQG1lbWJlcm9mIE1kNVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIE91dHB1dCBoYXNoIGFzIEFycmF5QnVmZmVyXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gQXJyYXlCdWZmZXJcbiAgICogQHNlZSB7QGxpbmsgbWQ1LmJ1ZmZlcn1cbiAgICogQGV4YW1wbGVcbiAgICogaGFzaC5idWZmZXIoKTtcbiAgICovXG4gIE1kNS5wcm90b3R5cGUuYnVmZmVyID0gTWQ1LnByb3RvdHlwZS5hcnJheUJ1ZmZlcjtcblxuICAvKipcbiAgICogQG1ldGhvZCBiYXNlNjRcbiAgICogQG1lbWJlcm9mIE1kNVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIE91dHB1dCBoYXNoIGFzIGJhc2U2NCBzdHJpbmdcbiAgICogQHJldHVybnMge1N0cmluZ30gYmFzZTY0IHN0cmluZ1xuICAgKiBAc2VlIHtAbGluayBtZDUuYmFzZTY0fVxuICAgKiBAZXhhbXBsZVxuICAgKiBoYXNoLmJhc2U2NCgpO1xuICAgKi9cbiAgTWQ1LnByb3RvdHlwZS5iYXNlNjQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYxLCB2MiwgdjMsIGJhc2U2NFN0ciA9ICcnLCBieXRlcyA9IHRoaXMuYXJyYXkoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE1Oykge1xuICAgICAgdjEgPSBieXRlc1tpKytdO1xuICAgICAgdjIgPSBieXRlc1tpKytdO1xuICAgICAgdjMgPSBieXRlc1tpKytdO1xuICAgICAgYmFzZTY0U3RyICs9IEJBU0U2NF9FTkNPREVfQ0hBUlt2MSA+Pj4gMl0gK1xuICAgICAgICBCQVNFNjRfRU5DT0RFX0NIQVJbKHYxIDw8IDQgfCB2MiA+Pj4gNCkgJiA2M10gK1xuICAgICAgICBCQVNFNjRfRU5DT0RFX0NIQVJbKHYyIDw8IDIgfCB2MyA+Pj4gNikgJiA2M10gK1xuICAgICAgICBCQVNFNjRfRU5DT0RFX0NIQVJbdjMgJiA2M107XG4gICAgfVxuICAgIHYxID0gYnl0ZXNbaV07XG4gICAgYmFzZTY0U3RyICs9IEJBU0U2NF9FTkNPREVfQ0hBUlt2MSA+Pj4gMl0gK1xuICAgICAgQkFTRTY0X0VOQ09ERV9DSEFSWyh2MSA8PCA0KSAmIDYzXSArXG4gICAgICAnPT0nO1xuICAgIHJldHVybiBiYXNlNjRTdHI7XG4gIH07XG5cbiAgdmFyIGV4cG9ydHMgPSBjcmVhdGVNZXRob2QoKTtcblxuICBpZiAoQ09NTU9OX0pTKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuICB9IGVsc2Uge1xuICAgIC8qKlxuICAgICAqIEBtZXRob2QgbWQ1XGJcbiAgICAgKiBAZGVzY3JpcHRpb24gTWQ1IGhhc2ggZnVuY3Rpb24sIGV4cG9ydCB0byBnbG9iYWwgaW4gYnJvd3NlcnMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl8VWludDhBcnJheXxBcnJheUJ1ZmZlcn0gbWVzc2FnZSBtZXNzYWdlIHRvIGhhc2hcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBtZDUgaGFzaGVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBtZDUoJycpOyAvLyBkNDFkOGNkOThmMDBiMjA0ZTk4MDA5OThlY2Y4NDI3ZVxuICAgICAqIG1kNSgnVGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZycpOyAvLyA5ZTEwN2Q5ZDM3MmJiNjgyNmJkODFkMzU0MmE0MTlkNlxuICAgICAqIG1kNSgnVGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4nKTsgLy8gZTRkOTA5YzI5MGQwZmIxY2EwNjhmZmFkZGYyMmNiZDBcbiAgICAgKlxuICAgICAqIC8vIEl0IGFsc28gc3VwcG9ydHMgVVRGLTggZW5jb2RpbmdcbiAgICAgKiBtZDUoJ+S4reaWhycpOyAvLyBhN2JhYzIyMzlmY2RjYjNhMDY3OTAzZDgwNzdjNGEwN1xuICAgICAqXG4gICAgICogLy8gSXQgYWxzbyBzdXBwb3J0cyBieXRlIGBBcnJheWAsIGBVaW50OEFycmF5YCwgYEFycmF5QnVmZmVyYFxuICAgICAqIG1kNShbXSk7IC8vIGQ0MWQ4Y2Q5OGYwMGIyMDRlOTgwMDk5OGVjZjg0MjdlXG4gICAgICogbWQ1KG5ldyBVaW50OEFycmF5KFtdKSk7IC8vIGQ0MWQ4Y2Q5OGYwMGIyMDRlOTgwMDk5OGVjZjg0MjdlXG4gICAgICovXG4gICAgcm9vdC5tZDUgPSBleHBvcnRzO1xuICAgIGlmIChBTUQpIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59KSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/.pnpm/js-md5@0.7.3/node_modules/js-md5/src/md5.js\n")},"../../node_modules/.pnpm/js-sha1@0.6.0/node_modules/js-sha1/src/sha1.js":(module,exports,__webpack_require__)=>{eval("/* provided dependency */ var process = __webpack_require__(\"../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\");\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*\n * [js-sha1]{@link https://github.com/emn178/js-sha1}\n *\n * @version 0.6.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2017\n * @license MIT\n */\n/*jslint bitwise: true */\n(function() {\n  'use strict';\n\n  var root = typeof window === 'object' ? window : {};\n  var NODE_JS = !root.JS_SHA1_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n  if (NODE_JS) {\n    root = __webpack_require__.g;\n  }\n  var COMMON_JS = !root.JS_SHA1_NO_COMMON_JS && \"object\" === 'object' && module.exports;\n  var AMD =  true && __webpack_require__.amdO;\n  var HEX_CHARS = '0123456789abcdef'.split('');\n  var EXTRA = [-2147483648, 8388608, 32768, 128];\n  var SHIFT = [24, 16, 8, 0];\n  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];\n\n  var blocks = [];\n\n  var createOutputMethod = function (outputType) {\n    return function (message) {\n      return new Sha1(true).update(message)[outputType]();\n    };\n  };\n\n  var createMethod = function () {\n    var method = createOutputMethod('hex');\n    if (NODE_JS) {\n      method = nodeWrap(method);\n    }\n    method.create = function () {\n      return new Sha1();\n    };\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createOutputMethod(type);\n    }\n    return method;\n  };\n\n  var nodeWrap = function (method) {\n    var crypto = eval(\"require('crypto')\");\n    var Buffer = eval(\"require('buffer').Buffer\");\n    var nodeMethod = function (message) {\n      if (typeof message === 'string') {\n        return crypto.createHash('sha1').update(message, 'utf8').digest('hex');\n      } else if (message.constructor === ArrayBuffer) {\n        message = new Uint8Array(message);\n      } else if (message.length === undefined) {\n        return method(message);\n      }\n      return crypto.createHash('sha1').update(new Buffer(message)).digest('hex');\n    };\n    return nodeMethod;\n  };\n\n  function Sha1(sharedMemory) {\n    if (sharedMemory) {\n      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n      blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n      blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      this.blocks = blocks;\n    } else {\n      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    }\n\n    this.h0 = 0x67452301;\n    this.h1 = 0xEFCDAB89;\n    this.h2 = 0x98BADCFE;\n    this.h3 = 0x10325476;\n    this.h4 = 0xC3D2E1F0;\n\n    this.block = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n  }\n\n  Sha1.prototype.update = function (message) {\n    if (this.finalized) {\n      return;\n    }\n    var notString = typeof(message) !== 'string';\n    if (notString && message.constructor === root.ArrayBuffer) {\n      message = new Uint8Array(message);\n    }\n    var code, index = 0, i, length = message.length || 0, blocks = this.blocks;\n\n    while (index < length) {\n      if (this.hashed) {\n        this.hashed = false;\n        blocks[0] = this.block;\n        blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n        blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n        blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      }\n\n      if(notString) {\n        for (i = this.start; index < length && i < 64; ++index) {\n          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n        }\n      } else {\n        for (i = this.start; index < length && i < 64; ++index) {\n          code = message.charCodeAt(index);\n          if (code < 0x80) {\n            blocks[i >> 2] |= code << SHIFT[i++ & 3];\n          } else if (code < 0x800) {\n            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else if (code < 0xd800 || code >= 0xe000) {\n            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else {\n            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          }\n        }\n      }\n\n      this.lastByteIndex = i;\n      this.bytes += i - this.start;\n      if (i >= 64) {\n        this.block = blocks[16];\n        this.start = i - 64;\n        this.hash();\n        this.hashed = true;\n      } else {\n        this.start = i;\n      }\n    }\n    if (this.bytes > 4294967295) {\n      this.hBytes += this.bytes / 4294967296 << 0;\n      this.bytes = this.bytes % 4294967296;\n    }\n    return this;\n  };\n\n  Sha1.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex;\n    blocks[16] = this.block;\n    blocks[i >> 2] |= EXTRA[i & 3];\n    this.block = blocks[16];\n    if (i >= 56) {\n      if (!this.hashed) {\n        this.hash();\n      }\n      blocks[0] = this.block;\n      blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n      blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n      blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n    }\n    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;\n    blocks[15] = this.bytes << 3;\n    this.hash();\n  };\n\n  Sha1.prototype.hash = function () {\n    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4;\n    var f, j, t, blocks = this.blocks;\n\n    for(j = 16; j < 80; ++j) {\n      t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];\n      blocks[j] =  (t << 1) | (t >>> 31);\n    }\n\n    for(j = 0; j < 20; j += 5) {\n      f = (b & c) | ((~b) & d);\n      t = (a << 5) | (a >>> 27);\n      e = t + f + e + 1518500249 + blocks[j] << 0;\n      b = (b << 30) | (b >>> 2);\n\n      f = (a & b) | ((~a) & c);\n      t = (e << 5) | (e >>> 27);\n      d = t + f + d + 1518500249 + blocks[j + 1] << 0;\n      a = (a << 30) | (a >>> 2);\n\n      f = (e & a) | ((~e) & b);\n      t = (d << 5) | (d >>> 27);\n      c = t + f + c + 1518500249 + blocks[j + 2] << 0;\n      e = (e << 30) | (e >>> 2);\n\n      f = (d & e) | ((~d) & a);\n      t = (c << 5) | (c >>> 27);\n      b = t + f + b + 1518500249 + blocks[j + 3] << 0;\n      d = (d << 30) | (d >>> 2);\n\n      f = (c & d) | ((~c) & e);\n      t = (b << 5) | (b >>> 27);\n      a = t + f + a + 1518500249 + blocks[j + 4] << 0;\n      c = (c << 30) | (c >>> 2);\n    }\n\n    for(; j < 40; j += 5) {\n      f = b ^ c ^ d;\n      t = (a << 5) | (a >>> 27);\n      e = t + f + e + 1859775393 + blocks[j] << 0;\n      b = (b << 30) | (b >>> 2);\n\n      f = a ^ b ^ c;\n      t = (e << 5) | (e >>> 27);\n      d = t + f + d + 1859775393 + blocks[j + 1] << 0;\n      a = (a << 30) | (a >>> 2);\n\n      f = e ^ a ^ b;\n      t = (d << 5) | (d >>> 27);\n      c = t + f + c + 1859775393 + blocks[j + 2] << 0;\n      e = (e << 30) | (e >>> 2);\n\n      f = d ^ e ^ a;\n      t = (c << 5) | (c >>> 27);\n      b = t + f + b + 1859775393 + blocks[j + 3] << 0;\n      d = (d << 30) | (d >>> 2);\n\n      f = c ^ d ^ e;\n      t = (b << 5) | (b >>> 27);\n      a = t + f + a + 1859775393 + blocks[j + 4] << 0;\n      c = (c << 30) | (c >>> 2);\n    }\n\n    for(; j < 60; j += 5) {\n      f = (b & c) | (b & d) | (c & d);\n      t = (a << 5) | (a >>> 27);\n      e = t + f + e - 1894007588 + blocks[j] << 0;\n      b = (b << 30) | (b >>> 2);\n\n      f = (a & b) | (a & c) | (b & c);\n      t = (e << 5) | (e >>> 27);\n      d = t + f + d - 1894007588 + blocks[j + 1] << 0;\n      a = (a << 30) | (a >>> 2);\n\n      f = (e & a) | (e & b) | (a & b);\n      t = (d << 5) | (d >>> 27);\n      c = t + f + c - 1894007588 + blocks[j + 2] << 0;\n      e = (e << 30) | (e >>> 2);\n\n      f = (d & e) | (d & a) | (e & a);\n      t = (c << 5) | (c >>> 27);\n      b = t + f + b - 1894007588 + blocks[j + 3] << 0;\n      d = (d << 30) | (d >>> 2);\n\n      f = (c & d) | (c & e) | (d & e);\n      t = (b << 5) | (b >>> 27);\n      a = t + f + a - 1894007588 + blocks[j + 4] << 0;\n      c = (c << 30) | (c >>> 2);\n    }\n\n    for(; j < 80; j += 5) {\n      f = b ^ c ^ d;\n      t = (a << 5) | (a >>> 27);\n      e = t + f + e - 899497514 + blocks[j] << 0;\n      b = (b << 30) | (b >>> 2);\n\n      f = a ^ b ^ c;\n      t = (e << 5) | (e >>> 27);\n      d = t + f + d - 899497514 + blocks[j + 1] << 0;\n      a = (a << 30) | (a >>> 2);\n\n      f = e ^ a ^ b;\n      t = (d << 5) | (d >>> 27);\n      c = t + f + c - 899497514 + blocks[j + 2] << 0;\n      e = (e << 30) | (e >>> 2);\n\n      f = d ^ e ^ a;\n      t = (c << 5) | (c >>> 27);\n      b = t + f + b - 899497514 + blocks[j + 3] << 0;\n      d = (d << 30) | (d >>> 2);\n\n      f = c ^ d ^ e;\n      t = (b << 5) | (b >>> 27);\n      a = t + f + a - 899497514 + blocks[j + 4] << 0;\n      c = (c << 30) | (c >>> 2);\n    }\n\n    this.h0 = this.h0 + a << 0;\n    this.h1 = this.h1 + b << 0;\n    this.h2 = this.h2 + c << 0;\n    this.h3 = this.h3 + d << 0;\n    this.h4 = this.h4 + e << 0;\n  };\n\n  Sha1.prototype.hex = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;\n\n    return HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +\n           HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +\n           HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +\n           HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +\n           HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +\n           HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +\n           HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +\n           HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +\n           HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +\n           HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +\n           HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +\n           HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +\n           HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F] +\n           HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +\n           HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +\n           HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +\n           HEX_CHARS[(h4 >> 28) & 0x0F] + HEX_CHARS[(h4 >> 24) & 0x0F] +\n           HEX_CHARS[(h4 >> 20) & 0x0F] + HEX_CHARS[(h4 >> 16) & 0x0F] +\n           HEX_CHARS[(h4 >> 12) & 0x0F] + HEX_CHARS[(h4 >> 8) & 0x0F] +\n           HEX_CHARS[(h4 >> 4) & 0x0F] + HEX_CHARS[h4 & 0x0F];\n  };\n\n  Sha1.prototype.toString = Sha1.prototype.hex;\n\n  Sha1.prototype.digest = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;\n\n    return [\n      (h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, h0 & 0xFF,\n      (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 8) & 0xFF, h1 & 0xFF,\n      (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, h2 & 0xFF,\n      (h3 >> 24) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, h3 & 0xFF,\n      (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, h4 & 0xFF\n    ];\n  };\n\n  Sha1.prototype.array = Sha1.prototype.digest;\n\n  Sha1.prototype.arrayBuffer = function () {\n    this.finalize();\n\n    var buffer = new ArrayBuffer(20);\n    var dataView = new DataView(buffer);\n    dataView.setUint32(0, this.h0);\n    dataView.setUint32(4, this.h1);\n    dataView.setUint32(8, this.h2);\n    dataView.setUint32(12, this.h3);\n    dataView.setUint32(16, this.h4);\n    return buffer;\n  };\n\n  var exports = createMethod();\n\n  if (COMMON_JS) {\n    module.exports = exports;\n  } else {\n    root.sha1 = exports;\n    if (AMD) {\n      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n        return exports;\n      }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n  }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2pzLXNoYTFAMC42LjAvbm9kZV9tb2R1bGVzL2pzLXNoYTEvc3JjL3NoYTEuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxPQUFPLGlCQUFpQixPQUFPLGFBQWEsT0FBTztBQUN0RztBQUNBLFdBQVcscUJBQU07QUFDakI7QUFDQSxnREFBZ0QsUUFBYTtBQUM3RCxZQUFZLEtBQTRCLElBQUksd0JBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsMEJBQTBCO0FBQ3ZEO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNkJBQTZCLDBCQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTSxtQ0FBTztBQUNiO0FBQ0EsT0FBTztBQUFBLGtHQUFDO0FBQ1I7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWl0by1mb3Jtcy9idWxtYS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vanMtc2hhMUAwLjYuMC9ub2RlX21vZHVsZXMvanMtc2hhMS9zcmMvc2hhMS5qcz9kNTBhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBbanMtc2hhMV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1zaGExfVxuICpcbiAqIEB2ZXJzaW9uIDAuNi4wXG4gKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXVxuICogQGNvcHlyaWdodCBDaGVuLCBZaS1DeXVhbiAyMDE0LTIwMTdcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgcm9vdCA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnID8gd2luZG93IDoge307XG4gIHZhciBOT0RFX0pTID0gIXJvb3QuSlNfU0hBMV9OT19OT0RFX0pTICYmIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcbiAgaWYgKE5PREVfSlMpIHtcbiAgICByb290ID0gZ2xvYmFsO1xuICB9XG4gIHZhciBDT01NT05fSlMgPSAhcm9vdC5KU19TSEExX05PX0NPTU1PTl9KUyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cztcbiAgdmFyIEFNRCA9IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZDtcbiAgdmFyIEhFWF9DSEFSUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJy5zcGxpdCgnJyk7XG4gIHZhciBFWFRSQSA9IFstMjE0NzQ4MzY0OCwgODM4ODYwOCwgMzI3NjgsIDEyOF07XG4gIHZhciBTSElGVCA9IFsyNCwgMTYsIDgsIDBdO1xuICB2YXIgT1VUUFVUX1RZUEVTID0gWydoZXgnLCAnYXJyYXknLCAnZGlnZXN0JywgJ2FycmF5QnVmZmVyJ107XG5cbiAgdmFyIGJsb2NrcyA9IFtdO1xuXG4gIHZhciBjcmVhdGVPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAob3V0cHV0VHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG5ldyBTaGExKHRydWUpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlT3V0cHV0TWV0aG9kKCdoZXgnKTtcbiAgICBpZiAoTk9ERV9KUykge1xuICAgICAgbWV0aG9kID0gbm9kZVdyYXAobWV0aG9kKTtcbiAgICB9XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgU2hhMSgpO1xuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZSgpLnVwZGF0ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgT1VUUFVUX1RZUEVTLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdHlwZSA9IE9VVFBVVF9UWVBFU1tpXTtcbiAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZU91dHB1dE1ldGhvZCh0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGhvZDtcbiAgfTtcblxuICB2YXIgbm9kZVdyYXAgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgdmFyIGNyeXB0byA9IGV2YWwoXCJyZXF1aXJlKCdjcnlwdG8nKVwiKTtcbiAgICB2YXIgQnVmZmVyID0gZXZhbChcInJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclwiKTtcbiAgICB2YXIgbm9kZU1ldGhvZCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShtZXNzYWdlLCAndXRmOCcpLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTtcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbWV0aG9kKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKG5ldyBCdWZmZXIobWVzc2FnZSkpLmRpZ2VzdCgnaGV4Jyk7XG4gICAgfTtcbiAgICByZXR1cm4gbm9kZU1ldGhvZDtcbiAgfTtcblxuICBmdW5jdGlvbiBTaGExKHNoYXJlZE1lbW9yeSkge1xuICAgIGlmIChzaGFyZWRNZW1vcnkpIHtcbiAgICAgIGJsb2Nrc1swXSA9IGJsb2Nrc1sxNl0gPSBibG9ja3NbMV0gPSBibG9ja3NbMl0gPSBibG9ja3NbM10gPVxuICAgICAgYmxvY2tzWzRdID0gYmxvY2tzWzVdID0gYmxvY2tzWzZdID0gYmxvY2tzWzddID1cbiAgICAgIGJsb2Nrc1s4XSA9IGJsb2Nrc1s5XSA9IGJsb2Nrc1sxMF0gPSBibG9ja3NbMTFdID1cbiAgICAgIGJsb2Nrc1sxMl0gPSBibG9ja3NbMTNdID0gYmxvY2tzWzE0XSA9IGJsb2Nrc1sxNV0gPSAwO1xuICAgICAgdGhpcy5ibG9ja3MgPSBibG9ja3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmxvY2tzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIH1cblxuICAgIHRoaXMuaDAgPSAweDY3NDUyMzAxO1xuICAgIHRoaXMuaDEgPSAweEVGQ0RBQjg5O1xuICAgIHRoaXMuaDIgPSAweDk4QkFEQ0ZFO1xuICAgIHRoaXMuaDMgPSAweDEwMzI1NDc2O1xuICAgIHRoaXMuaDQgPSAweEMzRDJFMUYwO1xuXG4gICAgdGhpcy5ibG9jayA9IHRoaXMuc3RhcnQgPSB0aGlzLmJ5dGVzID0gdGhpcy5oQnl0ZXMgPSAwO1xuICAgIHRoaXMuZmluYWxpemVkID0gdGhpcy5oYXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZpcnN0ID0gdHJ1ZTtcbiAgfVxuXG4gIFNoYTEucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3RTdHJpbmcgPSB0eXBlb2YobWVzc2FnZSkgIT09ICdzdHJpbmcnO1xuICAgIGlmIChub3RTdHJpbmcgJiYgbWVzc2FnZS5jb25zdHJ1Y3RvciA9PT0gcm9vdC5BcnJheUJ1ZmZlcikge1xuICAgICAgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuICAgIH1cbiAgICB2YXIgY29kZSwgaW5kZXggPSAwLCBpLCBsZW5ndGggPSBtZXNzYWdlLmxlbmd0aCB8fCAwLCBibG9ja3MgPSB0aGlzLmJsb2NrcztcblxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuaGFzaGVkKSB7XG4gICAgICAgIHRoaXMuaGFzaGVkID0gZmFsc2U7XG4gICAgICAgIGJsb2Nrc1swXSA9IHRoaXMuYmxvY2s7XG4gICAgICAgIGJsb2Nrc1sxNl0gPSBibG9ja3NbMV0gPSBibG9ja3NbMl0gPSBibG9ja3NbM10gPVxuICAgICAgICBibG9ja3NbNF0gPSBibG9ja3NbNV0gPSBibG9ja3NbNl0gPSBibG9ja3NbN10gPVxuICAgICAgICBibG9ja3NbOF0gPSBibG9ja3NbOV0gPSBibG9ja3NbMTBdID0gYmxvY2tzWzExXSA9XG4gICAgICAgIGJsb2Nrc1sxMl0gPSBibG9ja3NbMTNdID0gYmxvY2tzWzE0XSA9IGJsb2Nrc1sxNV0gPSAwO1xuICAgICAgfVxuXG4gICAgICBpZihub3RTdHJpbmcpIHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IDY0OyArK2luZGV4KSB7XG4gICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gbWVzc2FnZVtpbmRleF0gPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCA2NDsgKytpbmRleCkge1xuICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gY29kZSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4YzAgfCAoY29kZSA+PiA2KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ZTAgfCAoY29kZSA+PiAxMikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKG1lc3NhZ2UuY2hhckNvZGVBdCgrK2luZGV4KSAmIDB4M2ZmKSk7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhmMCB8IChjb2RlID4+IDE4KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiAxMikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdEJ5dGVJbmRleCA9IGk7XG4gICAgICB0aGlzLmJ5dGVzICs9IGkgLSB0aGlzLnN0YXJ0O1xuICAgICAgaWYgKGkgPj0gNjQpIHtcbiAgICAgICAgdGhpcy5ibG9jayA9IGJsb2Nrc1sxNl07XG4gICAgICAgIHRoaXMuc3RhcnQgPSBpIC0gNjQ7XG4gICAgICAgIHRoaXMuaGFzaCgpO1xuICAgICAgICB0aGlzLmhhc2hlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuYnl0ZXMgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICB0aGlzLmhCeXRlcyArPSB0aGlzLmJ5dGVzIC8gNDI5NDk2NzI5NiA8PCAwO1xuICAgICAgdGhpcy5ieXRlcyA9IHRoaXMuYnl0ZXMgJSA0Mjk0OTY3Mjk2O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBTaGExLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBibG9ja3MgPSB0aGlzLmJsb2NrcywgaSA9IHRoaXMubGFzdEJ5dGVJbmRleDtcbiAgICBibG9ja3NbMTZdID0gdGhpcy5ibG9jaztcbiAgICBibG9ja3NbaSA+PiAyXSB8PSBFWFRSQVtpICYgM107XG4gICAgdGhpcy5ibG9jayA9IGJsb2Nrc1sxNl07XG4gICAgaWYgKGkgPj0gNTYpIHtcbiAgICAgIGlmICghdGhpcy5oYXNoZWQpIHtcbiAgICAgICAgdGhpcy5oYXNoKCk7XG4gICAgICB9XG4gICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xuICAgICAgYmxvY2tzWzE2XSA9IGJsb2Nrc1sxXSA9IGJsb2Nrc1syXSA9IGJsb2Nrc1szXSA9XG4gICAgICBibG9ja3NbNF0gPSBibG9ja3NbNV0gPSBibG9ja3NbNl0gPSBibG9ja3NbN10gPVxuICAgICAgYmxvY2tzWzhdID0gYmxvY2tzWzldID0gYmxvY2tzWzEwXSA9IGJsb2Nrc1sxMV0gPVxuICAgICAgYmxvY2tzWzEyXSA9IGJsb2Nrc1sxM10gPSBibG9ja3NbMTRdID0gYmxvY2tzWzE1XSA9IDA7XG4gICAgfVxuICAgIGJsb2Nrc1sxNF0gPSB0aGlzLmhCeXRlcyA8PCAzIHwgdGhpcy5ieXRlcyA+Pj4gMjk7XG4gICAgYmxvY2tzWzE1XSA9IHRoaXMuYnl0ZXMgPDwgMztcbiAgICB0aGlzLmhhc2goKTtcbiAgfTtcblxuICBTaGExLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhID0gdGhpcy5oMCwgYiA9IHRoaXMuaDEsIGMgPSB0aGlzLmgyLCBkID0gdGhpcy5oMywgZSA9IHRoaXMuaDQ7XG4gICAgdmFyIGYsIGosIHQsIGJsb2NrcyA9IHRoaXMuYmxvY2tzO1xuXG4gICAgZm9yKGogPSAxNjsgaiA8IDgwOyArK2opIHtcbiAgICAgIHQgPSBibG9ja3NbaiAtIDNdIF4gYmxvY2tzW2ogLSA4XSBeIGJsb2Nrc1tqIC0gMTRdIF4gYmxvY2tzW2ogLSAxNl07XG4gICAgICBibG9ja3Nbal0gPSAgKHQgPDwgMSkgfCAodCA+Pj4gMzEpO1xuICAgIH1cblxuICAgIGZvcihqID0gMDsgaiA8IDIwOyBqICs9IDUpIHtcbiAgICAgIGYgPSAoYiAmIGMpIHwgKCh+YikgJiBkKTtcbiAgICAgIHQgPSAoYSA8PCA1KSB8IChhID4+PiAyNyk7XG4gICAgICBlID0gdCArIGYgKyBlICsgMTUxODUwMDI0OSArIGJsb2Nrc1tqXSA8PCAwO1xuICAgICAgYiA9IChiIDw8IDMwKSB8IChiID4+PiAyKTtcblxuICAgICAgZiA9IChhICYgYikgfCAoKH5hKSAmIGMpO1xuICAgICAgdCA9IChlIDw8IDUpIHwgKGUgPj4+IDI3KTtcbiAgICAgIGQgPSB0ICsgZiArIGQgKyAxNTE4NTAwMjQ5ICsgYmxvY2tzW2ogKyAxXSA8PCAwO1xuICAgICAgYSA9IChhIDw8IDMwKSB8IChhID4+PiAyKTtcblxuICAgICAgZiA9IChlICYgYSkgfCAoKH5lKSAmIGIpO1xuICAgICAgdCA9IChkIDw8IDUpIHwgKGQgPj4+IDI3KTtcbiAgICAgIGMgPSB0ICsgZiArIGMgKyAxNTE4NTAwMjQ5ICsgYmxvY2tzW2ogKyAyXSA8PCAwO1xuICAgICAgZSA9IChlIDw8IDMwKSB8IChlID4+PiAyKTtcblxuICAgICAgZiA9IChkICYgZSkgfCAoKH5kKSAmIGEpO1xuICAgICAgdCA9IChjIDw8IDUpIHwgKGMgPj4+IDI3KTtcbiAgICAgIGIgPSB0ICsgZiArIGIgKyAxNTE4NTAwMjQ5ICsgYmxvY2tzW2ogKyAzXSA8PCAwO1xuICAgICAgZCA9IChkIDw8IDMwKSB8IChkID4+PiAyKTtcblxuICAgICAgZiA9IChjICYgZCkgfCAoKH5jKSAmIGUpO1xuICAgICAgdCA9IChiIDw8IDUpIHwgKGIgPj4+IDI3KTtcbiAgICAgIGEgPSB0ICsgZiArIGEgKyAxNTE4NTAwMjQ5ICsgYmxvY2tzW2ogKyA0XSA8PCAwO1xuICAgICAgYyA9IChjIDw8IDMwKSB8IChjID4+PiAyKTtcbiAgICB9XG5cbiAgICBmb3IoOyBqIDwgNDA7IGogKz0gNSkge1xuICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgIHQgPSAoYSA8PCA1KSB8IChhID4+PiAyNyk7XG4gICAgICBlID0gdCArIGYgKyBlICsgMTg1OTc3NTM5MyArIGJsb2Nrc1tqXSA8PCAwO1xuICAgICAgYiA9IChiIDw8IDMwKSB8IChiID4+PiAyKTtcblxuICAgICAgZiA9IGEgXiBiIF4gYztcbiAgICAgIHQgPSAoZSA8PCA1KSB8IChlID4+PiAyNyk7XG4gICAgICBkID0gdCArIGYgKyBkICsgMTg1OTc3NTM5MyArIGJsb2Nrc1tqICsgMV0gPDwgMDtcbiAgICAgIGEgPSAoYSA8PCAzMCkgfCAoYSA+Pj4gMik7XG5cbiAgICAgIGYgPSBlIF4gYSBeIGI7XG4gICAgICB0ID0gKGQgPDwgNSkgfCAoZCA+Pj4gMjcpO1xuICAgICAgYyA9IHQgKyBmICsgYyArIDE4NTk3NzUzOTMgKyBibG9ja3NbaiArIDJdIDw8IDA7XG4gICAgICBlID0gKGUgPDwgMzApIHwgKGUgPj4+IDIpO1xuXG4gICAgICBmID0gZCBeIGUgXiBhO1xuICAgICAgdCA9IChjIDw8IDUpIHwgKGMgPj4+IDI3KTtcbiAgICAgIGIgPSB0ICsgZiArIGIgKyAxODU5Nzc1MzkzICsgYmxvY2tzW2ogKyAzXSA8PCAwO1xuICAgICAgZCA9IChkIDw8IDMwKSB8IChkID4+PiAyKTtcblxuICAgICAgZiA9IGMgXiBkIF4gZTtcbiAgICAgIHQgPSAoYiA8PCA1KSB8IChiID4+PiAyNyk7XG4gICAgICBhID0gdCArIGYgKyBhICsgMTg1OTc3NTM5MyArIGJsb2Nrc1tqICsgNF0gPDwgMDtcbiAgICAgIGMgPSAoYyA8PCAzMCkgfCAoYyA+Pj4gMik7XG4gICAgfVxuXG4gICAgZm9yKDsgaiA8IDYwOyBqICs9IDUpIHtcbiAgICAgIGYgPSAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCk7XG4gICAgICB0ID0gKGEgPDwgNSkgfCAoYSA+Pj4gMjcpO1xuICAgICAgZSA9IHQgKyBmICsgZSAtIDE4OTQwMDc1ODggKyBibG9ja3Nbal0gPDwgMDtcbiAgICAgIGIgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XG5cbiAgICAgIGYgPSAoYSAmIGIpIHwgKGEgJiBjKSB8IChiICYgYyk7XG4gICAgICB0ID0gKGUgPDwgNSkgfCAoZSA+Pj4gMjcpO1xuICAgICAgZCA9IHQgKyBmICsgZCAtIDE4OTQwMDc1ODggKyBibG9ja3NbaiArIDFdIDw8IDA7XG4gICAgICBhID0gKGEgPDwgMzApIHwgKGEgPj4+IDIpO1xuXG4gICAgICBmID0gKGUgJiBhKSB8IChlICYgYikgfCAoYSAmIGIpO1xuICAgICAgdCA9IChkIDw8IDUpIHwgKGQgPj4+IDI3KTtcbiAgICAgIGMgPSB0ICsgZiArIGMgLSAxODk0MDA3NTg4ICsgYmxvY2tzW2ogKyAyXSA8PCAwO1xuICAgICAgZSA9IChlIDw8IDMwKSB8IChlID4+PiAyKTtcblxuICAgICAgZiA9IChkICYgZSkgfCAoZCAmIGEpIHwgKGUgJiBhKTtcbiAgICAgIHQgPSAoYyA8PCA1KSB8IChjID4+PiAyNyk7XG4gICAgICBiID0gdCArIGYgKyBiIC0gMTg5NDAwNzU4OCArIGJsb2Nrc1tqICsgM10gPDwgMDtcbiAgICAgIGQgPSAoZCA8PCAzMCkgfCAoZCA+Pj4gMik7XG5cbiAgICAgIGYgPSAoYyAmIGQpIHwgKGMgJiBlKSB8IChkICYgZSk7XG4gICAgICB0ID0gKGIgPDwgNSkgfCAoYiA+Pj4gMjcpO1xuICAgICAgYSA9IHQgKyBmICsgYSAtIDE4OTQwMDc1ODggKyBibG9ja3NbaiArIDRdIDw8IDA7XG4gICAgICBjID0gKGMgPDwgMzApIHwgKGMgPj4+IDIpO1xuICAgIH1cblxuICAgIGZvcig7IGogPCA4MDsgaiArPSA1KSB7XG4gICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgdCA9IChhIDw8IDUpIHwgKGEgPj4+IDI3KTtcbiAgICAgIGUgPSB0ICsgZiArIGUgLSA4OTk0OTc1MTQgKyBibG9ja3Nbal0gPDwgMDtcbiAgICAgIGIgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XG5cbiAgICAgIGYgPSBhIF4gYiBeIGM7XG4gICAgICB0ID0gKGUgPDwgNSkgfCAoZSA+Pj4gMjcpO1xuICAgICAgZCA9IHQgKyBmICsgZCAtIDg5OTQ5NzUxNCArIGJsb2Nrc1tqICsgMV0gPDwgMDtcbiAgICAgIGEgPSAoYSA8PCAzMCkgfCAoYSA+Pj4gMik7XG5cbiAgICAgIGYgPSBlIF4gYSBeIGI7XG4gICAgICB0ID0gKGQgPDwgNSkgfCAoZCA+Pj4gMjcpO1xuICAgICAgYyA9IHQgKyBmICsgYyAtIDg5OTQ5NzUxNCArIGJsb2Nrc1tqICsgMl0gPDwgMDtcbiAgICAgIGUgPSAoZSA8PCAzMCkgfCAoZSA+Pj4gMik7XG5cbiAgICAgIGYgPSBkIF4gZSBeIGE7XG4gICAgICB0ID0gKGMgPDwgNSkgfCAoYyA+Pj4gMjcpO1xuICAgICAgYiA9IHQgKyBmICsgYiAtIDg5OTQ5NzUxNCArIGJsb2Nrc1tqICsgM10gPDwgMDtcbiAgICAgIGQgPSAoZCA8PCAzMCkgfCAoZCA+Pj4gMik7XG5cbiAgICAgIGYgPSBjIF4gZCBeIGU7XG4gICAgICB0ID0gKGIgPDwgNSkgfCAoYiA+Pj4gMjcpO1xuICAgICAgYSA9IHQgKyBmICsgYSAtIDg5OTQ5NzUxNCArIGJsb2Nrc1tqICsgNF0gPDwgMDtcbiAgICAgIGMgPSAoYyA8PCAzMCkgfCAoYyA+Pj4gMik7XG4gICAgfVxuXG4gICAgdGhpcy5oMCA9IHRoaXMuaDAgKyBhIDw8IDA7XG4gICAgdGhpcy5oMSA9IHRoaXMuaDEgKyBiIDw8IDA7XG4gICAgdGhpcy5oMiA9IHRoaXMuaDIgKyBjIDw8IDA7XG4gICAgdGhpcy5oMyA9IHRoaXMuaDMgKyBkIDw8IDA7XG4gICAgdGhpcy5oNCA9IHRoaXMuaDQgKyBlIDw8IDA7XG4gIH07XG5cbiAgU2hhMS5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBoMCA9IHRoaXMuaDAsIGgxID0gdGhpcy5oMSwgaDIgPSB0aGlzLmgyLCBoMyA9IHRoaXMuaDMsIGg0ID0gdGhpcy5oNDtcblxuICAgIHJldHVybiBIRVhfQ0hBUlNbKGgwID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMCA+PiAyNCkgJiAweDBGXSArXG4gICAgICAgICAgIEhFWF9DSEFSU1soaDAgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgwID4+IDE2KSAmIDB4MEZdICtcbiAgICAgICAgICAgSEVYX0NIQVJTWyhoMCA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDAgPj4gOCkgJiAweDBGXSArXG4gICAgICAgICAgIEhFWF9DSEFSU1soaDAgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toMCAmIDB4MEZdICtcbiAgICAgICAgICAgSEVYX0NIQVJTWyhoMSA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDEgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgICAgICBIRVhfQ0hBUlNbKGgxID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMSA+PiAxNikgJiAweDBGXSArXG4gICAgICAgICAgIEhFWF9DSEFSU1soaDEgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgxID4+IDgpICYgMHgwRl0gK1xuICAgICAgICAgICBIRVhfQ0hBUlNbKGgxID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDEgJiAweDBGXSArXG4gICAgICAgICAgIEhFWF9DSEFSU1soaDIgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgyID4+IDI0KSAmIDB4MEZdICtcbiAgICAgICAgICAgSEVYX0NIQVJTWyhoMiA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDIgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgICAgICBIRVhfQ0hBUlNbKGgyID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMiA+PiA4KSAmIDB4MEZdICtcbiAgICAgICAgICAgSEVYX0NIQVJTWyhoMiA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2gyICYgMHgwRl0gK1xuICAgICAgICAgICBIRVhfQ0hBUlNbKGgzID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMyA+PiAyNCkgJiAweDBGXSArXG4gICAgICAgICAgIEhFWF9DSEFSU1soaDMgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgzID4+IDE2KSAmIDB4MEZdICtcbiAgICAgICAgICAgSEVYX0NIQVJTWyhoMyA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDMgPj4gOCkgJiAweDBGXSArXG4gICAgICAgICAgIEhFWF9DSEFSU1soaDMgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toMyAmIDB4MEZdICtcbiAgICAgICAgICAgSEVYX0NIQVJTWyhoNCA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDQgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNCA+PiAxNikgJiAweDBGXSArXG4gICAgICAgICAgIEhFWF9DSEFSU1soaDQgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg0ID4+IDgpICYgMHgwRl0gK1xuICAgICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDQgJiAweDBGXTtcbiAgfTtcblxuICBTaGExLnByb3RvdHlwZS50b1N0cmluZyA9IFNoYTEucHJvdG90eXBlLmhleDtcblxuICBTaGExLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuXG4gICAgdmFyIGgwID0gdGhpcy5oMCwgaDEgPSB0aGlzLmgxLCBoMiA9IHRoaXMuaDIsIGgzID0gdGhpcy5oMywgaDQgPSB0aGlzLmg0O1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIChoMCA+PiAyNCkgJiAweEZGLCAoaDAgPj4gMTYpICYgMHhGRiwgKGgwID4+IDgpICYgMHhGRiwgaDAgJiAweEZGLFxuICAgICAgKGgxID4+IDI0KSAmIDB4RkYsIChoMSA+PiAxNikgJiAweEZGLCAoaDEgPj4gOCkgJiAweEZGLCBoMSAmIDB4RkYsXG4gICAgICAoaDIgPj4gMjQpICYgMHhGRiwgKGgyID4+IDE2KSAmIDB4RkYsIChoMiA+PiA4KSAmIDB4RkYsIGgyICYgMHhGRixcbiAgICAgIChoMyA+PiAyNCkgJiAweEZGLCAoaDMgPj4gMTYpICYgMHhGRiwgKGgzID4+IDgpICYgMHhGRiwgaDMgJiAweEZGLFxuICAgICAgKGg0ID4+IDI0KSAmIDB4RkYsIChoNCA+PiAxNikgJiAweEZGLCAoaDQgPj4gOCkgJiAweEZGLCBoNCAmIDB4RkZcbiAgICBdO1xuICB9O1xuXG4gIFNoYTEucHJvdG90eXBlLmFycmF5ID0gU2hhMS5wcm90b3R5cGUuZGlnZXN0O1xuXG4gIFNoYTEucHJvdG90eXBlLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMjApO1xuICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigwLCB0aGlzLmgwKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoNCwgdGhpcy5oMSk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDgsIHRoaXMuaDIpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigxMiwgdGhpcy5oMyk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDE2LCB0aGlzLmg0KTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xuXG4gIHZhciBleHBvcnRzID0gY3JlYXRlTWV0aG9kKCk7XG5cbiAgaWYgKENPTU1PTl9KUykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiAgfSBlbHNlIHtcbiAgICByb290LnNoYTEgPSBleHBvcnRzO1xuICAgIGlmIChBTUQpIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59KSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/.pnpm/js-sha1@0.6.0/node_modules/js-sha1/src/sha1.js\n")},"../../node_modules/.pnpm/react@19.1.0/node_modules/react/cjs/react-jsx-runtime.production.js":(__unused_webpack_module,exports)=>{"use strict";eval('/**\n * @license React\n * react-jsx-runtime.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),\n  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");\nfunction jsxProd(type, config, maybeKey) {\n  var key = null;\n  void 0 !== maybeKey && (key = "" + maybeKey);\n  void 0 !== config.key && (key = "" + config.key);\n  if ("key" in config) {\n    maybeKey = {};\n    for (var propName in config)\n      "key" !== propName && (maybeKey[propName] = config[propName]);\n  } else maybeKey = config;\n  config = maybeKey.ref;\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key,\n    ref: void 0 !== config ? config : null,\n    props: maybeKey\n  };\n}\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsxProd;\nexports.jsxs = jsxProd;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0QDE5LjEuMC9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLFdBQVc7QUFDWCxZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1pdG8tZm9ybXMvYnVsbWEvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0QDE5LjEuMC9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24uanM/MWM5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik7XG5mdW5jdGlvbiBqc3hQcm9kKHR5cGUsIGNvbmZpZywgbWF5YmVLZXkpIHtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiYgKGtleSA9IFwiXCIgKyBtYXliZUtleSk7XG4gIHZvaWQgMCAhPT0gY29uZmlnLmtleSAmJiAoa2V5ID0gXCJcIiArIGNvbmZpZy5rZXkpO1xuICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICBtYXliZUtleSA9IHt9O1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgfSBlbHNlIG1heWJlS2V5ID0gY29uZmlnO1xuICBjb25maWcgPSBtYXliZUtleS5yZWY7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogdm9pZCAwICE9PSBjb25maWcgPyBjb25maWcgOiBudWxsLFxuICAgIHByb3BzOiBtYXliZUtleVxuICB9O1xufVxuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLmpzeCA9IGpzeFByb2Q7XG5leHBvcnRzLmpzeHMgPSBqc3hQcm9kO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/.pnpm/react@19.1.0/node_modules/react/cjs/react-jsx-runtime.production.js\n')},"../../node_modules/.pnpm/react@19.1.0/node_modules/react/jsx-runtime.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nif (true) {\n  module.exports = __webpack_require__("../../node_modules/.pnpm/react@19.1.0/node_modules/react/cjs/react-jsx-runtime.production.js");\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0QDE5LjEuMC9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QyxFQUFFLG9JQUFpRTtBQUNuRSxFQUFFLEtBQUssRUFFTiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtaXRvLWZvcm1zL2J1bG1hLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdEAxOS4xLjAvbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzPzAxNjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/.pnpm/react@19.1.0/node_modules/react/jsx-runtime.js\n')},"../../node_modules/.pnpm/uuid-by-string@4.0.0/node_modules/uuid-by-string/src/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var lib = __webpack_require__(\"../../node_modules/.pnpm/uuid-by-string@4.0.0/node_modules/uuid-by-string/src/lib.js\");\n\n/** Uin8Array with zero items */\nvar EMPTY_UINT8_ARRAY = new Uint8Array(0);\n\n/**\n * Generates the Name-Based UUID hashes v3 and v5 according to RFC-4122\n * https://tools.ietf.org/html/rfc4122#section-4.3\n * @param {string} target Hashing target\n * @param {string} [namespace] Some name space within which generation occurs\n * @param {3|5} [version=5] Version of UUID. Available versions is 3 and 5\n * according to RFC-4122. The version is responsible for the hashing algorithm:\n * version 3 uses MD5, and version 5 uses SHA-1. Default is 5.\n * @returns {string} UUID\n */\nfunction generateUuid(target, namespace, version) {\n  if (typeof target !== 'string') {\n    throw TypeError('Value must be string');\n  }\n\n  if (typeof namespace === 'number') {\n    return generateUuid(target, undefined, namespace);\n  }\n\n  if (version == null) {\n    return generateUuid(target, namespace, 5);\n  }\n\n  if (version !== 3 && version !== 5) {\n    throw TypeError('Version of UUID can be only 3 or 5');\n  }\n\n  // Parsing target chars\n  var targetCharBuffer = lib.stringToCharBuffer(target);\n  var namespaceCharBuffer = typeof namespace === 'string' ? lib.parseUuid(namespace) : EMPTY_UINT8_ARRAY;\n\n  // Concatenation two buffers of strings to one\n  var buffer = lib.concatBuffers(namespaceCharBuffer, targetCharBuffer);\n\n  // Getting hash\n  var hash = version === 3 ? lib.md5Hash(buffer) : lib.sha1Hash(buffer);\n\n  return lib.hashToUuid(hash, version);\n}\n\n/**\n * Export module\n */\nmodule.exports = generateUuid;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3V1aWQtYnktc3RyaW5nQDQuMC4wL25vZGVfbW9kdWxlcy91dWlkLWJ5LXN0cmluZy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLHNGQUFPOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWl0by1mb3Jtcy9idWxtYS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdXVpZC1ieS1zdHJpbmdANC4wLjAvbm9kZV9tb2R1bGVzL3V1aWQtYnktc3RyaW5nL3NyYy9pbmRleC5qcz9iNTlhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBsaWIgPSByZXF1aXJlKCcuL2xpYicpO1xuXG4vKiogVWluOEFycmF5IHdpdGggemVybyBpdGVtcyAqL1xudmFyIEVNUFRZX1VJTlQ4X0FSUkFZID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG5cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBOYW1lLUJhc2VkIFVVSUQgaGFzaGVzIHYzIGFuZCB2NSBhY2NvcmRpbmcgdG8gUkZDLTQxMjJcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0MTIyI3NlY3Rpb24tNC4zXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0IEhhc2hpbmcgdGFyZ2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWVzcGFjZV0gU29tZSBuYW1lIHNwYWNlIHdpdGhpbiB3aGljaCBnZW5lcmF0aW9uIG9jY3Vyc1xuICogQHBhcmFtIHszfDV9IFt2ZXJzaW9uPTVdIFZlcnNpb24gb2YgVVVJRC4gQXZhaWxhYmxlIHZlcnNpb25zIGlzIDMgYW5kIDVcbiAqIGFjY29yZGluZyB0byBSRkMtNDEyMi4gVGhlIHZlcnNpb24gaXMgcmVzcG9uc2libGUgZm9yIHRoZSBoYXNoaW5nIGFsZ29yaXRobTpcbiAqIHZlcnNpb24gMyB1c2VzIE1ENSwgYW5kIHZlcnNpb24gNSB1c2VzIFNIQS0xLiBEZWZhdWx0IGlzIDUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBVVUlEXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVXVpZCh0YXJnZXQsIG5hbWVzcGFjZSwgdmVyc2lvbikge1xuICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1ZhbHVlIG11c3QgYmUgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG5hbWVzcGFjZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVVdWlkKHRhcmdldCwgdW5kZWZpbmVkLCBuYW1lc3BhY2UpO1xuICB9XG5cbiAgaWYgKHZlcnNpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBnZW5lcmF0ZVV1aWQodGFyZ2V0LCBuYW1lc3BhY2UsIDUpO1xuICB9XG5cbiAgaWYgKHZlcnNpb24gIT09IDMgJiYgdmVyc2lvbiAhPT0gNSkge1xuICAgIHRocm93IFR5cGVFcnJvcignVmVyc2lvbiBvZiBVVUlEIGNhbiBiZSBvbmx5IDMgb3IgNScpO1xuICB9XG5cbiAgLy8gUGFyc2luZyB0YXJnZXQgY2hhcnNcbiAgdmFyIHRhcmdldENoYXJCdWZmZXIgPSBsaWIuc3RyaW5nVG9DaGFyQnVmZmVyKHRhcmdldCk7XG4gIHZhciBuYW1lc3BhY2VDaGFyQnVmZmVyID0gdHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3N0cmluZycgPyBsaWIucGFyc2VVdWlkKG5hbWVzcGFjZSkgOiBFTVBUWV9VSU5UOF9BUlJBWTtcblxuICAvLyBDb25jYXRlbmF0aW9uIHR3byBidWZmZXJzIG9mIHN0cmluZ3MgdG8gb25lXG4gIHZhciBidWZmZXIgPSBsaWIuY29uY2F0QnVmZmVycyhuYW1lc3BhY2VDaGFyQnVmZmVyLCB0YXJnZXRDaGFyQnVmZmVyKTtcblxuICAvLyBHZXR0aW5nIGhhc2hcbiAgdmFyIGhhc2ggPSB2ZXJzaW9uID09PSAzID8gbGliLm1kNUhhc2goYnVmZmVyKSA6IGxpYi5zaGExSGFzaChidWZmZXIpO1xuXG4gIHJldHVybiBsaWIuaGFzaFRvVXVpZChoYXNoLCB2ZXJzaW9uKTtcbn1cblxuLyoqXG4gKiBFeHBvcnQgbW9kdWxlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVVdWlkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/.pnpm/uuid-by-string@4.0.0/node_modules/uuid-by-string/src/index.js\n")},"../../node_modules/.pnpm/uuid-by-string@4.0.0/node_modules/uuid-by-string/src/lib.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var md5 = __webpack_require__(\"../../node_modules/.pnpm/js-md5@0.7.3/node_modules/js-md5/src/md5.js\");\nvar sha1 = __webpack_require__(\"../../node_modules/.pnpm/js-sha1@0.6.0/node_modules/js-sha1/src/sha1.js\");\n\n/** List of hex digit for fast accessing by index */\nvar HEX_DIGITS = '0123456789abcdef'.split('');\n\n/** Length of string containing uuid */\nvar UUID_LENGTH = 36;\n\n/** Regular expression for uuid testing */\nvar UUID_REGEXP = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n\n/** Map matching of hex number and corresponding byte */\nvar HEX_TO_BYTE_MAP = (function () {\n  var map = {};\n\n  for (var i = 0; i < 256; i++) {\n    var hex = i.toString(16);\n\n    map[hex.length === 1 ? '0' + hex : hex] = i;\n  }\n\n  return map;\n})();\n\n/**\n * Converts unsigned byte to hex representation\n * @param {number} ubyte The unsigned byte to convert\n * @returns {string} The hex representation\n */\nvar uint8ToHex = function (ubyte) {\n  var first = ubyte >> 4;\n  var second = ubyte - (first << 4);\n\n  return HEX_DIGITS[first] + HEX_DIGITS[second];\n};\n\n/**\n * Converts unsigned byte buffer to hex string\n * @param {Uint8Array} buf The unsigned bytes buffer\n * @returns {string} The hex string representation\n */\nvar uint8ArrayToHex = function (buf) {\n  var out = '';\n\n  for (var i = 0; i < buf.length; i++) {\n    out += uint8ToHex(buf[i]);\n  }\n\n  return out;\n};\n\n/**\n * Converts string to buffer of char codes\n * @param {string} str The string to parse\n * @returns {Uint8Array} Buffer of char codes\n */\nvar stringToCharBuffer = function (str) {\n  var escapedStr = unescape(encodeURIComponent(str));\n  var buffer = new Uint8Array(escapedStr.length);\n\n  for (var i = 0; i < escapedStr.length; i++) {\n    buffer[i] = escapedStr[i].charCodeAt(0);\n  }\n\n  return buffer;\n};\n\n/**\n * Generates MD5 hash from buffer\n * @param {Uint8Array} buf Buffer of char codes\n * @returns {Uint8Array} MD5 hash buffer\n */\nvar md5Hash = function (buf) {\n  return new Uint8Array(md5.arrayBuffer(buf));\n};\n\n/**\n * Generates SHA-1 hash from buffer\n * @param {Uint8Array} buf Buffer of char codes\n * @returns {Uint8Array} SHA-1 hash buffer\n */\nvar sha1Hash = function (buf) {\n  return new Uint8Array(sha1.arrayBuffer(buf));\n};\n\n/**\n * Concatenates two uint8 buffers\n * @param {Uint8Array} buf1 The first buffer to concatenate\n * @param {Uint8Array} buf2 The second buffer to concatenate\n * @returns {Uint8Array} Concatenation result\n */\nvar concatBuffers = function (buf1, buf2) {\n  var out = new Uint8Array(buf1.length + buf2.length);\n\n  out.set(new Uint8Array(buf1), 0);\n  out.set(new Uint8Array(buf2), buf1.byteLength);\n\n  return out;\n};\n\n/**\n * Validates UUID\n * @param {string} uuid UUID to validate\n * @return {boolean} Validation result\n */\nvar validateUuid = function (uuid) {\n  return typeof uuid === 'string' && uuid.length === UUID_LENGTH && UUID_REGEXP.test(uuid);\n};\n\n/**\n * Parses UUID into a buffer\n * @param {string} uuid UUID to parse\n * @returns {Uint8Array} Ready buffer\n */\nvar parseUuid = function (uuid) {\n  if (!validateUuid(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  var buf = new Uint8Array(16);\n  var strIndex = 0;\n  var bufIndex = 0;\n\n  while (strIndex < uuid.length) {\n    if (uuid[strIndex] === '-') {\n      strIndex++;\n      continue;\n    }\n\n    var oct = (uuid[strIndex] + uuid[strIndex + 1]).toLowerCase();\n    buf[bufIndex] = HEX_TO_BYTE_MAP[oct];\n\n    bufIndex++;\n    strIndex += 2;\n  }\n\n  return buf;\n};\n\n/**\n * Creates uuid from hash buffer\n * @param {Uint8Array} hashBuffer Hash buffer\n * @param {3|5} version Version of uuid\n * @returns {string} The uuid\n */\nvar hashToUuid = function (hashBuffer, version) {\n  return (\n    // The low field of the timestamp\n    uint8ArrayToHex(hashBuffer.slice(0, 4)) +\n    '-' +\n    // The middle field of the timestamp\n    uint8ArrayToHex(hashBuffer.slice(4, 6)) +\n    '-' +\n    // The high field of the timestamp multiplexed with the version number\n    uint8ToHex((hashBuffer[6] & 0x0f) | parseInt(version * 10, 16)) +\n    uint8ToHex(hashBuffer[7]) +\n    '-' +\n    // The high field of the clock sequence multiplexed with the variant\n    uint8ToHex((hashBuffer[8] & 0x3f) | 0x80) +\n    // The low field of the clock sequence\n    uint8ToHex(hashBuffer[9]) +\n    '-' +\n    //  The spatially unique node identifier\n    uint8ArrayToHex(hashBuffer.slice(10, 16))\n  );\n};\n\nmodule.exports = {\n  uint8ToHex: uint8ToHex,\n  uint8ArrayToHex: uint8ArrayToHex,\n  stringToCharBuffer: stringToCharBuffer,\n  md5Hash: md5Hash,\n  sha1Hash: sha1Hash,\n  concatBuffers: concatBuffers,\n  validateUuid: validateUuid,\n  parseUuid: parseUuid,\n  hashToUuid: hashToUuid,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3V1aWQtYnktc3RyaW5nQDQuMC4wL25vZGVfbW9kdWxlcy91dWlkLWJ5LXN0cmluZy9zcmMvbGliLmpzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyxzRUFBUTtBQUMxQixXQUFXLG1CQUFPLENBQUMseUVBQVM7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsaUJBQWlCLEVBQUUsVUFBVSxHQUFHOztBQUU1RjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1pdG8tZm9ybXMvYnVsbWEvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3V1aWQtYnktc3RyaW5nQDQuMC4wL25vZGVfbW9kdWxlcy91dWlkLWJ5LXN0cmluZy9zcmMvbGliLmpzPzcwMTUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIG1kNSA9IHJlcXVpcmUoJ2pzLW1kNScpO1xudmFyIHNoYTEgPSByZXF1aXJlKCdqcy1zaGExJyk7XG5cbi8qKiBMaXN0IG9mIGhleCBkaWdpdCBmb3IgZmFzdCBhY2Nlc3NpbmcgYnkgaW5kZXggKi9cbnZhciBIRVhfRElHSVRTID0gJzAxMjM0NTY3ODlhYmNkZWYnLnNwbGl0KCcnKTtcblxuLyoqIExlbmd0aCBvZiBzdHJpbmcgY29udGFpbmluZyB1dWlkICovXG52YXIgVVVJRF9MRU5HVEggPSAzNjtcblxuLyoqIFJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgdXVpZCB0ZXN0aW5nICovXG52YXIgVVVJRF9SRUdFWFAgPSAvXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVswLTVdWzAtOWEtZl17M30tWzA4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfSQvaTtcblxuLyoqIE1hcCBtYXRjaGluZyBvZiBoZXggbnVtYmVyIGFuZCBjb3JyZXNwb25kaW5nIGJ5dGUgKi9cbnZhciBIRVhfVE9fQllURV9NQVAgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgbWFwID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgIHZhciBoZXggPSBpLnRvU3RyaW5nKDE2KTtcblxuICAgIG1hcFtoZXgubGVuZ3RoID09PSAxID8gJzAnICsgaGV4IDogaGV4XSA9IGk7XG4gIH1cblxuICByZXR1cm4gbWFwO1xufSkoKTtcblxuLyoqXG4gKiBDb252ZXJ0cyB1bnNpZ25lZCBieXRlIHRvIGhleCByZXByZXNlbnRhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHVieXRlIFRoZSB1bnNpZ25lZCBieXRlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBoZXggcmVwcmVzZW50YXRpb25cbiAqL1xudmFyIHVpbnQ4VG9IZXggPSBmdW5jdGlvbiAodWJ5dGUpIHtcbiAgdmFyIGZpcnN0ID0gdWJ5dGUgPj4gNDtcbiAgdmFyIHNlY29uZCA9IHVieXRlIC0gKGZpcnN0IDw8IDQpO1xuXG4gIHJldHVybiBIRVhfRElHSVRTW2ZpcnN0XSArIEhFWF9ESUdJVFNbc2Vjb25kXTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdW5zaWduZWQgYnl0ZSBidWZmZXIgdG8gaGV4IHN0cmluZ1xuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGhlIHVuc2lnbmVkIGJ5dGVzIGJ1ZmZlclxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGhleCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqL1xudmFyIHVpbnQ4QXJyYXlUb0hleCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgdmFyIG91dCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0ICs9IHVpbnQ4VG9IZXgoYnVmW2ldKTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBidWZmZXIgb2YgY2hhciBjb2Rlc1xuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHBhcnNlXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyIG9mIGNoYXIgY29kZXNcbiAqL1xudmFyIHN0cmluZ1RvQ2hhckJ1ZmZlciA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGVzY2FwZWRTdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG4gIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShlc2NhcGVkU3RyLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlc2NhcGVkU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyW2ldID0gZXNjYXBlZFN0cltpXS5jaGFyQ29kZUF0KDApO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIE1ENSBoYXNoIGZyb20gYnVmZmVyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBCdWZmZXIgb2YgY2hhciBjb2Rlc1xuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IE1ENSBoYXNoIGJ1ZmZlclxuICovXG52YXIgbWQ1SGFzaCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG1kNS5hcnJheUJ1ZmZlcihidWYpKTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIFNIQS0xIGhhc2ggZnJvbSBidWZmZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIEJ1ZmZlciBvZiBjaGFyIGNvZGVzXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gU0hBLTEgaGFzaCBidWZmZXJcbiAqL1xudmFyIHNoYTFIYXNoID0gZnVuY3Rpb24gKGJ1Zikge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2hhMS5hcnJheUJ1ZmZlcihidWYpKTtcbn07XG5cbi8qKlxuICogQ29uY2F0ZW5hdGVzIHR3byB1aW50OCBidWZmZXJzXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZjEgVGhlIGZpcnN0IGJ1ZmZlciB0byBjb25jYXRlbmF0ZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYyIFRoZSBzZWNvbmQgYnVmZmVyIHRvIGNvbmNhdGVuYXRlXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQ29uY2F0ZW5hdGlvbiByZXN1bHRcbiAqL1xudmFyIGNvbmNhdEJ1ZmZlcnMgPSBmdW5jdGlvbiAoYnVmMSwgYnVmMikge1xuICB2YXIgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoYnVmMS5sZW5ndGggKyBidWYyLmxlbmd0aCk7XG5cbiAgb3V0LnNldChuZXcgVWludDhBcnJheShidWYxKSwgMCk7XG4gIG91dC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmMiksIGJ1ZjEuYnl0ZUxlbmd0aCk7XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIFVVSURcbiAqIEBwYXJhbSB7c3RyaW5nfSB1dWlkIFVVSUQgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbnZhciB2YWxpZGF0ZVV1aWQgPSBmdW5jdGlvbiAodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIHV1aWQubGVuZ3RoID09PSBVVUlEX0xFTkdUSCAmJiBVVUlEX1JFR0VYUC50ZXN0KHV1aWQpO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgVVVJRCBpbnRvIGEgYnVmZmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXVpZCBVVUlEIHRvIHBhcnNlXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gUmVhZHkgYnVmZmVyXG4gKi9cbnZhciBwYXJzZVV1aWQgPSBmdW5jdGlvbiAodXVpZCkge1xuICBpZiAoIXZhbGlkYXRlVXVpZCh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICB2YXIgc3RySW5kZXggPSAwO1xuICB2YXIgYnVmSW5kZXggPSAwO1xuXG4gIHdoaWxlIChzdHJJbmRleCA8IHV1aWQubGVuZ3RoKSB7XG4gICAgaWYgKHV1aWRbc3RySW5kZXhdID09PSAnLScpIHtcbiAgICAgIHN0ckluZGV4Kys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgb2N0ID0gKHV1aWRbc3RySW5kZXhdICsgdXVpZFtzdHJJbmRleCArIDFdKS50b0xvd2VyQ2FzZSgpO1xuICAgIGJ1ZltidWZJbmRleF0gPSBIRVhfVE9fQllURV9NQVBbb2N0XTtcblxuICAgIGJ1ZkluZGV4Kys7XG4gICAgc3RySW5kZXggKz0gMjtcbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgdXVpZCBmcm9tIGhhc2ggYnVmZmVyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGhhc2hCdWZmZXIgSGFzaCBidWZmZXJcbiAqIEBwYXJhbSB7M3w1fSB2ZXJzaW9uIFZlcnNpb24gb2YgdXVpZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHV1aWRcbiAqL1xudmFyIGhhc2hUb1V1aWQgPSBmdW5jdGlvbiAoaGFzaEJ1ZmZlciwgdmVyc2lvbikge1xuICByZXR1cm4gKFxuICAgIC8vIFRoZSBsb3cgZmllbGQgb2YgdGhlIHRpbWVzdGFtcFxuICAgIHVpbnQ4QXJyYXlUb0hleChoYXNoQnVmZmVyLnNsaWNlKDAsIDQpKSArXG4gICAgJy0nICtcbiAgICAvLyBUaGUgbWlkZGxlIGZpZWxkIG9mIHRoZSB0aW1lc3RhbXBcbiAgICB1aW50OEFycmF5VG9IZXgoaGFzaEJ1ZmZlci5zbGljZSg0LCA2KSkgK1xuICAgICctJyArXG4gICAgLy8gVGhlIGhpZ2ggZmllbGQgb2YgdGhlIHRpbWVzdGFtcCBtdWx0aXBsZXhlZCB3aXRoIHRoZSB2ZXJzaW9uIG51bWJlclxuICAgIHVpbnQ4VG9IZXgoKGhhc2hCdWZmZXJbNl0gJiAweDBmKSB8IHBhcnNlSW50KHZlcnNpb24gKiAxMCwgMTYpKSArXG4gICAgdWludDhUb0hleChoYXNoQnVmZmVyWzddKSArXG4gICAgJy0nICtcbiAgICAvLyBUaGUgaGlnaCBmaWVsZCBvZiB0aGUgY2xvY2sgc2VxdWVuY2UgbXVsdGlwbGV4ZWQgd2l0aCB0aGUgdmFyaWFudFxuICAgIHVpbnQ4VG9IZXgoKGhhc2hCdWZmZXJbOF0gJiAweDNmKSB8IDB4ODApICtcbiAgICAvLyBUaGUgbG93IGZpZWxkIG9mIHRoZSBjbG9jayBzZXF1ZW5jZVxuICAgIHVpbnQ4VG9IZXgoaGFzaEJ1ZmZlcls5XSkgK1xuICAgICctJyArXG4gICAgLy8gIFRoZSBzcGF0aWFsbHkgdW5pcXVlIG5vZGUgaWRlbnRpZmllclxuICAgIHVpbnQ4QXJyYXlUb0hleChoYXNoQnVmZmVyLnNsaWNlKDEwLCAxNikpXG4gICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdWludDhUb0hleDogdWludDhUb0hleCxcbiAgdWludDhBcnJheVRvSGV4OiB1aW50OEFycmF5VG9IZXgsXG4gIHN0cmluZ1RvQ2hhckJ1ZmZlcjogc3RyaW5nVG9DaGFyQnVmZmVyLFxuICBtZDVIYXNoOiBtZDVIYXNoLFxuICBzaGExSGFzaDogc2hhMUhhc2gsXG4gIGNvbmNhdEJ1ZmZlcnM6IGNvbmNhdEJ1ZmZlcnMsXG4gIHZhbGlkYXRlVXVpZDogdmFsaWRhdGVVdWlkLFxuICBwYXJzZVV1aWQ6IHBhcnNlVXVpZCxcbiAgaGFzaFRvVXVpZDogaGFzaFRvVXVpZCxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/.pnpm/uuid-by-string@4.0.0/node_modules/uuid-by-string/src/lib.js\n")}}]);