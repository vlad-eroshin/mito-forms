"use strict";(self.webpackChunk_mito_forms_bulma=self.webpackChunk_mito_forms_bulma||[]).push([[324],{"./src/stories/ListEditor.stories.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{Basic:()=>Basic,WithBorder:()=>WithBorder,WithHeaders:()=>WithHeaders,__namedExportsOrder:()=>__namedExportsOrder,default:()=>ListEditor_stories});var dist=__webpack_require__("../../node_modules/.pnpm/@storybook+test@8.6.12_storybook@8.6.12_prettier@3.5.3_/node_modules/@storybook/test/dist/index.mjs"),jsx_runtime=__webpack_require__("../../node_modules/.pnpm/react@19.1.0/node_modules/react/jsx-runtime.js"),core_dist=__webpack_require__("../../node_modules/.pnpm/@mito-forms+core@0.1.0-beta-2_typescript@5.8.3/node_modules/@mito-forms/core/dist/index.js"),react=__webpack_require__("../../node_modules/.pnpm/react@19.1.0/node_modules/react/index.js"),provider=__webpack_require__("../../node_modules/.pnpm/react-intl@7.1.6_react@19.1.0_typescript@5.8.3/node_modules/react-intl/lib/src/components/provider.js"),src=__webpack_require__("./src/index.tsx");const ListEditorWrapper=props=>{const contextVal=(0,react.useMemo)((()=>({dataSources:{},contextParams:{},componentRegistry:src.S,editorState:{formStates:{},editorResult:{}}})),[]);return(0,jsx_runtime.jsx)(provider.A,{locale:"en",messages:{},children:(0,jsx_runtime.jsx)(core_dist.pl.Provider,{value:contextVal,children:(0,jsx_runtime.jsx)(core_dist.qQ,{...props})})})};ListEditorWrapper.displayName="ListEditorWrapper",ListEditorWrapper.__docgenInfo={description:"",methods:[],displayName:"ListEditorWrapper",props:{rowFieldset:{required:!0,tsType:{name:"signature",type:"object",raw:"{\n  /**\n   * Fieldset name is required for the fieldset. Reducer is mapped to the\n   */\n  name: string;\n  /**\n   * List of input fields\n   */\n  fields: (InputField | FormDividerConfig)[];\n\n  /**\n   *  Configures field layout overrides layout on the level of fieldset\n   */\n  fieldsLayout?: FieldsLayout;\n\n  /**\n   * Used for list editor component configures how the fieldset is displayed\n   */\n  arrangeFields?: 'column' | 'row' | 'tableRow';\n  /**\n   * Field set title\n   */\n  title?: string;\n  /**\n   * Intended to be used for conditional display. For example if some field has certain value display this fieldset.\n   */\n  showIf?: ConditionInfo | ConditionInfo[];\n  /**\n   * allows collapse expand fieldset.\n   */\n  collapsible?: boolean;\n  collapsed?: boolean;\n  /**\n   * Data object locator in the overall data that is being edited.\n   */\n  jsonPath?: string;\n  /**\n   * Allows to manage show/hide title\n   */\n  showTitle?: boolean;\n  /**\n   * Data source binding for the fieldset.\n   */\n  dataSource?: DataSourceBinding;\n}",signature:{properties:[{key:"name",value:{name:"string",required:!0},description:"Fieldset name is required for the fieldset. Reducer is mapped to the"},{key:"fields",value:{name:"Array",elements:[{name:"unknown"}],raw:"(InputField | FormDividerConfig)[]",required:!0},description:"List of input fields"},{key:"fieldsLayout",value:{name:"union",raw:"'twoColumn' | 'compact' | 'twoColumnJustified'",elements:[{name:"literal",value:"'twoColumn'"},{name:"literal",value:"'compact'"},{name:"literal",value:"'twoColumnJustified'"}],required:!1},description:"Configures field layout overrides layout on the level of fieldset"},{key:"arrangeFields",value:{name:"union",raw:"'column' | 'row' | 'tableRow'",elements:[{name:"literal",value:"'column'"},{name:"literal",value:"'row'"},{name:"literal",value:"'tableRow'"}],required:!1},description:"Used for list editor component configures how the fieldset is displayed"},{key:"title",value:{name:"string",required:!1},description:"Field set title"},{key:"showIf",value:{name:"union",raw:"ConditionInfo | ConditionInfo[]",elements:[{name:"signature",type:"object",raw:"{\n  logic?: 'and' | 'or';\n  value: DefinedDataValue;\n  value2?: DefinedDataValue | null;\n  type: ConditionTypeEnum;\n}",signature:{properties:[{key:"logic",value:{name:"union",raw:"'and' | 'or'",elements:[{name:"literal",value:"'and'"},{name:"literal",value:"'or'"}],required:!1}},{key:"value",value:{name:"union",raw:"string | number | boolean",elements:[{name:"string"},{name:"number"},{name:"boolean"}],required:!0}},{key:"value2",value:{name:"union",raw:"DefinedDataValue | null",elements:[{name:"union",raw:"string | number | boolean",elements:[{name:"string"},{name:"number"},{name:"boolean"}],required:!0},{name:"null"}],required:!1}},{key:"type",value:{name:"ConditionTypeEnum",required:!0}}]}},{name:"Array",elements:[{name:"signature",type:"object",raw:"{\n  logic?: 'and' | 'or';\n  value: DefinedDataValue;\n  value2?: DefinedDataValue | null;\n  type: ConditionTypeEnum;\n}",signature:{properties:[{key:"logic",value:{name:"union",raw:"'and' | 'or'",elements:[{name:"literal",value:"'and'"},{name:"literal",value:"'or'"}],required:!1}},{key:"value",value:{name:"union",raw:"string | number | boolean",elements:[{name:"string"},{name:"number"},{name:"boolean"}],required:!0}},{key:"value2",value:{name:"union",raw:"DefinedDataValue | null",elements:[{name:"union",raw:"string | number | boolean",elements:[{name:"string"},{name:"number"},{name:"boolean"}],required:!0},{name:"null"}],required:!1}},{key:"type",value:{name:"ConditionTypeEnum",required:!0}}]}}],raw:"ConditionInfo[]"}],required:!1},description:"Intended to be used for conditional display. For example if some field has certain value display this fieldset."},{key:"collapsible",value:{name:"boolean",required:!1},description:"allows collapse expand fieldset."},{key:"collapsed",value:{name:"boolean",required:!1}},{key:"jsonPath",value:{name:"string",required:!1},description:"Data object locator in the overall data that is being edited."},{key:"showTitle",value:{name:"boolean",required:!1},description:"Allows to manage show/hide title"},{key:"dataSource",value:{name:"intersection",raw:"Omit<DataBinding, 'type'> & {\n  datasourceId: string;\n}",elements:[{name:"Omit",elements:[{name:"signature",type:"object",raw:'{\n  widgetId?: string;\n  datasourceId?: string;\n  type: ComponentTypeEnum;\n  /**\n   * targetProperty specifies where data will be injected if targetProperty is "$data" it means that data\n   * from Data Binding will be passed as the data to the component this is most useful for data visualization\n   * components.\n   */\n  targetProperty?: string;\n  staticValue?: object;\n  changeMode?: DataChangeMode;\n\n  // If specified, uses this property field on reach record as the unique ID for the merge behavior.\n  mergeOnField?: string;\n\n  jsonPath?: string;\n  /**\n   * Accessor Expression. Used to access values inside Object Hierarchies.\n   * Useful when for example DataSource result is in the format where the\n   * data produced by the data source requires child object. In case of\n   * Widget binding accessor can be used to access child hierarchy of\n   * the bound state.\n   *\n   *  Example 1: Data Source result is in format:\n   *\n   *    {\n   *      fullComparison: {...},\n   *      topRegressions: {...},\n   *      topImprovements: {...}\n   *    }\n   *\n   *  if Component requires only \'topRegressions\' object component can specify topRegressions as an accessor path.\n   *\n   *    {\n   *        accessor: {\n   *            type: AccessorType.FetchPropertyPath,\n   *            attributePath: \'topRegressions\'\n   *        }\n   *    }\n   *  Example 2: Data source result is an array of objects and we need to access only one property of the object or\n   *  one or two elements of the object. [{id: "1", title: "Title1"}, {id: "2", title: "Title2"}, {id: "3", title: "Title3"}]\n   *\n   *    {\n   *        type: AccessorType.RemapRecordsArray\n   *        propertyMap: {\n   *          id: "recordId"\n   *          title: "titleString"\n   *        }\n   *    }\n   *    produces result of:\n   *      [\n   *        {recordId: "1", titleString: "Title1"},\n   *        {recordId: "2", titleString: "Title1"},\n   *        {recordId: "3", titleString: "Title1"}\n   *      ]\n   */\n  accessor?: DataAccessor;\n  /**\n   * If specified data is first retrieved and the transformed accordingly (Currently not used)\n   */\n  transformers?: DataTransformer[];\n}',signature:{properties:[{key:"widgetId",value:{name:"string",required:!1}},{key:"datasourceId",value:{name:"string",required:!1}},{key:"type",value:{name:"ComponentTypeEnum",required:!0}},{key:"targetProperty",value:{name:"string",required:!1},description:'targetProperty specifies where data will be injected if targetProperty is "$data" it means that data\nfrom Data Binding will be passed as the data to the component this is most useful for data visualization\ncomponents.'},{key:"staticValue",value:{name:"object",required:!1}},{key:"changeMode",value:{name:"union",raw:"'replace' | 'merge'",elements:[{name:"literal",value:"'replace'"},{name:"literal",value:"'merge'"}],required:!1}},{key:"mergeOnField",value:{name:"string",required:!1}},{key:"jsonPath",value:{name:"string",required:!1}},{key:"accessor",value:{name:"signature",type:"object",raw:"{\n  type: AccessorType;\n  jsonPath?: string;\n  property?: string;\n}",signature:{properties:[{key:"type",value:{name:"AccessorType",required:!0}},{key:"jsonPath",value:{name:"string",required:!1}},{key:"property",value:{name:"string",required:!1}}]},required:!1},description:'Accessor Expression. Used to access values inside Object Hierarchies.\nUseful when for example DataSource result is in the format where the\ndata produced by the data source requires child object. In case of\nWidget binding accessor can be used to access child hierarchy of\nthe bound state.\n\n Example 1: Data Source result is in format:\n\n   {\n     fullComparison: {...},\n     topRegressions: {...},\n     topImprovements: {...}\n   }\n\n if Component requires only \'topRegressions\' object component can specify topRegressions as an accessor path.\n\n   {\n       accessor: {\n           type: AccessorType.FetchPropertyPath,\n           attributePath: \'topRegressions\'\n       }\n   }\n Example 2: Data source result is an array of objects and we need to access only one property of the object or\n one or two elements of the object. [{id: "1", title: "Title1"}, {id: "2", title: "Title2"}, {id: "3", title: "Title3"}]\n\n   {\n       type: AccessorType.RemapRecordsArray\n       propertyMap: {\n         id: "recordId"\n         title: "titleString"\n       }\n   }\n   produces result of:\n     [\n       {recordId: "1", titleString: "Title1"},\n       {recordId: "2", titleString: "Title1"},\n       {recordId: "3", titleString: "Title1"}\n     ]'},{key:"transformers",value:{name:"Array",elements:[{name:"signature",type:"object",raw:"{\n  type: TransformType;\n\n  /**\n   * if this property is specified the source object is retrieved from this path first\n   */\n  sourceJsonPath?: string;\n  /**\n   * source->target\n   */\n  propertyMap?: {\n    [key: string]: string;\n  };\n\n  /*\n   * List of properties (keys).\n   */\n  propertyKvList?: [string, string | number][];\n\n  objectTemplate?: object;\n\n  sortBy?: string; // field Name\n\n  groupBy?: string; // group by field name\n\n  sortOrder?: 'asc' | 'desc';\n\n  targetColumn?: string;\n\n  precision?: number; //Number of fraction digits\n\n  delimiter?: string;\n\n  targetJsonPath?: string;\n\n  targetProperty?: string;\n  sourceProperty?: string;\n  caseSensitive?: boolean;\n  datetimeFormat?: string;\n  value?: DefaultDataTypes;\n  valuesMap?: {\n    accessor?: DataAccessor;\n    data?: { [key: string]: DataCellValue };\n  };\n\n  // Used by filtering transformers\n  // If set to true, filter will include by condition\n  // If set to failse, filter will exclude by condition\n  include?: boolean;\n  splitBy?: string;\n}",signature:{properties:[{key:"type",value:{name:"TransformType",required:!0}},{key:"sourceJsonPath",value:{name:"string",required:!1},description:"if this property is specified the source object is retrieved from this path first"},{key:"propertyMap",value:{name:"signature",type:"object",raw:"{\n  [key: string]: string;\n}",signature:{properties:[{key:{name:"string"},value:{name:"string",required:!0}}]},required:!1},description:"source->target"},{key:"propertyKvList",value:{name:"Array",elements:[{name:"tuple",raw:"[string, string | number]",elements:[{name:"string"},{name:"union",raw:"string | number",elements:[{name:"string"},{name:"number"}]}]}],raw:"[string, string | number][]",required:!1}},{key:"objectTemplate",value:{name:"object",required:!1}},{key:"sortBy",value:{name:"string",required:!1}},{key:"groupBy",value:{name:"string",required:!1}},{key:"sortOrder",value:{name:"union",raw:"'asc' | 'desc'",elements:[{name:"literal",value:"'asc'"},{name:"literal",value:"'desc'"}],required:!1}},{key:"targetColumn",value:{name:"string",required:!1}},{key:"precision",value:{name:"number",required:!1}},{key:"delimiter",value:{name:"string",required:!1}},{key:"targetJsonPath",value:{name:"string",required:!1}},{key:"targetProperty",value:{name:"string",required:!1}},{key:"sourceProperty",value:{name:"string",required:!1}},{key:"caseSensitive",value:{name:"boolean",required:!1}},{key:"datetimeFormat",value:{name:"string",required:!1}},{key:"value",value:{name:"union",raw:"| RecordsArray\n| DataCellValue\n| (string | object)[]\n| { [key: string]: object | RecordsArray }\n| undefined",elements:[{name:"Array",elements:[{name:"signature",type:"object",raw:"{ [key: string]: DataCellValue }",signature:{properties:[{key:{name:"string"},value:{name:"union",raw:"string | number | boolean | object | object[] | null",elements:[{name:"string"},{name:"number"},{name:"boolean"},{name:"object"},{name:"Array",elements:[{name:"object"}],raw:"object[]"},{name:"null"}],required:!0}}]}}],raw:"DataRecord[]"},{name:"union",raw:"string | number | boolean | object | object[] | null",elements:[{name:"string"},{name:"number"},{name:"boolean"},{name:"object"},{name:"Array",elements:[{name:"object"}],raw:"object[]"},{name:"null"}],required:!0},{name:"Array",elements:[{name:"unknown"}],raw:"(string | object)[]"},{name:"signature",type:"object",raw:"{ [key: string]: object | RecordsArray }",signature:{properties:[{key:{name:"string"},value:{name:"union",raw:"object | RecordsArray",elements:[{name:"object"},{name:"Array",elements:[{name:"signature",type:"object",raw:"{ [key: string]: DataCellValue }",signature:{properties:[{key:{name:"string"},value:{name:"union",raw:"string | number | boolean | object | object[] | null",elements:[{name:"string"},{name:"number"},{name:"boolean"},{name:"object"},{name:"Array",elements:[{name:"object"}],raw:"object[]"},{name:"null"}],required:!0}}]}}],raw:"DataRecord[]"}],required:!0}}]}},{name:"undefined"}],required:!1}},{key:"valuesMap",value:{name:"signature",type:"object",raw:"{\n  accessor?: DataAccessor;\n  data?: { [key: string]: DataCellValue };\n}",signature:{properties:[{key:"accessor",value:{name:"signature",type:"object",raw:"{\n  type: AccessorType;\n  jsonPath?: string;\n  property?: string;\n}",signature:{properties:[{key:"type",value:{name:"AccessorType",required:!0}},{key:"jsonPath",value:{name:"string",required:!1}},{key:"property",value:{name:"string",required:!1}}]},required:!1}},{key:"data",value:{name:"signature",type:"object",raw:"{ [key: string]: DataCellValue }",signature:{properties:[{key:{name:"string"},value:{name:"union",raw:"string | number | boolean | object | object[] | null",elements:[{name:"string"},{name:"number"},{name:"boolean"},{name:"object"},{name:"Array",elements:[{name:"object"}],raw:"object[]"},{name:"null"}],required:!0}}]},required:!1}}]},required:!1}},{key:"include",value:{name:"boolean",required:!1}},{key:"splitBy",value:{name:"string",required:!1}}]}}],raw:"DataTransformer[]",required:!1},description:"If specified data is first retrieved and the transformed accordingly (Currently not used)"}]}},{name:"literal",value:"'type'"}],raw:"Omit<DataBinding, 'type'>"},{name:"signature",type:"object",raw:"{\n  datasourceId: string;\n}",signature:{properties:[{key:"datasourceId",value:{name:"string",required:!0}}]}}],required:!1},description:"Data source binding for the fieldset."}]}},description:""},data:{required:!0,tsType:{name:"object"},description:""},jsonPath:{required:!1,tsType:{name:"string"},description:""},showHeader:{required:!1,tsType:{name:"boolean"},description:""},canDeleteRows:{required:!1,tsType:{name:"union",raw:"boolean | undefined",elements:[{name:"boolean"},{name:"undefined"}]},description:""},showBorders:{required:!1,tsType:{name:"boolean"},description:""},onChange:{required:!1,tsType:{name:"signature",type:"function",raw:"(data: RecordsArray, isValid: boolean) => void",signature:{arguments:[{type:{name:"Array",elements:[{name:"signature",type:"object",raw:"{ [key: string]: DataCellValue }",signature:{properties:[{key:{name:"string"},value:{name:"union",raw:"string | number | boolean | object | object[] | null",elements:[{name:"string"},{name:"number"},{name:"boolean"},{name:"object"},{name:"Array",elements:[{name:"object"}],raw:"object[]"},{name:"null"}],required:!0}}]}}],raw:"DataRecord[]"},name:"data"},{type:{name:"boolean"},name:"isValid"}],return:{name:"void"}}},description:""},minItemsRequired:{required:!1,tsType:{name:"number"},description:""}}};const ListEditor_stories={title:"Form Editor/List Editor",component:ListEditorWrapper,decorators:[],parameters:{}},Basic={play:async({canvasElement})=>{const canvas=(0,dist.ux)(canvasElement),staticText=await canvas.findByText("Static Text Value 1");(0,dist.E3)(staticText).toBeInTheDocument();const textInput=await canvas.findByTestId("text-textValue-0");(0,dist.E3)(textInput).toBeInTheDocument(),(0,dist.E3)(textInput).toHaveAttribute("value"),(0,dist.E3)(textInput.getAttribute("value")).toBe("Text Value 1")},args:{rowFieldset:{name:"testFieldSet",fieldLayout:"compact",arrangeFields:"row",fields:[{label:"Some Label",name:"textValue",type:"text"},{label:"Another Label 123",name:"selector",type:"select",options:["Selector Value 1","Value 2"]},{label:"",name:"staticText",type:"staticText"},{label:"",name:"tagKeyLabel",type:"staticText"},{label:"Tags Selector",name:"tagsSelector",options:"{$.tagsSelector#options}",placeHolderText:"Select Tag",type:"select"}]},data:[{staticText:"Static Text Value 1",textValue:"Text Value 1",selector:"Selector Value 1","tagsSelector#options":["tag1","tag2"],tagKeyLabel:"TagKey1",tagsSelector:"tag2"},{staticText:"Static Text Value 2",textValue:"Text Value 2",selector:"Selector Value 2","tagsSelector#options":["tag aa","tag bb"],tagKeyLabel:"TagKey1"}]}},WithBorder={args:{showBorders:!0,rowFieldset:{name:"testFieldSet",fieldLayout:"compact",arrangeFields:"row",fields:[{label:"Some Label",name:"staticText",type:"text"},{label:"Another Label 123",name:"selector",type:"staticText"},{label:"",name:"tagKeyLabel",type:"staticText"},{label:"Tags Selector",name:"tagsSelector",options:"{$.tagsSelector#options}",placeHolderText:"Select Tag",type:"select"}]},data:[{staticText:"Static Text Value 1",selector:"Selector Value 1","tagsSelector#options":["tag1","tag2"],tagKeyLabel:"TagKey1",tagsSelector:"tag2"},{staticText:"Static Text Value 2",selector:"Selector Value 2","tagsSelector#options":["tag aa","tag bb"],tagKeyLabel:"TagKey1"}]}},WithHeaders={args:{showBorders:!0,canDeleteRows:!0,showHeader:!0,rowFieldset:{name:"testFieldSet",fieldLayout:"compact",arrangeFields:"row",fields:[{label:"Some Label",name:"staticText",type:"text"},{label:"Another Label 123",name:"selector",type:"staticText"},{label:"",name:"tagKeyLabel",type:"staticText"},{label:"Tags Selector",name:"tagsSelector",options:"{$.tagsSelector#options}",placeHolderText:"Select Tag",type:"select"}]},data:[{staticText:"Static Text Value 1",selector:"Selector Value 1","tagsSelector#options":["tag1","tag2"],tagKeyLabel:"TagKey1",tagsSelector:"tag2"},{staticText:"Static Text Value 2",selector:"Selector Value 2","tagsSelector#options":["tag aa","tag bb"],tagKeyLabel:"TagKey1"}]}},__namedExportsOrder=["Basic","WithBorder","WithHeaders"];Basic.parameters={...Basic.parameters,docs:{...Basic.parameters?.docs,source:{originalSource:"{\n  play: async ({\n    canvasElement\n  }) => {\n    const canvas = within(canvasElement);\n    const staticText = await canvas.findByText('Static Text Value 1');\n    expect(staticText).toBeInTheDocument();\n    const textInput = await canvas.findByTestId('text-textValue-0');\n    expect(textInput).toBeInTheDocument();\n    expect(textInput).toHaveAttribute('value');\n    expect(textInput.getAttribute('value')).toBe('Text Value 1');\n  },\n  args: {\n    rowFieldset: {\n      name: 'testFieldSet',\n      fieldLayout: 'compact',\n      arrangeFields: 'row',\n      fields: [{\n        label: 'Some Label',\n        name: 'textValue',\n        type: 'text'\n      }, {\n        label: 'Another Label 123',\n        name: 'selector',\n        type: 'select',\n        options: ['Selector Value 1', 'Value 2']\n      }, {\n        label: '',\n        name: 'staticText',\n        type: 'staticText'\n      }, {\n        label: '',\n        name: 'tagKeyLabel',\n        type: 'staticText'\n      }, {\n        label: 'Tags Selector',\n        name: 'tagsSelector',\n        options: '{$.tagsSelector#options}',\n        placeHolderText: 'Select Tag',\n        type: 'select'\n      }]\n    } as FieldSetMetadata,\n    data: [{\n      staticText: 'Static Text Value 1',\n      textValue: 'Text Value 1',\n      selector: 'Selector Value 1',\n      'tagsSelector#options': ['tag1', 'tag2'],\n      tagKeyLabel: 'TagKey1',\n      tagsSelector: 'tag2'\n    }, {\n      staticText: 'Static Text Value 2',\n      textValue: 'Text Value 2',\n      selector: 'Selector Value 2',\n      'tagsSelector#options': ['tag aa', 'tag bb'],\n      tagKeyLabel: 'TagKey1'\n    }]\n  }\n}",...Basic.parameters?.docs?.source}}},WithBorder.parameters={...WithBorder.parameters,docs:{...WithBorder.parameters?.docs,source:{originalSource:"{\n  args: {\n    showBorders: true,\n    rowFieldset: {\n      name: 'testFieldSet',\n      fieldLayout: 'compact',\n      arrangeFields: 'row',\n      fields: [{\n        label: 'Some Label',\n        name: 'staticText',\n        type: 'text'\n      }, {\n        label: 'Another Label 123',\n        name: 'selector',\n        type: 'staticText'\n      }, {\n        label: '',\n        name: 'tagKeyLabel',\n        type: 'staticText'\n      }, {\n        label: 'Tags Selector',\n        name: 'tagsSelector',\n        options: '{$.tagsSelector#options}',\n        placeHolderText: 'Select Tag',\n        type: 'select'\n      }]\n    } as FieldSetMetadata,\n    data: [{\n      staticText: 'Static Text Value 1',\n      selector: 'Selector Value 1',\n      'tagsSelector#options': ['tag1', 'tag2'],\n      tagKeyLabel: 'TagKey1',\n      tagsSelector: 'tag2'\n    }, {\n      staticText: 'Static Text Value 2',\n      selector: 'Selector Value 2',\n      'tagsSelector#options': ['tag aa', 'tag bb'],\n      tagKeyLabel: 'TagKey1'\n    }]\n  }\n}",...WithBorder.parameters?.docs?.source}}},WithHeaders.parameters={...WithHeaders.parameters,docs:{...WithHeaders.parameters?.docs,source:{originalSource:"{\n  args: {\n    showBorders: true,\n    canDeleteRows: true,\n    showHeader: true,\n    rowFieldset: {\n      name: 'testFieldSet',\n      fieldLayout: 'compact',\n      arrangeFields: 'row',\n      fields: [{\n        label: 'Some Label',\n        name: 'staticText',\n        type: 'text'\n      }, {\n        label: 'Another Label 123',\n        name: 'selector',\n        type: 'staticText'\n      }, {\n        label: '',\n        name: 'tagKeyLabel',\n        type: 'staticText'\n      }, {\n        label: 'Tags Selector',\n        name: 'tagsSelector',\n        options: '{$.tagsSelector#options}',\n        placeHolderText: 'Select Tag',\n        type: 'select'\n      }]\n    } as FieldSetMetadata,\n    data: [{\n      staticText: 'Static Text Value 1',\n      selector: 'Selector Value 1',\n      'tagsSelector#options': ['tag1', 'tag2'],\n      tagKeyLabel: 'TagKey1',\n      tagsSelector: 'tag2'\n    }, {\n      staticText: 'Static Text Value 2',\n      selector: 'Selector Value 2',\n      'tagsSelector#options': ['tag aa', 'tag bb'],\n      tagKeyLabel: 'TagKey1'\n    }]\n  }\n}",...WithHeaders.parameters?.docs?.source}}}}}]);